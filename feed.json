{
    "version": "https://jsonfeed.org/version/1",
    "title": "Alan",
    "subtitle": "",
    "icon": "http://47.97.229.110/images/favicon.ico",
    "description": "",
    "home_page_url": "http://47.97.229.110",
    "items": [
        {
            "id": "http://47.97.229.110/2021/02/22/2021%E6%96%B0%E5%B9%B4%E7%A5%9D%E6%84%BF/",
            "url": "http://47.97.229.110/2021/02/22/2021%E6%96%B0%E5%B9%B4%E7%A5%9D%E6%84%BF/",
            "title": "2021新年祝愿",
            "date_published": "2021-02-22T11:24:26.000Z",
            "content_html": "<h1 id=\"2021新年祝愿\"><a href=\"#2021新年祝愿\" class=\"headerlink\" title=\"2021新年祝愿\"></a>2021新年祝愿</h1><h2 id=\"我总吧我的生命想成只有一日，忙完一日，第二天清晨，一睁眼，一个又一个崭新的世界创造在面前，而在这一天里我又有许多不同的事不同的人待我去遇见，这让我看见这个世界原来是如此美好。很高兴的是，我还有许多个这样的一天等我去遇见，但很不幸的事，这些时间又太短了。希望在2021的往后的每一天里，都能完成已经有意义的事情\"><a href=\"#我总吧我的生命想成只有一日，忙完一日，第二天清晨，一睁眼，一个又一个崭新的世界创造在面前，而在这一天里我又有许多不同的事不同的人待我去遇见，这让我看见这个世界原来是如此美好。很高兴的是，我还有许多个这样的一天等我去遇见，但很不幸的事，这些时间又太短了。希望在2021的往后的每一天里，都能完成已经有意义的事情\" class=\"headerlink\" title=\"我总吧我的生命想成只有一日，忙完一日，第二天清晨，一睁眼，一个又一个崭新的世界创造在面前，而在这一天里我又有许多不同的事不同的人待我去遇见，这让我看见这个世界原来是如此美好。很高兴的是，我还有许多个这样的一天等我去遇见，但很不幸的事，这些时间又太短了。希望在2021的往后的每一天里，都能完成已经有意义的事情\"></a>我总吧我的生命想成只有一日，忙完一日，第二天清晨，一睁眼，一个又一个崭新的世界创造在面前，而在这一天里我又有许多不同的事不同的人待我去遇见，这让我看见这个世界原来是如此美好。很高兴的是，我还有许多个这样的一天等我去遇见，但很不幸的事，这些时间又太短了。希望在2021的往后的每一天里，都能完成已经有意义的事情</h2>",
            "tags": [
                "日常"
            ]
        },
        {
            "id": "http://47.97.229.110/2021/02/18/%E5%8F%AA%E8%A6%81%E4%BD%A0%E9%9C%80%E8%A6%81%E6%88%91%EF%BC%8C%E6%88%91%E6%B0%B8%E8%BF%9C%E5%9C%A8%E4%BD%A0%E7%9C%8B%E7%9A%84%E5%88%B0%E7%9A%84%E5%9C%B0%E6%96%B9/",
            "url": "http://47.97.229.110/2021/02/18/%E5%8F%AA%E8%A6%81%E4%BD%A0%E9%9C%80%E8%A6%81%E6%88%91%EF%BC%8C%E6%88%91%E6%B0%B8%E8%BF%9C%E5%9C%A8%E4%BD%A0%E7%9C%8B%E7%9A%84%E5%88%B0%E7%9A%84%E5%9C%B0%E6%96%B9/",
            "title": "只要你需要我，我永远在你看的到的地方",
            "date_published": "2021-02-18T11:13:16.000Z",
            "content_html": "<h1 id=\"寒假和朋友一起出去玩\"><a href=\"#寒假和朋友一起出去玩\" class=\"headerlink\" title=\"寒假和朋友一起出去玩\"></a>寒假和朋友一起出去玩</h1><p>来时<br><img data-src=\"https://tenadmin.oss-cn-chengdu.aliyuncs.com/myfriend/IMG_1346.JPG\" alt=\"来时的路上\"><br><img data-src=\"https://tenadmin.oss-cn-chengdu.aliyuncs.com/myfriend/IMG_1348.JPG\" alt=\"来时\"></p>\n<h1 id=\"钓鱼\"><a href=\"#钓鱼\" class=\"headerlink\" title=\"钓鱼\"></a>钓鱼</h1><p><img data-src=\"https://tenadmin.oss-cn-chengdu.aliyuncs.com/myfriend/IMG_1356.JPG\" alt=\"钓鱼\"><br><img data-src=\"https://tenadmin.oss-cn-chengdu.aliyuncs.com/myfriend/IMG_1361.JPG\" alt=\"My friend\"></p>\n<h1 id=\"去乐山的路上\"><a href=\"#去乐山的路上\" class=\"headerlink\" title=\"去乐山的路上\"></a>去乐山的路上</h1><p><img data-src=\"https://tenadmin.oss-cn-chengdu.aliyuncs.com/myfriend/IMG_1449.JPG\" alt=\"去乐山的路上\"></p>\n<h1 id=\"逛文庙\"><a href=\"#逛文庙\" class=\"headerlink\" title=\"逛文庙\"></a>逛文庙</h1><p><img data-src=\"https://tenadmin.oss-cn-chengdu.aliyuncs.com/myfriend/IMG_1535.JPG\" alt=\"文庙\"><br><img data-src=\"https://tenadmin.oss-cn-chengdu.aliyuncs.com/myfriend/IMG_1540.JPG\" alt=\"文庙\"><br><img data-src=\"https://tenadmin.oss-cn-chengdu.aliyuncs.com/myfriend/IMG_1539.JPG\" alt=\"文庙\"><br><img data-src=\"https://tenadmin.oss-cn-chengdu.aliyuncs.com/myfriend/IMG_1538.JPG\" alt=\"文庙\"><br><img data-src=\"https://tenadmin.oss-cn-chengdu.aliyuncs.com/myfriend/IMG_1541.JPG\" alt=\"文庙\"><br><img data-src=\"https://tenadmin.oss-cn-chengdu.aliyuncs.com/myfriend/IMG_1543.JPG\" alt=\"文庙\"><br><img data-src=\"https://tenadmin.oss-cn-chengdu.aliyuncs.com/myfriend/IMG_1546.JPG\" alt=\"文庙\"><br><img data-src=\"https://tenadmin.oss-cn-chengdu.aliyuncs.com/myfriend/IMG_1544.JPG\" alt=\"文庙\"></p>\n<h1 id=\"老霄顶看乐山大佛\"><a href=\"#老霄顶看乐山大佛\" class=\"headerlink\" title=\"老霄顶看乐山大佛\"></a>老霄顶看乐山大佛</h1><p><img data-src=\"https://tenadmin.oss-cn-chengdu.aliyuncs.com/myfriend/IMG_1433.JPG\" alt=\"乐山大佛\"></p>\n<h1 id=\"嘉州长卷\"><a href=\"#嘉州长卷\" class=\"headerlink\" title=\"嘉州长卷\"></a>嘉州长卷</h1><p><img data-src=\"https://tenadmin.oss-cn-chengdu.aliyuncs.com/myfriend/IMG_1558.JPG\" alt=\"嘉州长卷\"><br><img data-src=\"https://tenadmin.oss-cn-chengdu.aliyuncs.com/myfriend/IMG_1455.JPG\" alt=\"嘉州长卷\"><br><img data-src=\"https://tenadmin.oss-cn-chengdu.aliyuncs.com/myfriend/IMG_1460.jpg\" alt=\"嘉州长卷\"><br><img data-src=\"https://tenadmin.oss-cn-chengdu.aliyuncs.com/myfriend/IMG_1573.JPG\" alt=\"嘉州长卷\"><br><img data-src=\"https://tenadmin.oss-cn-chengdu.aliyuncs.com/myfriend/IMG_1566.JPG\" alt=\"嘉州长卷\"><br><img data-src=\"https://tenadmin.oss-cn-chengdu.aliyuncs.com/myfriend/IMG_1467.JPG\" alt=\"嘉州长卷\"><br><img data-src=\"https://tenadmin.oss-cn-chengdu.aliyuncs.com/myfriend/IMG_1582.JPG\" alt=\"嘉州长卷\"><br><img data-src=\"https://tenadmin.oss-cn-chengdu.aliyuncs.com/myfriend/IMG_1562.JPG\" alt=\"嘉州长卷\"><br>！<span class=\"exturl\" data-url=\"aHR0cHM6Ly90ZW5hZG1pbi5vc3MtY24tY2hlbmdkdS5hbGl5dW5jcy5jb20vbXlmcmllbmQvSU1HXzE0NjYuSlBH\">嘉州长卷</span><br><img data-src=\"https://tenadmin.oss-cn-chengdu.aliyuncs.com/myfriend/IMG_1472.JPG\" alt=\"嘉州长卷\"><br><img data-src=\"https://tenadmin.oss-cn-chengdu.aliyuncs.com/myfriend/IMG_1464.JPG\" alt=\"嘉州长卷\"></p>\n<h1 id=\"回去的路上\"><a href=\"#回去的路上\" class=\"headerlink\" title=\"回去的路上\"></a>回去的路上</h1><p><img data-src=\"https://tenadmin.oss-cn-chengdu.aliyuncs.com/myfriend/IMG_1437.JPG\" alt=\"路上\"></p>\n<h1 id=\"放风筝\"><a href=\"#放风筝\" class=\"headerlink\" title=\"放风筝\"></a>放风筝</h1><p>第一次飞起来hhh<br><img data-src=\"https://tenadmin.oss-cn-chengdu.aliyuncs.com/myfriend/IMG_1523.JPG\" alt=\"放风筝\"><br><img data-src=\"https://tenadmin.oss-cn-chengdu.aliyuncs.com/myfriend/IMG_1521.JPG\" alt=\"放风筝\"><br><img data-src=\"https://tenadmin.oss-cn-chengdu.aliyuncs.com/myfriend/IMG_1511.JPG\" alt=\"放风筝\"></p>\n<h1 id=\"儿时回忆\"><a href=\"#儿时回忆\" class=\"headerlink\" title=\"儿时回忆\"></a>儿时回忆</h1><p><img data-src=\"https://tenadmin.oss-cn-chengdu.aliyuncs.com/myfriend/IMG_1447.JPG\" alt=\"回忆\"><br><img data-src=\"https://tenadmin.oss-cn-chengdu.aliyuncs.com/myfriend/IMG_1551.JPG\" alt=\"回忆\"></p>\n<h1 id=\"回家最后一张\"><a href=\"#回家最后一张\" class=\"headerlink\" title=\"回家最后一张\"></a>回家最后一张</h1><p><img data-src=\"https://tenadmin.oss-cn-chengdu.aliyuncs.com/myfriend/IMG_1533.jpg\" alt=\"回忆\"></p>\n<h2 id=\"See-you\"><a href=\"#See-you\" class=\"headerlink\" title=\"See you!\"></a>See you!</h2><p>今日一别，又不知何时才能想到</p>\n",
            "tags": [
                "日常"
            ]
        },
        {
            "id": "http://47.97.229.110/2021/02/15/%E5%85%B3%E4%BA%8E/",
            "url": "http://47.97.229.110/2021/02/15/%E5%85%B3%E4%BA%8E/",
            "title": "关于",
            "date_published": "2021-02-15T14:31:33.404Z",
            "content_html": "<p>#此站站主：Alan</p>\n<p>此站点目的，是作为朋友圈使用，和偶尔写写文章</p>\n<p>其他详情请看菜单栏的关于页</p>\n<p>此站为node和git制作的静态网站</p>\n",
            "tags": []
        },
        {
            "id": "http://47.97.229.110/2021/01/29/python-1-day/",
            "url": "http://47.97.229.110/2021/01/29/python-1-day/",
            "title": "python_1_day",
            "date_published": "2021-01-29T13:39:15.000Z",
            "content_html": "<p>Python入门(上)<br>简介</p>\n<p>变量、运算符与数据类型</p>\n<ol>\n<li>注释</li>\n<li>运算符</li>\n<li>变量和赋值</li>\n<li>数据类型与转换</li>\n<li>print()函数</li>\n</ol>\n<p>位运算</p>\n<ol>\n<li>原码、反码和补码</li>\n<li>按位运算</li>\n<li>利用位运算实现快速计算</li>\n<li>利用位运算实现整数集合</li>\n</ol>\n<p>条件语句</p>\n<ol>\n<li>if 语句</li>\n<li>if - else 语句</li>\n<li>if - elif - else 语句</li>\n<li>assert 关键词</li>\n</ol>\n<p>循环语句</p>\n<ol>\n<li>while 循环</li>\n<li>while - else 循环</li>\n<li>for 循环</li>\n<li>for - else 循环</li>\n<li>range() 函数</li>\n<li>enumerate()函数</li>\n<li>break 语句</li>\n<li>continue 语句</li>\n<li>pass 语句</li>\n<li>推导式</li>\n</ol>\n<p>异常处理</p>\n<ol>\n<li>Python 标准异常总结</li>\n<li>Python 标准警告总结</li>\n<li>try - except 语句</li>\n<li>try - except - finally 语句</li>\n<li>try - except - else 语句</li>\n<li>raise语句</li>\n</ol>\n<p>简介<br>Python 是一种通用编程语言，其在科学计算和机器学习领域具有广泛的应用。如果我们打算利用 Python 来执行机器学习，那么对 Python 有一些基本的了解就是至关重要的。本 Python 入门系列体验就是为这样的初学者精心准备的。</p>\n<p>本实验包括以下内容：</p>\n<p>变量、运算符与数据类型<br>注释<br>运算符<br>变量和赋值<br>数据类型与转换<br>print() 函数<br>位运算<br>原码、反码和补码<br>按位非操作 ~<br>按位与操作 &amp;<br>按位或操作 |<br>按位异或操作 ^<br>按位左移操作 &lt;&lt;<br>按位右移操作 &gt;&gt;<br>利用位运算实现快速计算<br>利用位运算实现整数集合<br>条件语句<br>if 语句<br>if - else 语句<br>if - elif - else 语句<br>assert 关键词<br>循环语句<br>while 循环<br>while - else 循环<br>for 循环<br>for - else 循环<br>range() 函数<br>enumerate()函数<br>break 语句<br>continue 语句<br>pass 语句<br>推导式<br>异常处理<br>Python 标准异常总结<br>Python 标准警告总结<br>try - except 语句<br>try - except - finally 语句<br>try - except - else 语句<br>raise语句<br>变量、运算符与数据类型</p>\n<ol>\n<li>注释<br>在 Python 中，# 表示注释，作用于整行。<br>【例子】单行注释<pre><code class=\"pypthon\"># 这是一个注释\nprint(&quot;Hello world&quot;)\n​\n# Hello world</code></pre>\nHello world<br>‘’’ ‘’’ 或者 “”” “”” 表示区间注释，在三引号之间的所有内容被注释<br>【例子】多行注释<pre><code class=\"python\">&#39;&#39;&#39;\n这是多行注释，用三个单引号\n这是多行注释，用三个单引号\n这是多行注释，用三个单引号\n&#39;&#39;&#39;\n</code></pre>\n</li>\n</ol>\n<p>print(“Hello china”) </p>\n<h1 id=\"Hello-china0\"><a href=\"#Hello-china0\" class=\"headerlink\" title=\"Hello china0\"></a>Hello china0</h1><p>​<br>“””<br>这是多行注释，用三个双引号<br>这是多行注释，用三个双引号<br>这是多行注释，用三个双引号<br>“””</p>\n<pre><code>print(&quot;hello china&quot;) \n# hello china\nHello china\nhello china\n【我是测试题1】请在下方代码块中打印(print)出 hello+你的姓名\n如：print(&quot;hello 老表&quot;)\n\n# 写下你的答案\n​\n2. 运算符\n算术运算符\n``` python\n操作符    名称    示例\n+    加    1 + 1\n-    减    2 - 1\n*    乘    3 * 4\n/    除    3 / 4\n//    整除（地板除）    3 // 4\n%    取余    3 % 4\n**    幂    2 ** 3</code></pre>\n<p>【例子】</p>\n<pre><code class=\"python\">print(1 + 1)  # 2\nprint(2 - 1)  # 1\nprint(3 * 4)  # 12\nprint(3 / 4)  # 0.75\nprint(3 // 4)  # 0\nprint(3 % 4)  # 3\nprint(2 ** 3)  # 8</code></pre>\n<p>2<br>1<br>12<br>0.75<br>0<br>3<br>8<br>比较运算符</p>\n<pre><code class=\"python\">操作符    名称    示例\n&gt;    大于    2 &gt; 1\n&gt;=    大于等于    2 &gt;= 4\n&lt;    小于    1 &lt; 2\n&lt;=    小于等于    5 &lt;= 2\n==    等于    3 == 4\n!=    不等于    3 != 5</code></pre>\n<p>【例子】</p>\n<pre><code class=\"python\">print(2 &gt; 1)  # True\nprint(2 &gt;= 4)  # False\nprint(1 &lt; 2)  # True\nprint(5 &lt;= 2)  # False\nprint(3 == 4)  # False\nprint(3 != 5)  # True</code></pre>\n<p>True<br>False<br>True<br>False<br>False<br>True<br>逻辑运算符</p>\n<pre><code class=\"python\">操作符    名称    示例\nand    与    (3 &gt; 2) and (3 &lt; 5)\nor    或    (1 &gt; 3) or (9 &lt; 2)\nnot    非    not (2 &gt; 1)</code></pre>\n<p>【例子】</p>\n<pre><code class=\"python\">print((3 &gt; 2) and (3 &lt; 5))  # True\nprint((1 &gt; 3) or (9 &lt; 2))  # False\nprint(not (2 &gt; 1))  # False</code></pre>\n<p>True<br>False<br>False<br>位运算符</p>\n<pre><code class=\"python\">操作符    名称    示例\n~    按位取反    ~4\n&amp;    按位与    4 &amp; 5\n`    `    按位或\n^    按位异或    4 ^ 5\n&lt;&lt;    左移    4 &lt;&lt; 2\n&gt;&gt;    右移    4 &gt;&gt; 2</code></pre>\n<p>【例子】有关二进制的运算，参见“位运算”部分的讲解。</p>\n<pre><code class=\"python\">print(bin(4))  # 0b100\nprint(bin(5))  # 0b101\nprint(bin(~4), ~4)  # -0b101 -5\nprint(bin(4 &amp; 5), 4 &amp; 5)  # 0b100 4\nprint(bin(4 | 5), 4 | 5)  # 0b101 5\nprint(bin(4 ^ 5), 4 ^ 5)  # 0b1 1\nprint(bin(4 &lt;&lt; 2), 4 &lt;&lt; 2)  # 0b10000 16\nprint(bin(4 &gt;&gt; 2), 4 &gt;&gt; 2)  # 0b1 1</code></pre>\n<p>0b100<br>0b101<br>-0b101 -5<br>0b100 4<br>0b101 5<br>0b1 1<br>0b10000 16<br>0b1 1<br>三元运算符</p>\n<p>【例子】</p>\n<pre><code class=\"python\">x, y = 4, 5\nif x &lt; y:\n    small = x\nelse:\n    small = y\n​\nprint(small)  # 4</code></pre>\n<p>4<br>有了这个三元操作符的条件表达式，你可以使用一条语句来完成以上的条件判断和赋值操作。</p>\n<p>【例子】</p>\n<pre><code class=\"python\">x, y = 4, 5\nsmall = x if x &lt; y else y\nprint(small)  # 4</code></pre>\n<p>4<br>其他运算符</p>\n<pre><code class=\"python\">操作符    名称    示例\nin    存在    &#39;A&#39; in [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]\nnot in    不存在    &#39;h&#39; not in [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]\nis    是    &quot;hello&quot; is &quot;hello&quot;\nnot is    不是    &quot;hello&quot; is not &quot;hello&quot;</code></pre>\n<p>【例子】</p>\n<pre><code class=\"python\">letters = [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]\nif &#39;A&#39; in letters:\n    print(&#39;A&#39; + &#39; exists&#39;)\nif &#39;h&#39; not in letters:\n    print(&#39;h&#39; + &#39; not exists&#39;)\n​\n# A exists\n# h not exists</code></pre>\n<p>A exists<br>h not exists<br>【例子】比较的两个变量均指向不可变类型。</p>\n<pre><code class=\"python\">a = &quot;hello&quot;\nb = &quot;hello&quot;\nprint(a is b, a == b)  # True True\nprint(a is not b, a != b)  # False False</code></pre>\n<p>True True<br>False False<br>【例子】比较的两个变量均指向可变类型。</p>\n<pre><code class=\"python\">a = [&quot;hello&quot;]\nb = [&quot;hello&quot;]\nprint(a is b, a == b)  # False True\nprint(a is not b, a != b)  # True False</code></pre>\n<p>False True<br>True False<br>注意：</p>\n<p>is, is not 对比的是两个变量的内存地址<br>==, != 对比的是两个变量的值<br>比较的两个变量，指向的都是地址不可变的类型（str等），那么is，is not 和 ==，！= 是完全等价的。<br>对比的两个变量，指向的是地址可变的类型（list，dict，tuple等），则两者是有区别的。<br>运算符的优先级</p>\n<pre><code class=\"python\">运算符    描述\n**    指数（最高优先级）\n~+-    按位翻转，一元加号和减号\n* / % //    乘，除，取模和取整除）\n+ -    加法减法\n&gt;&gt; &lt;&lt;    右移，左移运算符\n&amp;    位‘AND’\n^|    位运算符\n&lt;=&lt;&gt;&gt;=    比较运算符\n&lt;&gt;==!=    等于运算符\n=%=/=//=-=+==*=    赋值运算符\nis is not    身份运算符\nin not in    成员运算符\nnot and or    逻辑运算符</code></pre>\n<p>【例子】</p>\n<pre><code class=\"python\">print(-3 ** 2)  # -9\nprint(3 ** -2)  # 0.1111111111111111\nprint(1 &lt;&lt; 3 + 2 &amp; 7)  # 0\nprint(-3 * 2 + 5 / -2 - 4)  # -12.5\nprint(3 &lt; 4 and 4 &lt; 5)  # True</code></pre>\n<p>-9<br>0.1111111111111111<br>0<br>-12.5<br>True<br>【我是测试题2】下面这段代码的运行结果是什么？</p>\n<pre><code class=\"python\"># 运行一下结果就出来了\na = &quot;hello&quot;\nb = &quot;hello&quot;\nprint(a is b, a == b)</code></pre>\n<ol start=\"3\">\n<li>变量和赋值<br>在使用变量之前，需要对其先赋值。<br>变量名可以包括字母、数字、下划线、但变量名不能以数字开头。<br>Python 变量名是大小写敏感的，foo != Foo。<br>【例子】<pre><code class=\"python\">teacher = &quot;老马的程序人生&quot;\nprint(teacher)  # 老马的程序人生</code></pre>\n老马的程序人生<br>【例子】<pre><code class=\"python\">first = 2\nsecond = 3\nthird = first + second\nprint(third)  # 5</code></pre>\n5<br>【例子】<pre><code class=\"python\">myTeacher = &quot;老马的程序人生&quot;\nyourTeacher = &quot;小马的程序人生&quot;\nourTeacher = myTeacher + &#39;,&#39; + yourTeacher\nprint(ourTeacher)  # 老马的程序人生,小马的程序人生</code></pre>\n老马的程序人生,小马的程序人生<br>【我是测试题3】运行下面一段代码看看结果是什么？<br>``` python<h1 id=\"运行一下就好啦\"><a href=\"#运行一下就好啦\" class=\"headerlink\" title=\"运行一下就好啦\"></a>运行一下就好啦</h1>set_1 = {“欢迎”, “学习”,”Python”}<br>print(set_1.pop())</li>\n<li>数据类型与转换<br>类型    名称    示例<br>int    整型 &lt;class ‘int’&gt;    -876, 10<br>float    浮点型&lt;class ‘float’&gt;    3.149, 11.11<br>bool    布尔型&lt;class ‘bool’&gt;    True, False<pre><code>整型\n</code></pre>\n</li>\n</ol>\n<p>【例子】通过 print() 可看出 a 的值，以及类 (class) 是int。</p>\n<pre><code class=\"python\">a = 1031\nprint(a, type(a))\n# 1031 &lt;class &#39;int&#39;&gt;</code></pre>\n<p>1031 &lt;class ‘int’&gt;</p>\n<p>Python 里面万物皆对象（object），整型也不例外，只要是对象，就有相应的属性 （attributes） 和方法（methods）。</p>\n<p>【例子】</p>\n<pre><code class=\"python\">b = dir(int)\nprint(b)\n​\n# [&#39;__abs__&#39;, &#39;__add__&#39;, &#39;__and__&#39;, &#39;__bool__&#39;, &#39;__ceil__&#39;, &#39;__class__&#39;,\n# &#39;__delattr__&#39;, &#39;__dir__&#39;, &#39;__divmod__&#39;, &#39;__doc__&#39;, &#39;__eq__&#39;,\n# &#39;__float__&#39;, &#39;__floor__&#39;, &#39;__floordiv__&#39;, &#39;__format__&#39;, &#39;__ge__&#39;,\n# &#39;__getattribute__&#39;, &#39;__getnewargs__&#39;, &#39;__gt__&#39;, &#39;__hash__&#39;,\n# &#39;__index__&#39;, &#39;__init__&#39;, &#39;__init_subclass__&#39;, &#39;__int__&#39;, &#39;__invert__&#39;,\n# &#39;__le__&#39;, &#39;__lshift__&#39;, &#39;__lt__&#39;, &#39;__mod__&#39;, &#39;__mul__&#39;, &#39;__ne__&#39;,\n# &#39;__neg__&#39;, &#39;__new__&#39;, &#39;__or__&#39;, &#39;__pos__&#39;, &#39;__pow__&#39;, &#39;__radd__&#39;,\n# &#39;__rand__&#39;, &#39;__rdivmod__&#39;, &#39;__reduce__&#39;, &#39;__reduce_ex__&#39;, &#39;__repr__&#39;,\n# &#39;__rfloordiv__&#39;, &#39;__rlshift__&#39;, &#39;__rmod__&#39;, &#39;__rmul__&#39;, &#39;__ror__&#39;,\n# &#39;__round__&#39;, &#39;__rpow__&#39;, &#39;__rrshift__&#39;, &#39;__rshift__&#39;, &#39;__rsub__&#39;,\n# &#39;__rtruediv__&#39;, &#39;__rxor__&#39;, &#39;__setattr__&#39;, &#39;__sizeof__&#39;, &#39;__str__&#39;,\n# &#39;__sub__&#39;, &#39;__subclasshook__&#39;, &#39;__truediv__&#39;, &#39;__trunc__&#39;, &#39;__xor__&#39;,\n# &#39;bit_length&#39;, &#39;conjugate&#39;, &#39;denominator&#39;, &#39;from_bytes&#39;, &#39;imag&#39;,\n# &#39;numerator&#39;, &#39;real&#39;, &#39;to_bytes&#39;]\n[&#39;__abs__&#39;, &#39;__add__&#39;, &#39;__and__&#39;, &#39;__bool__&#39;, &#39;__ceil__&#39;, &#39;__class__&#39;, &#39;__delattr__&#39;, &#39;__dir__&#39;, &#39;__divmod__&#39;, &#39;__doc__&#39;, &#39;__eq__&#39;, &#39;__float__&#39;, &#39;__floor__&#39;, &#39;__floordiv__&#39;, &#39;__format__&#39;, &#39;__ge__&#39;, &#39;__getattribute__&#39;, &#39;__getnewargs__&#39;, &#39;__gt__&#39;, &#39;__hash__&#39;, &#39;__index__&#39;, &#39;__init__&#39;, &#39;__init_subclass__&#39;, &#39;__int__&#39;, &#39;__invert__&#39;, &#39;__le__&#39;, &#39;__lshift__&#39;, &#39;__lt__&#39;, &#39;__mod__&#39;, &#39;__mul__&#39;, &#39;__ne__&#39;, &#39;__neg__&#39;, &#39;__new__&#39;, &#39;__or__&#39;, &#39;__pos__&#39;, &#39;__pow__&#39;, &#39;__radd__&#39;, &#39;__rand__&#39;, &#39;__rdivmod__&#39;, &#39;__reduce__&#39;, &#39;__reduce_ex__&#39;, &#39;__repr__&#39;, &#39;__rfloordiv__&#39;, &#39;__rlshift__&#39;, &#39;__rmod__&#39;, &#39;__rmul__&#39;, &#39;__ror__&#39;, &#39;__round__&#39;, &#39;__rpow__&#39;, &#39;__rrshift__&#39;, &#39;__rshift__&#39;, &#39;__rsub__&#39;, &#39;__rtruediv__&#39;, &#39;__rxor__&#39;, &#39;__setattr__&#39;, &#39;__sizeof__&#39;, &#39;__str__&#39;, &#39;__sub__&#39;, &#39;__subclasshook__&#39;, &#39;__truediv__&#39;, &#39;__trunc__&#39;, &#39;__xor__&#39;, &#39;bit_length&#39;, &#39;conjugate&#39;, &#39;denominator&#39;, &#39;from_bytes&#39;, &#39;imag&#39;, &#39;numerator&#39;, &#39;real&#39;, &#39;to_bytes&#39;]</code></pre>\n<p>对它们有个大概印象就可以了，具体怎么用，需要哪些参数 （argument），还需要查文档。看个bit_length()的例子。</p>\n<p>【例子】找到一个整数的二进制表示，再返回其长度。</p>\n<pre><code class=\"python\">a = 1031\nprint(bin(a))  # 0b10000000111\nprint(a.bit_length())  # 11</code></pre>\n<p>0b10000000111<br>11<br>浮点型</p>\n<p>【例子】</p>\n<pre><code class=\"python\">print(1, type(1))\n# 1 &lt;class &#39;int&#39;&gt;\n​\nprint(1., type(1.))\n# 1.0 &lt;class &#39;float&#39;&gt;\n​\na = 0.00000023\nb = 2.3e-7\nprint(a)  # 2.3e-07\nprint(b)  # 2.3e-07</code></pre>\n<p>1 &lt;class ‘int’&gt;<br>1.0 &lt;class ‘float’&gt;<br>2.3e-07<br>2.3e-07<br>有时候我们想保留浮点型的小数点后 n 位。可以用 decimal 包里的 Decimal 对象和 getcontext() 方法来实现。</p>\n<pre><code class=\"python\">import decimal\nfrom decimal import Decimal</code></pre>\n<p>Python 里面有很多用途广泛的包 (package)，用什么你就引进 (import) 什么。包也是对象，也可以用上面提到的dir(decimal) 来看其属性和方法。</p>\n<p>【例子】getcontext() 显示了 Decimal 对象的默认精度值是 28 位 (prec=28)。</p>\n<pre><code class=\"python\">a = decimal.getcontext()\nprint(a)\n​\n# Context(prec=28, rounding=ROUND_HALF_EVEN, Emin=-999999, Emax=999999,\n# capitals=1, clamp=0, flags=[], \n# traps=[InvalidOperation, DivisionByZero, Overflow])\nContext(prec=28, rounding=ROUND_HALF_EVEN, Emin=-999999, Emax=999999, capitals=1, clamp=0, flags=[], traps=[InvalidOperation, DivisionByZero, Overflow])\nb = Decimal(1) / Decimal(3)\nprint(b)\n​\n# 0.3333333333333333333333333333</code></pre>\n<p>0.3333333333333333333333333333<br>【例子】使 1/3 保留 4 位，用 getcontext().prec 来调整精度。</p>\n<pre><code class=\"python\">decimal.getcontext().prec = 4\nc = Decimal(1) / Decimal(3)\nprint(c)\n​\n# 0.3333</code></pre>\n<p>0.3333<br>布尔型</p>\n<p>布尔 (boolean) 型变量只能取两个值，True 和 False。当把布尔型变量用在数字运算中，用 1 和 0 代表 True 和 False。</p>\n<p>【例子】</p>\n<pre><code class=\"python\">print(True + True)  # 2\nprint(True + False)  # 1\nprint(True * False)  # 0</code></pre>\n<p>2<br>1<br>0<br>除了直接给变量赋值 True 和 False，还可以用 bool(X) 来创建变量，其中 X 可以是</p>\n<p>基本类型：整型、浮点型、布尔型<br>容器类型：字符串、元组、列表、字典和集合<br>【例子】bool 作用在基本类型变量：X 只要不是整型 0、浮点型 0.0，bool(X) 就是 True，其余就是 False。</p>\n<pre><code class=\"python\">print(type(0), bool(0), bool(1))\n# &lt;class &#39;int&#39;&gt; False True\n​\nprint(type(10.31), bool(0.00), bool(10.31))\n# &lt;class &#39;float&#39;&gt; False True\n​\nprint(type(True), bool(False), bool(True))\n# &lt;class &#39;bool&#39;&gt; False True</code></pre>\n<p>&lt;class ‘int’&gt; False True<br>&lt;class ‘float’&gt; False True<br>&lt;class ‘bool’&gt; False True</p>\n<p>【例子】bool 作用在容器类型变量：X 只要不是空的变量，bool(X) 就是 True，其余就是 False。</p>\n<pre><code class=\"python\">print(type(&#39;&#39;), bool(&#39;&#39;), bool(&#39;python&#39;))\n# &lt;class &#39;str&#39;&gt; False True\n​\nprint(type(()), bool(()), bool((10,)))\n# &lt;class &#39;tuple&#39;&gt; False True\n​\nprint(type([]), bool([]), bool([1, 2]))\n# &lt;class &#39;list&#39;&gt; False True\n​\nprint(type(&#123;&#125;), bool(&#123;&#125;), bool(&#123;&#39;a&#39;: 1, &#39;b&#39;: 2&#125;))\n# &lt;class &#39;dict&#39;&gt; False True\n​\nprint(type(set()), bool(set()), bool(&#123;1, 2&#125;))\n# &lt;class &#39;set&#39;&gt; False True</code></pre>\n<p>&lt;class ‘str’&gt; False True<br>&lt;class ‘tuple’&gt; False True<br>&lt;class ‘list’&gt; False True<br>&lt;class ‘dict’&gt; False True<br>&lt;class ‘set’&gt; False True</p>\n<p>确定bool(X) 的值是 True 还是 False，就看 X 是不是空，空的话就是 False，不空的话就是 True。</p>\n<p>对于数值变量，0, 0.0 都可认为是空的。<br>对于容器变量，里面没元素就是空的。<br>获取类型信息</p>\n<p>获取类型信息 type(object)<br>【例子】</p>\n<pre><code class=\"python\">print(isinstance(1, int))  # True\nprint(isinstance(5.2, float))  # True\nprint(isinstance(True, bool))  # True\nprint(isinstance(&#39;5.2&#39;, str))  # True</code></pre>\n<p>True<br>True<br>True<br>True<br>注：</p>\n<p>type() 不会认为子类是一种父类类型，不考虑继承关系。<br>isinstance() 会认为子类是一种父类类型，考虑继承关系。<br>如果要判断两个类型是否相同推荐使用 isinstance()。</p>\n<p>类型转换</p>\n<p>转换为整型 int(x, base=10)<br>转换为字符串 str(object=’’)<br>转换为浮点型 float(x)<br>【例子】</p>\n<pre><code class=\"python\">print(int(&#39;520&#39;))  # 520\nprint(int(520.52))  # 520\nprint(float(&#39;520.52&#39;))  # 520.52\nprint(float(520))  # 520.0\nprint(str(10 + 10))  # 20\nprint(str(10.1 + 5.2))  # 15.3</code></pre>\n<p>520<br>520<br>520.52<br>520.0<br>20<br>15.3<br>5. print() 函数<br>print(*objects, sep=’ ‘, end=’\\n’, file=sys.stdout, flush=False)<br>将对象以字符串表示的方式格式化输出到流文件对象file里。其中所有非关键字参数都按str()方式进行转换为字符串输出；<br>关键字参数sep是实现分隔符，比如多个参数输出时想要输出中间的分隔字符；<br>关键字参数end是输出结束时的字符，默认是换行符\\n；<br>关键字参数file是定义流输出的文件，可以是标准的系统输出sys.stdout，也可以重定义为别的文件；<br>关键字参数flush是立即把内容输出到流文件，不作缓存。<br>【例子】没有参数时，每次输出后都会换行。</p>\n<pre><code class=\"python\">shoplist = [&#39;apple&#39;, &#39;mango&#39;, &#39;carrot&#39;, &#39;banana&#39;]\nprint(&quot;This is printed without &#39;end&#39;and &#39;sep&#39;.&quot;)\nfor item in shoplist:\n    print(item)\n​\n# This is printed without &#39;end&#39;and &#39;sep&#39;.\n# apple\n# mango\n# carrot\n# banana</code></pre>\n<p>This is printed without ‘end’and ‘sep’.<br>apple<br>mango<br>carrot<br>banana<br>【例子】每次输出结束都用end设置的参数&amp;结尾，并没有默认换行。</p>\n<pre><code class=\"python\">shoplist = [&#39;apple&#39;, &#39;mango&#39;, &#39;carrot&#39;, &#39;banana&#39;]\nprint(&quot;This is printed with &#39;end=&#39;&amp;&#39;&#39;.&quot;)\nfor item in shoplist:\n    print(item, end=&#39;&amp;&#39;)\nprint(&#39;hello world&#39;)\n​\n# This is printed with &#39;end=&#39;&amp;&#39;&#39;.\n# apple&amp;mango&amp;carrot&amp;banana&amp;hello world</code></pre>\n<p>This is printed with ‘end=’&amp;’’.<br>apple&amp;mango&amp;carrot&amp;banana&amp;hello world<br>【例子】item值与’another string’两个值之间用sep设置的参数&amp;分割。由于end参数没有设置，因此默认是输出解释后换行，即end参数的默认值为\\n。</p>\n<pre><code class=\"python\">shoplist = [&#39;apple&#39;, &#39;mango&#39;, &#39;carrot&#39;, &#39;banana&#39;]\nprint(&quot;This is printed with &#39;sep=&#39;&amp;&#39;&#39;.&quot;)\nfor item in shoplist:\n    print(item, &#39;another string&#39;, sep=&#39;&amp;&#39;)\n​\n# This is printed with &#39;sep=&#39;&amp;&#39;&#39;.\n# apple&amp;another string\n# mango&amp;another string\n# carrot&amp;another string\n# banana&amp;another string</code></pre>\n<p>This is printed with ‘sep=’&amp;’’.<br>apple&amp;another string<br>mango&amp;another string<br>carrot&amp;another string<br>banana&amp;another string<br>位运算</p>\n<ol>\n<li>原码、反码和补码<br>二进制有三种不同的表示形式：原码、反码和补码，计算机内部使用补码来表示。</li>\n</ol>\n<p>原码：就是其二进制表示（注意，有一位符号位）。</p>\n<pre><code class=\"python\">00 00 00 11 -&gt; 3\n10 00 00 11 -&gt; -3</code></pre>\n<p>反码：正数的反码就是原码，负数的反码是符号位不变，其余位取反（对应正数按位取反）。</p>\n<pre><code class=\"python\">00 00 00 11 -&gt; 3\n11 11 11 00 -&gt; -3</code></pre>\n<p>补码：正数的补码就是原码，负数的补码是反码+1。</p>\n<pre><code class=\"python\">00 00 00 11 -&gt; 3\n11 11 11 01 -&gt; -3</code></pre>\n<p>符号位：最高位为符号位，0表示正数，1表示负数。在位运算中符号位也参与运算。</p>\n<ol start=\"2\">\n<li>按位运算<br>按位非操作 ~<pre><code class=\"python\">~ 1 = 0\n~ 0 = 1</code></pre>\n~ 把num的补码中的 0 和 1 全部取反（0 变为 1，1 变为 0）有符号整数的符号位在 ~ 运算中同样会取反。<pre><code class=\"python\">00 00 01 01 -&gt; 5\n~</code></pre>\n</li>\n</ol>\n<hr>\n<p>11 11 10 10 -&gt; -6</p>\n<p>11 11 10 11 -&gt; -5<br>~</p>\n<hr>\n<p>00 00 01 00 -&gt; 4</p>\n<pre><code>按位与操作 &amp;\n``` python\n1 &amp; 1 = 1\n1 &amp; 0 = 0\n0 &amp; 1 = 0\n0 &amp; 0 = 0</code></pre>\n<p>只有两个对应位都为 1 时才为 1</p>\n<pre><code class=\"python\">00 00 01 01 -&gt; 5\n&amp;\n00 00 01 10 -&gt; 6\n---\n00 00 01 00 -&gt; 4</code></pre>\n<p>按位或操作 |</p>\n<pre><code class=\"python\">1 | 1 = 1\n1 | 0 = 1\n0 | 1 = 1\n0 | 0 = 0</code></pre>\n<p>只要两个对应位中有一个 1 时就为 1</p>\n<pre><code class=\"python\">00 00 01 01 -&gt; 5\n|\n00 00 01 10 -&gt; 6\n---\n00 00 01 11 -&gt; 7</code></pre>\n<p>按位异或操作 ^</p>\n<pre><code class=\"python\">1 ^ 1 = 0\n1 ^ 0 = 1\n0 ^ 1 = 1\n0 ^ 0 = 0</code></pre>\n<p>只有两个对应位不同时才为 1</p>\n<pre><code class=\"python\">00 00 01 01 -&gt; 5\n^\n00 00 01 10 -&gt; 6\n---\n00 00 00 11 -&gt; 3</code></pre>\n<p>异或操作的性质：满足交换律和结合律</p>\n<pre><code class=\"python\">A: 00 00 11 00\nB: 00 00 01 11\n\nA^B: 00 00 10 11\nB^A: 00 00 10 11\n\nA^A: 00 00 00 00\nA^0: 00 00 11 00</code></pre>\n<p>A^B^A: = A^A^B = B = 00 00 01 11<br>按位左移操作 &lt;&lt;<br>num &lt;&lt; i 将num的二进制表示向左移动i位所得的值。</p>\n<pre><code class=\"python\">00 00 10 11 -&gt; 11\n11 &lt;&lt; 3\n---\n01 01 10 00 -&gt; 88 </code></pre>\n<p>按位右移操作 &gt;&gt;<br>num &gt;&gt; i 将num的二进制表示向右移动i位所得的值。</p>\n<pre><code class=\"python\">00 00 10 11 -&gt; 11\n11 &gt;&gt; 2\n---\n00 00 00 10 -&gt; 2 </code></pre>\n<ol start=\"3\">\n<li>利用位运算实现快速计算<br>通过 &lt;&lt;，&gt;&gt; 快速计算2的倍数问题。</li>\n</ol>\n<p>n &lt;&lt; 1 -&gt; 计算 n<em>2<br>n &gt;&gt; 1 -&gt; 计算 n/2，负奇数的运算不可用<br>n &lt;&lt; m -&gt; 计算 n</em>(2^m)，即乘以 2 的 m 次方<br>n &gt;&gt; m -&gt; 计算 n/(2^m)，即除以 2 的 m 次方<br>1 &lt;&lt; n -&gt; 2^n<br>通过 ^ 快速交换两个整数。 通过 ^ 快速交换两个整数。</p>\n<pre><code class=\"python\">a ^= b\nb ^= a\na ^= b</code></pre>\n<p>通过 a &amp; (-a) 快速获取a的最后为 1 位置的整数。</p>\n<pre><code class=\"python\">00 00 01 01 -&gt; 5\n&amp;\n11 11 10 11 -&gt; -5\n---\n00 00 00 01 -&gt; 1\n\n00 00 11 10 -&gt; 14\n&amp;\n11 11 00 10 -&gt; -14\n---\n00 00 00 10 -&gt; 2</code></pre>\n<ol start=\"4\">\n<li>利用位运算实现整数集合<br>一个数的二进制表示可以看作是一个集合（0 表示不在集合中，1 表示在集合中）。</li>\n</ol>\n<p>比如集合 {1, 3, 4, 8}，可以表示成 01 00 01 10 10 而对应的位运算也就可以看作是对集合进行的操作。</p>\n<p>元素与集合的操作：</p>\n<pre><code class=\"python\">a | (1&lt;&lt;i)  -&gt; 把 i 插入到集合中\na &amp; ~(1&lt;&lt;i) -&gt; 把 i 从集合中删除\na &amp; (1&lt;&lt;i)  -&gt; 判断 i 是否属于该集合（零不属于，非零属于）</code></pre>\n<p>集合之间的操作：</p>\n<pre><code class=\"python\">a 补   -&gt; ~a\na 交 b -&gt; a &amp; b\na 并 b -&gt; a | b\na 差 b -&gt; a &amp; (~b)</code></pre>\n<p>注意：整数在内存中是以补码的形式存在的，输出自然也是按照补码输出。</p>\n<p>【例子】C#语言输出负数。</p>\n<pre><code class=\"python\">class Program\n&#123;\n    static void Main(string[] args)\n    &#123;\n        string s1 = Convert.ToString(-3, 2);\n        Console.WriteLine(s1); \n        // 11111111111111111111111111111101\n\n        string s2 = Convert.ToString(-3, 16);\n        Console.WriteLine(s2); \n        // fffffffd\n    &#125;\n&#125;</code></pre>\n<p>【例子】 Python 的bin() 输出。</p>\n<pre><code class=\"python\">print(bin(3))  # 0b11\nprint(bin(-3))  # -0b11\n​\nprint(bin(-3 &amp; 0xffffffff))  \n# 0b11111111111111111111111111111101\n​\nprint(bin(0xfffffffd))       \n# 0b11111111111111111111111111111101\n​\nprint(0xfffffffd)  # 4294967293</code></pre>\n<p>0b11<br>-0b11<br>0b11111111111111111111111111111101<br>0b11111111111111111111111111111101<br>4294967293<br>是不是很颠覆认知，我们从结果可以看出：</p>\n<p>Python中bin一个负数（十进制表示），输出的是它的原码的二进制表示加上个负号，巨坑。<br>Python中的整型是补码形式存储的。<br>Python中整型是不限制长度的不会超范围溢出。<br>所以为了获得负数（十进制表示）的补码，需要手动将其和十六进制数0xffffffff进行按位与操作，再交给bin()进行输出，得到的才是负数的补码表示。</p>\n<p>条件语句</p>\n<ol>\n<li>if 语句<pre><code class=\"python\">if expression:\n expr_true_suite</code></pre>\nif 语句的 expr_true_suite 代码块只有当条件表达式 expression 结果为真时才执行，否则将继续执行紧跟在该代码块后面的语句。<br>单个 if 语句中的 expression 条件表达式可以通过布尔操作符 and，or和not 实现多重条件判断。<br>【例子】<pre><code class=\"python\">if 2 &gt; 1 and not 2 &gt; 3:\n print(&#39;Correct Judgement!&#39;)\n​\n# Correct Judgement!</code></pre>\nCorrect Judgement!</li>\n<li>if - else 语句<pre><code class=\"python\">if expression:\n expr_true_suite\nelse:\n expr_false_suite</code></pre>\nPython 提供与 if 搭配使用的 else，如果 if 语句的条件表达式结果布尔值为假，那么程序将执行 else 语句后的代码。<br>【例子】<pre><code class=\"python\">temp = input(&quot;猜一猜小姐姐想的是哪个数字？&quot;)\nguess = int(temp) # input 函数将接收的任何数据类型都默认为 str。\nif guess == 666:\n print(&quot;你太了解小姐姐的心思了！&quot;)\n print(&quot;哼，猜对也没有奖励！&quot;)\nelse:\n print(&quot;猜错了，小姐姐现在心里想的是666！&quot;)\nprint(&quot;游戏结束，不玩儿啦！&quot;)</code></pre>\n猜一猜小姐姐想的是哪个数字？666<br>你太了解小姐姐的心思了！<br>哼，猜对也没有奖励！<br>游戏结束，不玩儿啦！<br>if语句支持嵌套，即在一个if语句中嵌入另一个if语句，从而构成不同层次的选择结构。</li>\n</ol>\n<p>【例子】Python 使用缩进而不是大括号来标记代码块边界，因此要特别注意else的悬挂问题。</p>\n<pre><code class=\"python\">hi = 6\nif hi &gt; 2:\n    if hi &gt; 7:\n        print(&#39;好棒!好棒!&#39;)\nelse:\n    print(&#39;切~&#39;)\n​\n# 无输出</code></pre>\n<p>【例子】</p>\n<pre><code class=\"python\">temp = input(&quot;猜一猜小姐姐想的是哪个数字？&quot;)\nguess = int(temp)\nif guess &gt; 8:\n    print(&quot;大了，大了&quot;)\nelse:\n    if guess == 8:\n        print(&quot;你太了解小姐姐的心思了！&quot;)\n        print(&quot;哼，猜对也没有奖励！&quot;)\n    else:\n        print(&quot;小了，小了&quot;)\nprint(&quot;游戏结束，不玩儿啦！&quot;)</code></pre>\n<p>猜一猜小姐姐想的是哪个数字？8<br>你太了解小姐姐的心思了！<br>哼，猜对也没有奖励！<br>游戏结束，不玩儿啦！<br>3. if - elif - else 语句</p>\n<pre><code class=\"python\">if expression1:\n    expr1_true_suite\nelif expression2:\n    expr2_true_suite\n    .\n    .\nelif expressionN:\n    exprN_true_suite\nelse:\n    expr_false_suite\n    ```\nelif 语句即为 else if，用来检查多个表达式是否为真，并在为真时执行特定代码块中的代码。\n【例子】\n``` python\ntemp = input(&#39;请输入成绩:&#39;)\nsource = int(temp)\nif 100 &gt;= source &gt;= 90:\n    print(&#39;A&#39;)\nelif 90 &gt; source &gt;= 80:\n    print(&#39;B&#39;)\nelif 80 &gt; source &gt;= 60:\n    print(&#39;C&#39;)\nelif 60 &gt; source &gt;= 0:\n    print(&#39;D&#39;)\nelse:\n    print(&#39;输入错误！&#39;)\n    ```\n请输入成绩:99\nA\n4. assert 关键词\nassert这个关键词我们称之为“断言”，当这个关键词后边的条件为 False 时，程序自动崩溃并抛出AssertionError的异常。\n【例子】\n``` python\nmy_list = [&#39;lsgogroup&#39;]\nmy_list.pop(0)\nassert len(my_list) &gt; 0\n​\n# AssertionError</code></pre>\n<p>【例子】在进行单元测试时，可以用来在程序中置入检查点，只有条件为 True 才能让程序正常工作。</p>\n<pre><code class=\"python\">assert 3 &gt; 7\n​\n# AssertionError</code></pre>\n<p>循环语句</p>\n<ol>\n<li>while 循环<br>while语句最基本的形式包括一个位于顶部的布尔表达式，一个或多个属于while代码块的缩进语句。<pre><code class=\"python\">while 布尔表达式:\n 代码块</code></pre>\nwhile循环的代码块会一直循环执行，直到布尔表达式的值为布尔假。</li>\n</ol>\n<p>如果布尔表达式不带有&lt;、&gt;、==、！=、in、not in等运算符，仅仅给出数值之类的条件，也是可以的。当while后写入一个非零整数时，视为真值，执行循环体；写入0时，视为假值，不执行循环体。也可以写入str、list或任何序列，长度非零则视为真值，执行循环体；否则视为假值，不执行循环体。</p>\n<p>【例子】</p>\n<pre><code class=\"python\">count = 0\nwhile count &lt; 3:\n    temp = input(&quot;猜一猜小姐姐想的是哪个数字？&quot;)\n    guess = int(temp)\n    if guess &gt; 8:\n        print(&quot;大了，大了&quot;)\n    else:\n        if guess == 8:\n            print(&quot;你太了解小姐姐的心思了！&quot;)\n            print(&quot;哼，猜对也没有奖励！&quot;)\n            count = 3\n        else:\n            print(&quot;小了，小了&quot;)\n    count = count + 1\nprint(&quot;游戏结束，不玩儿啦！&quot;)</code></pre>\n<p>猜一猜小姐姐想的是哪个数字？8<br>你太了解小姐姐的心思了！<br>哼，猜对也没有奖励！<br>游戏结束，不玩儿啦！<br>【例子】布尔表达式返回0，循环终止。</p>\n<pre><code class=\"python\">string = &#39;abcd&#39;\nwhile string:\n    print(string)\n    string = string[1:]\n\n​\n# abcd\n# bcd\n# cd\n# d</code></pre>\n<p>abcd<br>bcd<br>cd<br>d<br>2. while - else 循环</p>\n<pre><code class=\"python\">while 布尔表达式:\n    代码块\nelse:\n    代码块</code></pre>\n<p>当while循环正常执行完的情况下，执行else输出，如果while循环中执行了跳出循环的语句，比如 break，将不执行else代码块的内容。</p>\n<p>【例子】</p>\n<pre><code class=\"python\">count = 0\nwhile count &lt; 5:\n    print(&quot;%d is  less than 5&quot; % count)\n    count = count + 1\nelse:\n    print(&quot;%d is not less than 5&quot; % count)\n\n# 0 is  less than 5\n# 1 is  less than 5\n# 2 is  less than 5\n# 3 is  less than 5\n# 4 is  less than 5\n# 5 is not less than 5</code></pre>\n<p>0 is  less than 5<br>1 is  less than 5<br>2 is  less than 5<br>3 is  less than 5<br>4 is  less than 5<br>5 is not less than 5<br>【例子】</p>\n<pre><code class=\"python\">count = 0\nwhile count &lt; 5:\n    print(&quot;%d is  less than 5&quot; % count)\n    count = 6\n    break\nelse:\n    print(&quot;%d is not less than 5&quot; % count)\n​\n# 0 is  less than 5</code></pre>\n<p>0 is  less than 5<br>3. for 循环<br>for循环是迭代循环，在Python中相当于一个通用的序列迭代器，可以遍历任何有序序列，如str、list、tuple等，也可以遍历任何可迭代对象，如dict。</p>\n<pre><code class=\"python\">for 迭代变量 in 可迭代对象:\n    代码块\n    ```\n每次循环，迭代变量被设置为可迭代对象的当前元素，提供给代码块使用。\n\n【例子】\n``` python\nfor i in &#39;ILoveLSGO&#39;:\n    print(i, end=&#39; &#39;)  # 不换行输出\n​\n# I L o v e L S G O</code></pre>\n<p>I L o v e L S G O<br>【例子】</p>\n<pre><code class=\"python\">member = [&#39;张三&#39;, &#39;李四&#39;, &#39;刘德华&#39;, &#39;刘六&#39;, &#39;周润发&#39;]\nfor each in member:\n    print(each)\n​\n# 张三\n# 李四\n# 刘德华\n# 刘六\n# 周润发\n​\nfor i in range(len(member)):\n    print(member[i])\n​\n# 张三\n# 李四\n# 刘德华\n# 刘六\n# 周润发</code></pre>\n<p>张三<br>李四<br>刘德华<br>刘六<br>周润发<br>张三<br>李四<br>刘德华<br>刘六<br>周润发<br>【例子】</p>\n<pre><code class=\"python\">dic = &#123;&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3, &#39;d&#39;: 4&#125;\n​\nfor key, value in dic.items():\n    print(key, value, sep=&#39;:&#39;, end=&#39; &#39;)\n\n# a:1 b:2 c:3 d:4 </code></pre>\n<p>a:1 b:2 c:3 d:4<br>【例子】</p>\n<pre><code class=\"python\">dic = &#123;&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3, &#39;d&#39;: 4&#125;\n​\nfor key in dic.keys():\n    print(key, end=&#39; &#39;)\n\n# a b c d </code></pre>\n<p>a b c d<br>【例子】</p>\n<pre><code class=\"python\">dic = &#123;&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3, &#39;d&#39;: 4&#125;\n​\nfor value in dic.values():\n    print(value, end=&#39; &#39;)\n\n# 1 2 3 4</code></pre>\n<p>1 2 3 4<br>4. for - else 循环</p>\n<pre><code class=\"python\">for 迭代变量 in 可迭代对象:\n    代码块\nelse:\n    代码块\n    ```\n当for循环正常执行完的情况下，执行else输出，如果for循环中执行了跳出循环的语句，比如 break，将不执行else代码块的内容，与while - else语句一样。\n\n【例子】\n``` python\nfor num in range(10, 20):  # 迭代 10 到 20 之间的数字\n    for i in range(2, num):  # 根据因子迭代\n        if num % i == 0:  # 确定第一个因子\n            j = num / i  # 计算第二个因子\n            print(&#39;%d 等于 %d * %d&#39; % (num, i, j))\n            break  # 跳出当前循环\n    else:  # 循环的 else 部分\n        print(num, &#39;是一个质数&#39;)\n​\n# 10 等于 2 * 5\n# 11 是一个质数\n# 12 等于 2 * 6\n# 13 是一个质数\n# 14 等于 2 * 7\n# 15 等于 3 * 5\n# 16 等于 2 * 8\n# 17 是一个质数\n# 18 等于 2 * 9\n# 19 是一个质数</code></pre>\n<p>10 等于 2 * 5<br>11 是一个质数<br>12 等于 2 * 6<br>13 是一个质数<br>14 等于 2 * 7<br>15 等于 3 * 5<br>16 等于 2 * 8<br>17 是一个质数<br>18 等于 2 * 9<br>19 是一个质数<br>5. range() 函数</p>\n<pre><code class=\"python\">range([start,] stop[, step=1])</code></pre>\n<p>这个BIF（Built-in functions）有三个参数，其中用中括号括起来的两个表示这两个参数是可选的。<br>step=1 表示第三个参数的默认值是1。<br>range 这个BIF的作用是生成一个从start参数的值开始到stop参数的值结束的数字序列，该序列包含start的值但不包含stop的值。<br>【例子】</p>\n<pre><code class=\"python\">for i in range(2, 9):  # 不包含9\n    print(i)\n​\n# 2\n# 3\n# 4\n# 5\n# 6\n# 7\n# 8</code></pre>\n<p>2<br>3<br>4<br>5<br>6<br>7<br>8<br>【例子】</p>\n<pre><code class=\"python\">for i in range(1, 10, 2):\n    print(i)\n​\n# 1\n# 3\n# 5\n# 7\n# 9</code></pre>\n<p>1<br>3<br>5<br>7<br>9<br>6. enumerate()函数</p>\n<pre><code class=\"python\">enumerate(sequence, [start=0])</code></pre>\n<p>sequence：一个序列、迭代器或其他支持迭代对象。<br>start：下标起始位置。<br>返回 enumerate(枚举) 对象<br>【例子】</p>\n<pre><code class=\"python\">seasons = [&#39;Spring&#39;, &#39;Summer&#39;, &#39;Fall&#39;, &#39;Winter&#39;]\nlst = list(enumerate(seasons))\nprint(lst)\n# [(0, &#39;Spring&#39;), (1, &#39;Summer&#39;), (2, &#39;Fall&#39;), (3, &#39;Winter&#39;)]\nlst = list(enumerate(seasons, start=1))  # 下标从 1 开始\nprint(lst)\n# [(1, &#39;Spring&#39;), (2, &#39;Summer&#39;), (3, &#39;Fall&#39;), (4, &#39;Winter&#39;)]\n[(0, &#39;Spring&#39;), (1, &#39;Summer&#39;), (2, &#39;Fall&#39;), (3, &#39;Winter&#39;)]\n[(1, &#39;Spring&#39;), (2, &#39;Summer&#39;), (3, &#39;Fall&#39;), (4, &#39;Winter&#39;)]</code></pre>\n<p>enumerate()与 for 循环的结合使用。</p>\n<pre><code class=\"python\">for i, a in enumerate(A)\n    do something with a  \n    ```\n用 enumerate(A) 不仅返回了 A 中的元素，还顺便给该元素一个索引值 (默认从 0 开始)。此外，用 enumerate(A, j) 还可以确定索引起始值为 j。\n\n【例子】\n``` python\nlanguages = [&#39;Python&#39;, &#39;R&#39;, &#39;Matlab&#39;, &#39;C++&#39;]\nfor language in languages:\n    print(&#39;I love&#39;, language)\nprint(&#39;Done!&#39;)\n# I love Python\n# I love R\n# I love Matlab\n# I love C++\n# Done!\n​\n​\nfor i, language in enumerate(languages, 2):\n    print(i, &#39;I love&#39;, language)\nprint(&#39;Done!&#39;)\n# 2 I love Python\n# 3 I love R\n# 4 I love Matlab\n# 5 I love C++\n# Done!</code></pre>\n<p>I love Python<br>I love R<br>I love Matlab<br>I love C++<br>Done!<br>2 I love Python<br>3 I love R<br>4 I love Matlab<br>5 I love C++<br>Done!<br>7. break 语句<br>break语句可以跳出当前所在层的循环。</p>\n<p>【例子】</p>\n<pre><code class=\"python\">import random\nsecret = random.randint(1, 10) #[1,10]之间的随机数\n​\nwhile True:\n    temp = input(&quot;猜一猜小姐姐想的是哪个数字？&quot;)\n    guess = int(temp)\n    if guess &gt; secret:\n        print(&quot;大了，大了&quot;)\n    else:\n        if guess == secret:\n            print(&quot;你太了解小姐姐的心思了！&quot;)\n            print(&quot;哼，猜对也没有奖励！&quot;)\n            break\n        else:\n            print(&quot;小了，小了&quot;)\nprint(&quot;游戏结束，不玩儿啦！&quot;)</code></pre>\n<p>猜一猜小姐姐想的是哪个数字？8<br>你太了解小姐姐的心思了！<br>哼，猜对也没有奖励！<br>游戏结束，不玩儿啦！<br>8. continue 语句<br>continue终止本轮循环并开始下一轮循环。</p>\n<p>【例子】</p>\n<pre><code class=\"python\">for i in range(10):\n    if i % 2 != 0:\n        print(i)\n        continue\n    i += 2\n    print(i)\n​\n# 2\n# 1\n# 4\n# 3\n# 6\n# 5\n# 8\n# 7\n# 10\n# 9</code></pre>\n<p>2<br>1<br>4<br>3<br>6<br>5<br>8<br>7<br>10<br>9<br>9. pass 语句<br>pass 语句的意思是“不做任何事”，如果你在需要有语句的地方不写任何语句，那么解释器会提示出错，而 pass 语句就是用来解决这些问题的。</p>\n<p>【例子】</p>\n<pre><code class=\"python\">def a_func():\n\n# SyntaxError: unexpected EOF while parsing</code></pre>\n<p>【例子】</p>\n<pre><code class=\"python\">def a_func():\n    pass\n    ```\npass是空语句，不做任何操作，只起到占位的作用，其作用是为了保持程序结构的完整性。尽管pass语句不做任何操作，但如果暂时不确定要在一个位置放上什么样的代码，可以先放置一个pass语句，让代码可以正常运行。\n\n10. 推导式\n列表推导式\n\n[ expr for value in collection [if condition] ]\n【例子】\n``` python\nx = [-4, -2, 0, 2, 4]\ny = [a * 2 for a in x]\nprint(y)\n# [-8, -4, 0, 4, 8]</code></pre>\n<p>[-8, -4, 0, 4, 8]<br>【例子】</p>\n<pre><code class=\"python\">x = [i ** 2 for i in range(1, 10)]\nprint(x)\n# [1, 4, 9, 16, 25, 36, 49, 64, 81]</code></pre>\n<p>[1, 4, 9, 16, 25, 36, 49, 64, 81]<br>【例子】</p>\n<pre><code class=\"python\">x = [(i, i ** 2) for i in range(6)]\nprint(x)\n​\n# [(0, 0), (1, 1), (2, 4), (3, 9), (4, 16), (5, 25)]</code></pre>\n<p>[(0, 0), (1, 1), (2, 4), (3, 9), (4, 16), (5, 25)]<br>【例子】</p>\n<pre><code class=\"python\">x = [i for i in range(100) if (i % 2) != 0 and (i % 3) == 0]\nprint(x)\n​\n# [3, 9, 15, 21, 27, 33, 39, 45, 51, 57, 63, 69, 75, 81, 87, 93, 99]</code></pre>\n<p>[3, 9, 15, 21, 27, 33, 39, 45, 51, 57, 63, 69, 75, 81, 87, 93, 99]<br>【例子】</p>\n<pre><code class=\"python\">a = [(i, j) for i in range(0, 3) for j in range(0, 3)]\nprint(a)\n​\n# [(0, 0), (0, 1), (0, 2), (1, 0), (1, 1), (1, 2), (2, 0), (2, 1), (2, 2)]</code></pre>\n<p>[(0, 0), (0, 1), (0, 2), (1, 0), (1, 1), (1, 2), (2, 0), (2, 1), (2, 2)]<br>【例子】</p>\n<pre><code class=\"python\">x = [[i, j] for i in range(0, 3) for j in range(0, 3)]\nprint(x)\n# [[0, 0], [0, 1], [0, 2], [1, 0], [1, 1], [1, 2], [2, 0], [2, 1], [2, 2]]\n\nx[0][0] = 10\nprint(x)\n# [[10, 0], [0, 1], [0, 2], [1, 0], [1, 1], [1, 2], [2, 0], [2, 1], [2, 2]]</code></pre>\n<p>[[0, 0], [0, 1], [0, 2], [1, 0], [1, 1], [1, 2], [2, 0], [2, 1], [2, 2]]<br>[[10, 0], [0, 1], [0, 2], [1, 0], [1, 1], [1, 2], [2, 0], [2, 1], [2, 2]]<br>【例子】</p>\n<pre><code class=\"python\">a = [(i, j) for i in range(0, 3) if i &lt; 1 for j in range(0, 3) if j &gt; 1]\nprint(a)\n​\n# [(0, 2)]</code></pre>\n<p>[(0, 2)]<br>元组推导式<br>` python<br>( expr for value in collection [if condition] )</p>\n<p>【例子】</p>\n<pre><code class=\"python\">a = (x for x in range(10))\nprint(a)\n​\n# &lt;generator object &lt;genexpr&gt; at 0x0000025BE511CC48&gt;\n​\nprint(tuple(a))\n\n​\n# (0, 1, 2, 3, 4, 5, 6, 7, 8, 9)\n&lt;generator object &lt;genexpr&gt; at 0x0000014CEC2E28B8&gt;</code></pre>\n<p>(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)<br>字典推导式</p>\n<pre><code class=\"python\">&#123; key_expr: value_expr for value in collection [if condition] &#125;</code></pre>\n<p>【例子】</p>\n<pre><code class=\"python\">b = &#123;i: i % 2 == 0 for i in range(10) if i % 3 == 0&#125;\nprint(b)\n# &#123;0: True, 3: False, 6: True, 9: False&#125;</code></pre>\n<p>{0: True, 3: False, 6: True, 9: False}<br>集合推导式</p>\n<pre><code class=\"python\">&#123; expr for value in collection [if condition] &#125;</code></pre>\n<p>【例子】</p>\n<pre><code class=\"python\">c = &#123;i for i in [1, 2, 3, 4, 5, 5, 6, 4, 3, 2, 1]&#125;\nprint(c)\n# &#123;1, 2, 3, 4, 5, 6&#125;</code></pre>\n<p>{1, 2, 3, 4, 5, 6}<br>其它</p>\n<pre><code>next(iterator[, default]) Return the next item from the iterator. If default is given and the iterator is exhausted, it is returned instead of raising StopIteration.</code></pre>\n<p>【例子】</p>\n<pre><code class=\"python\">e = (i for i in range(10))\nprint(e)\n# &lt;generator object &lt;genexpr&gt; at 0x0000007A0B8D01B0&gt;\n​\nprint(next(e))  # 0\nprint(next(e))  # 1\n​\nfor each in e:\n    print(each, end=&#39; &#39;)\n​\n# 2 3 4 5 6 7 8 9\n&lt;generator object &lt;genexpr&gt; at 0x0000014CEC389C78&gt;</code></pre>\n<p>0<br>1<br>2 3 4 5 6 7 8 9<br>【例子】</p>\n<pre><code class=\"python\">s = sum([i for i in range(101)])\nprint(s)  # 5050\ns = sum((i for i in range(101)))\nprint(s)  # 5050</code></pre>\n<p>5050<br>5050<br>异常处理<br>异常就是运行期检测到的错误。计算机语言针对可能出现的错误定义了异常类型，某种错误引发对应的异常时，异常处理程序将被启动，从而恢复程序的正常运行。</p>\n<ol>\n<li>Python 标准异常总结<br>BaseException：所有异常的 基类<br>Exception：常规异常的 基类<br>StandardError：所有的内建标准异常的基类<br>ArithmeticError：所有数值计算异常的基类<br>FloatingPointError：浮点计算异常<br>OverflowError：数值运算超出最大限制<br>ZeroDivisionError：除数为零<br>AssertionError：断言语句（assert）失败<br>AttributeError：尝试访问未知的对象属性<br>EOFError：没有内建输入，到达EOF标记<br>EnvironmentError：操作系统异常的基类<br>IOError：输入/输出操作失败<br>OSError：操作系统产生的异常（例如打开一个不存在的文件）<br>WindowsError：系统调用失败<br>ImportError：导入模块失败的时候<br>KeyboardInterrupt：用户中断执行<br>LookupError：无效数据查询的基类<br>IndexError：索引超出序列的范围<br>KeyError：字典中查找一个不存在的关键字<br>MemoryError：内存溢出（可通过删除对象释放内存）<br>NameError：尝试访问一个不存在的变量<br>UnboundLocalError：访问未初始化的本地变量<br>ReferenceError：弱引用试图访问已经垃圾回收了的对象<br>RuntimeError：一般的运行时异常<br>NotImplementedError：尚未实现的方法<br>SyntaxError：语法错误导致的异常<br>IndentationError：缩进错误导致的异常<br>TabError：Tab和空格混用<br>SystemError：一般的解释器系统异常<br>TypeError：不同类型间的无效操作<br>ValueError：传入无效的参数<br>UnicodeError：Unicode相关的异常<br>UnicodeDecodeError：Unicode解码时的异常<br>UnicodeEncodeError：Unicode编码错误导致的异常<br>UnicodeTranslateError：Unicode转换错误导致的异常<br>异常体系内部有层次关系，Python异常体系中的部分关系如下所示：</li>\n</ol>\n<p>Image</p>\n<ol start=\"2\">\n<li>Python标准警告总结<br>Warning：警告的基类<br>DeprecationWarning：关于被弃用的特征的警告<br>FutureWarning：关于构造将来语义会有改变的警告<br>UserWarning：用户代码生成的警告<br>PendingDeprecationWarning：关于特性将会被废弃的警告<br>RuntimeWarning：可疑的运行时行为(runtime behavior)的警告<br>SyntaxWarning：可疑语法的警告<br>ImportWarning：用于在导入模块过程中触发的警告<br>UnicodeWarning：与Unicode相关的警告<br>BytesWarning：与字节或字节码相关的警告<br>ResourceWarning：与资源使用相关的警告</li>\n<li>try - except 语句<br>try:<br> 检测范围<br>except Exception[as reason]:<br> 出现异常后的处理代码<br>try 语句按照如下方式工作：</li>\n</ol>\n<p>首先，执行try子句（在关键字try和关键字except之间的语句）<br>如果没有异常发生，忽略except子句，try子句执行后结束。<br>如果在执行try子句的过程中发生了异常，那么try子句余下的部分将被忽略。如果异常的类型和except之后的名称相符，那么对应的except子句将被执行。最后执行try - except语句之后的代码。<br>如果一个异常没有与任何的except匹配，那么这个异常将会传递给上层的try中。<br>【例子】</p>\n<pre><code class=\"python\">try:\n    f = open(&#39;test.txt&#39;)\n    print(f.read())\n    f.close()\nexcept OSError:\n    print(&#39;打开文件出错&#39;)\n​\n# 打开文件出错</code></pre>\n<p>打开文件出错<br>【例子】</p>\n<pre><code class=\"python\">try:\n    f = open(&#39;test.txt&#39;)\n    print(f.read())\n    f.close()\nexcept OSError as error:\n    print(&#39;打开文件出错\\n原因是：&#39; + str(error))\n​\n# 打开文件出错\n# 原因是：[Errno 2] No such file or directory: &#39;test.txt&#39;</code></pre>\n<p>打开文件出错<br>原因是：[Errno 2] No such file or directory: ‘test.txt’<br>一个try语句可能包含多个except子句，分别来处理不同的特定的异常。最多只有一个分支会被执行。</p>\n<p>【例子】</p>\n<pre><code class=\"python\">try:\n    int(&quot;abc&quot;)\n    s = 1 + &#39;1&#39;\n    f = open(&#39;test.txt&#39;)\n    print(f.read())\n    f.close()\nexcept OSError as error:\n    print(&#39;打开文件出错\\n原因是：&#39; + str(error))\nexcept TypeError as error:\n    print(&#39;类型出错\\n原因是：&#39; + str(error))\nexcept ValueError as error:\n    print(&#39;数值出错\\n原因是：&#39; + str(error))\n​\n# 数值出错\n# 原因是：invalid literal for int() with base 10: &#39;abc&#39;</code></pre>\n<p>数值出错<br>原因是：invalid literal for int() with base 10: ‘abc’<br>【例子】</p>\n<pre><code class=\"python\">dict1 = &#123;&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;v&#39;: 22&#125;\ntry:\n    x = dict1[&#39;y&#39;]\nexcept LookupError:\n    print(&#39;查询错误&#39;)\nexcept KeyError:\n    print(&#39;键错误&#39;)\nelse:\n    print(x)\n​\n# 查询错误</code></pre>\n<p>查询错误<br>try-except-else语句尝试查询不在dict中的键值对，从而引发了异常。这一异常准确地说应属于KeyError，但由于KeyError是LookupError的子类，且将LookupError置于KeyError之前，因此程序优先执行该except代码块。所以，使用多个except代码块时，必须坚持对其规范排序，要从最具针对性的异常到最通用的异常。</p>\n<p>【例子】</p>\n<pre><code class=\"python\">dict1 = &#123;&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;v&#39;: 22&#125;\ntry:\n    x = dict1[&#39;y&#39;]\nexcept KeyError:\n    print(&#39;键错误&#39;)\nexcept LookupError:\n    print(&#39;查询错误&#39;)\nelse:\n    print(x)\n​\n# 键错误</code></pre>\n<p>键错误<br>【例子】一个 except 子句可以同时处理多个异常，这些异常将被放在一个括号里成为一个元组。</p>\n<pre><code class=\"python\">try:\n    s = 1 + &#39;1&#39;\n    int(&quot;abc&quot;)\n    f = open(&#39;test.txt&#39;)\n    print(f.read())\n    f.close()\nexcept (OSError, TypeError, ValueError) as error:\n    print(&#39;出错了！\\n原因是：&#39; + str(error))\n​\n# 出错了！\n# 原因是：unsupported operand type(s) for +: &#39;int&#39; and &#39;str&#39;</code></pre>\n<p>出错了！<br>原因是：unsupported operand type(s) for +: ‘int’ and ‘str’<br>4. try - except - finally 语句<br>try: 检测范围 except Exception[as reason]: 出现异常后的处理代码 finally: 无论如何都会被执行的代码</p>\n<p>不管try子句里面有没有发生异常，finally子句都会执行。</p>\n<p>【例子】如果一个异常在try子句里被抛出，而又没有任何的except把它截住，那么这个异常会在finally子句执行后被抛出。</p>\n<pre><code class=\"python\">def divide(x, y):\n    try:\n        result = x / y\n        print(&quot;result is&quot;, result)\n    except ZeroDivisionError:\n        print(&quot;division by zero!&quot;)\n    finally:\n        print(&quot;executing finally clause&quot;)\n​\n​\ndivide(2, 1)\n# result is 2.0\n# executing finally clause\ndivide(2, 0)\n# division by zero!\n# executing finally clause\ndivide(&quot;2&quot;, &quot;1&quot;)\n# executing finally clause\n# TypeError: unsupported operand type(s) for /: &#39;str&#39; and &#39;str&#39;</code></pre>\n<p>result is 2.0<br>executing finally clause<br>division by zero!<br>executing finally clause<br>5. try - except - else 语句<br>如果在try子句执行时没有发生异常，Python将执行else语句后的语句。</p>\n<pre><code class=\"python\">try:\n    检测范围\nexcept:\n    出现异常后的处理代码\nelse:\n    如果没有异常执行这块代码\n    ```\n使用except而不带任何异常类型，这不是一个很好的方式，我们不能通过该程序识别出具体的异常信息，因为它捕获所有的异常。\n\ntry: 检测范围 except(Exception1[, Exception2[,...ExceptionN]]]): 发生以上多个异常中的一个，执行这块代码 else: 如果没有异常执行这块代码\n\n【例子】\n``` python\ntry:\n    fh = open(&quot;testfile.txt&quot;, &quot;w&quot;)\n    fh.write(&quot;这是一个测试文件，用于测试异常!!&quot;)\nexcept IOError:\n    print(&quot;Error: 没有找到文件或读取文件失败&quot;)\nelse:\n    print(&quot;内容写入文件成功&quot;)\n    fh.close()\n​\n# 内容写入文件成功</code></pre>\n<p>内容写入文件成功<br>注意：else语句的存在必须以except语句的存在为前提，在没有except语句的try语句中使用else语句，会引发语法错误。</p>\n<ol start=\"6\">\n<li>raise语句<br>Python 使用raise语句抛出一个指定的异常。</li>\n</ol>\n<p>【例子】</p>\n<pre><code class=\"python\">try:\n    raise NameError(&#39;HiThere&#39;)\nexcept NameError:\n    print(&#39;An exception flew by!&#39;)\n\n# An exception flew by!\ntry:\n    raise NameError(&#39;HiThere&#39;)\nexcept NameError:\n    print(&#39;An exception flew by!&#39;)\n\n# An exception flew by!</code></pre>\n",
            "tags": [
                "python"
            ]
        },
        {
            "id": "http://47.97.229.110/2021/01/29/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0_1_day/",
            "url": "http://47.97.229.110/2021/01/29/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0_1_day/",
            "title": "深度学习_1_day",
            "date_published": "2021-01-29T13:39:01.000Z",
            "content_html": "<p>基于人脸的常见表情识别——模型搭建、训练与测试<br>模型搭建与训练</p>\n<ol>\n<li>数据接口准备</li>\n<li>模型定义</li>\n<li>模型训练</li>\n</ol>\n<p>模型测试</p>\n<p>本 Task 是『基于人脸的常见表情识别』训练营的第 3 课，如果你未学习前面的课程，请从 Task1 开始学习，本 Task 需要使用到数据集，在 Task2 中提供下载的渠道。</p>\n<p>在完成了数据准备后，接下来就是卷积神经网络一展身手的时候了，通过本次任务，您将学到如何使用 PyTorch 深度学习框架，实现卷积神经网络的定义、训练和预测。</p>\n<p>模型搭建与训练<br>得到了数据之后，接下来咱们使用 PyTorch 这个框架来进行模型的训练。整个训练流程包括数据接口准备、模型定义、结果保存与分析。</p>\n<ol>\n<li>数据接口准备<br>PyTorch 图像分类直接利用文件夹作为输入，只需要把不同类的数据放到不同的文件夹中。数据读取的完整代码如下：<pre><code class=\"python\">data_transforms = &#123;\n &#39;train&#39;: transforms.Compose([\n     transforms.RandomSizedCrop(48),\n     transforms.RandomHorizontalFlip(),\n     transforms.ToTensor(),\n     transforms.Normalize([0.5,0.5,0.5], [0.5,0.5,0.5])\n ]),\n &#39;val&#39;: transforms.Compose([\n     transforms.Scale(64),\n     transforms.CenterCrop(48),\n     transforms.ToTensor(),\n     transforms.Normalize([0.5,0.5,0.5], [0.5,0.5,0.5])\n ]),\n&#125;\n</code></pre>\n</li>\n</ol>\n<p>data_dir = ‘./train_val_data/‘<br>image_datasets = {x: datasets.ImageFolder(os.path.join(data_dir, x),<br>                                          data_transforms[x]) for x in [‘train’, ‘val’]}<br>dataloders = {x: torch.utils.data.DataLoader(image_datasets[x],<br>                                             batch_size=16,<br>                                             shuffle=True,<br>                                             num_workers=4) for x in [‘train’, ‘val’]}</p>\n<pre><code>上面脚本中的函数，输入一个文件夹，输出图片路径以及标签，在开始训练之前需要将数据集进行拆分，拆分成训练集(train)和验证集(val)，训练集和测试集的比例为9:1，train_val_data文件结构如下所示，其中 0 代表 none、 1 代表pouting、2 代表 smile、3 代表 openmouth：\n``` python\n- train_val_data\n    - train\n        - 0\n        - 1\n        - 2\n        - 3\n\n    - val\n        - 0\n        - 1\n        - 2\n        - 3</code></pre>\n<p>到此，数据接口就定义完毕了，接下来在训练代码中看如何使用迭代器进行数据读取就可以了。</p>\n<ol start=\"2\">\n<li>模型定义<br>创建数据接⼝后，我们开始定义⼀个⽹络 simpleconv3<pre><code class=\"python\">import torch.nn as nn\nimport torch.nn.functional as F\n​\nclass simpleconv3(nn.Module):\n def __init__(self):\n     super(simpleconv3,self).__init__()\n     self.conv1 = nn.Conv2d(3, 12, 3, 2)\n     self.bn1 = nn.BatchNorm2d(12)\n     self.conv2 = nn.Conv2d(12, 24, 3, 2)\n     self.bn2 = nn.BatchNorm2d(24)\n     self.conv3 = nn.Conv2d(24, 48, 3, 2)\n     self.bn3 = nn.BatchNorm2d(48)\n     self.fc1 = nn.Linear(48 * 5 * 5 , 1200)\n     self.fc2 = nn.Linear(1200 , 128)\n     self.fc3 = nn.Linear(128 , 4)\n​\n def forward(self , x):\n     x = F.relu(self.bn1(self.conv1(x)))\n     #print &quot;bn1 shape&quot;,x.shape\n     x = F.relu(self.bn2(self.conv2(x)))\n     x = F.relu(self.bn3(self.conv3(x)))\n     x = x.view(-1 , 48 * 5 * 5) \n     x = F.relu(self.fc1(x))\n     x = F.relu(self.fc2(x))\n     x = self.fc3(x)\n     return x</code></pre>\n上面就是我们定义的网络，是一个简单的 3 层卷积。在 torch.nn 下，有各种网络层，这里就用到了 nn.Conv2d，nn.BatchNorm2d 和 nn.Linear，分别是卷积层，BN 层和全连接层。我们以一个卷积层为例：</li>\n</ol>\n<p>conv1 = nn.Conv2d(in_channels=3, out_channels=12, kernel_size=3, stride=2)<br>bn1 = nn.BatchNorm2d(num_features=12)<br>in_channels：输入通道数<br>out_channels：输出通道数<br>kernel_size：卷积核的大小<br>stride：卷积核的移动步长<br>更全面的参数，请自查 API：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9weXRvcmNoLm9yZy8=\">https://pytorch.org/</span></p>\n<ol start=\"3\">\n<li>模型训练<br>这里准备好了数据集，可以直接使用</li>\n</ol>\n<p>深度学习一般使用 GPU 进行训练，大家可以根据下图的操作，将设备切换至 GPU状态，再运行下面的程序，切换过程需要一定时间，请耐心等待</p>\n<p>Image</p>\n<pre><code class=\"python\">#coding:utf8\nfrom __future__ import print_function, division\n​\nimport torch\nimport torch.nn as nn\nimport torch.optim as optim\nfrom torch.optim import lr_scheduler\nfrom torch.autograd import Variable\nimport torchvision\nfrom torchvision import datasets, models, transforms\nimport time\nimport os\nfrom tensorboardX import SummaryWriter\nimport torch.nn.functional as F\nimport numpy as np\n​\nimport warnings\n​\nwarnings.filterwarnings(&#39;ignore&#39;)\n​\nwriter = SummaryWriter()\n​\ndef train_model(model, criterion, optimizer, scheduler, num_epochs=25):\n    for epoch in range(num_epochs):\n        print(&#39;Epoch &#123;&#125;/&#123;&#125;&#39;.format(epoch, num_epochs - 1))\n        for phase in [&#39;train&#39;, &#39;val&#39;]:\n            if phase == &#39;train&#39;:\n                scheduler.step()\n                model.train(True)  # Set model to training mode\n            else:\n                model.train(False)  # Set model to evaluate mode\n​\n            running_loss = 0.0\n            running_corrects = 0.0\n​\n            for data in dataloders[phase]:\n                inputs, labels = data\n                if use_gpu:\n                    inputs = Variable(inputs.cuda())\n                    labels = Variable(labels.cuda())\n                else:\n                    inputs, labels = Variable(inputs), Variable(labels)\n​\n                optimizer.zero_grad()\n                outputs = model(inputs)\n                _, preds = torch.max(outputs.data, 1)\n                loss = criterion(outputs, labels)\n                if phase == &#39;train&#39;:\n                    loss.backward()\n                    optimizer.step()\n​\n                running_loss += loss.data.item()\n                running_corrects += torch.sum(preds == labels).item()\n​\n            epoch_loss = running_loss / dataset_sizes[phase]\n            epoch_acc = running_corrects / dataset_sizes[phase]\n\n            if phase == &#39;train&#39;:\n                writer.add_scalar(&#39;data/trainloss&#39;, epoch_loss, epoch)\n                writer.add_scalar(&#39;data/trainacc&#39;, epoch_acc, epoch)\n            else:\n                writer.add_scalar(&#39;data/valloss&#39;, epoch_loss, epoch)\n                writer.add_scalar(&#39;data/valacc&#39;, epoch_acc, epoch)\n​\n            print(&#39;&#123;&#125; Loss: &#123;:.4f&#125; Acc: &#123;:.4f&#125;&#39;.format(\n                phase, epoch_loss, epoch_acc))\n​\n    writer.export_scalars_to_json(&quot;./all_scalars.json&quot;)\n    writer.close()\n    return model\n​\nif __name__ == &#39;__main__&#39;:\n​\n    data_transforms = &#123;\n        &#39;train&#39;: transforms.Compose([\n            transforms.RandomSizedCrop(48),\n            transforms.RandomHorizontalFlip(),\n            transforms.ToTensor(),\n            transforms.Normalize([0.5,0.5,0.5], [0.5,0.5,0.5])\n        ]),\n        &#39;val&#39;: transforms.Compose([\n            transforms.Scale(64),\n            transforms.CenterCrop(48),\n            transforms.ToTensor(),\n            transforms.Normalize([0.5,0.5,0.5], [0.5,0.5,0.5])\n        ]),\n    &#125;\n​\n    data_dir = &#39;./Emotion_Recognition_File/train_val_data/&#39; # 数据集所在的位置\n    image_datasets = &#123;x: datasets.ImageFolder(os.path.join(data_dir, x),\n                                              data_transforms[x]) for x in [&#39;train&#39;, &#39;val&#39;]&#125;\n    dataloders = &#123;x: torch.utils.data.DataLoader(image_datasets[x],\n                                                 batch_size=64,\n                                                 shuffle=True if x==&quot;train&quot; else False,\n                                                 num_workers=8) for x in [&#39;train&#39;, &#39;val&#39;]&#125;\n​\n    dataset_sizes = &#123;x: len(image_datasets[x]) for x in [&#39;train&#39;, &#39;val&#39;]&#125;\n​\n    use_gpu = torch.cuda.is_available()\n    print(&quot;是否使用 GPU&quot;, use_gpu)\n    modelclc = simpleconv3()\n    print(modelclc)\n    if use_gpu:\n        modelclc = modelclc.cuda()\n​\n    criterion = nn.CrossEntropyLoss()\n    optimizer_ft = optim.SGD(modelclc.parameters(), lr=0.1, momentum=0.9)\n    exp_lr_scheduler = lr_scheduler.StepLR(optimizer_ft, step_size=100, gamma=0.1)\n​\n    modelclc = train_model(model=modelclc,\n                           criterion=criterion,\n                           optimizer=optimizer_ft,\n                           scheduler=exp_lr_scheduler,\n                           num_epochs=10)  # 这里可以调节训练的轮次\n    if not os.path.exists(&quot;models&quot;):\n        os.mkdir(&#39;models&#39;)\n    torch.save(modelclc.state_dict(),&#39;models/model.ckpt&#39;)</code></pre>\n<p>训练的过程需要注意几个参数，第一个是数据加载器(dataloders)中的 batch_size，这个代表的含义是每次送入模型训练的图片数量，这个需要根据GPU的显存来设置，显存越大，可以设置越大，这个数一般设置为 2 的整数次幂（如 4、8、16、32 等）</p>\n<p>dataloders = {x: torch.utils.data.DataLoader(image_datasets[x],<br>                              batch_size=64,<br>                              shuffle=True if x==”train” else False,<br>                              num_workers=8) for x in [‘train’, ‘val’]}<br>第二个需要注意的参数是训练函数的 num_epochs，这个参数代表的意义是，模型训练的轮次。</p>\n<p>modelclc = train_model(model=modelclc,<br>               criterion=criterion,<br>               optimizer=optimizer_ft,<br>               scheduler=exp_lr_scheduler,<br>               num_epochs=10)  # 这里可以调节训练的轮次<br>模型测试<br>上⾯已经训练好了模型，我们接下来的⽬标，就是要⽤它来做推理，真正把模型⽤起来，下⾯我们载⼊⼀个图⽚，⽤模型进⾏测试。 结果在 results 文件夹中</p>\n<pre><code class=\"python\"># coding:utf8\n​\nimport sys\nimport numpy as np\nimport cv2\nimport os\nimport dlib\n​\nimport torch\nimport torch.nn as nn\nimport torch.optim as optim\nfrom torch.optim import lr_scheduler\nfrom torch.autograd import Variable\nimport torchvision\nfrom torchvision import datasets, models, transforms\nimport time\nfrom PIL import Image\nimport torch.nn.functional as F\n​\nimport matplotlib.pyplot as plt\nimport warnings\n​\nwarnings.filterwarnings(&#39;ignore&#39;)\n​\n​\nPREDICTOR_PATH = &quot;./Emotion_Recognition_File/face_detect_model/shape_predictor_68_face_landmarks.dat&quot;\npredictor = dlib.shape_predictor(PREDICTOR_PATH)\ncascade_path = &#39;./Emotion_Recognition_File/face_detect_model/haarcascade_frontalface_default.xml&#39;\ncascade = cv2.CascadeClassifier(cascade_path)\n​\nif not os.path.exists(&quot;results&quot;):\n    os.mkdir(&quot;results&quot;)\n\n​\ndef standardization(data):\n    mu = np.mean(data, axis=0)\n    sigma = np.std(data, axis=0)\n    return (data - mu) / sigma\n​\n​\ndef get_landmarks(im):\n    rects = cascade.detectMultiScale(im, 1.3, 5)\n    x, y, w, h = rects[0]\n    rect = dlib.rectangle(int(x), int(y), int(x + w), int(y + h))\n    return np.matrix([[p.x, p.y] for p in predictor(im, rect).parts()])\n​\n​\ndef annotate_landmarks(im, landmarks):\n    im = im.copy()\n    for idx, point in enumerate(landmarks):\n        pos = (point[0, 0], point[0, 1])\n        cv2.putText(im,\n                    str(idx),\n                    pos,\n                    fontFace=cv2.FONT_HERSHEY_SCRIPT_SIMPLEX,\n                    fontScale=0.4,\n                    color=(0, 0, 255))\n        cv2.circle(im, pos, 3, color=(0, 255, 255))\n    return im\n​\n​\ntestsize = 48  # 测试图大小\n​\ndata_transforms = transforms.Compose([\n    transforms.ToTensor(),\n    transforms.Normalize([0.5, 0.5, 0.5], [0.5, 0.5, 0.5])\n])\nnet = simpleconv3()\nnet.eval()\nmodelpath = &quot;./models/model.ckpt&quot;  # 模型路径\nnet.load_state_dict(\n    torch.load(modelpath, map_location=lambda storage, loc: storage))\n​\n# 一次测试一个文件\nimg_path = &quot;./Emotion_Recognition_File/find_face_img/&quot;\nimagepaths = os.listdir(img_path)  # 图像文件夹\nfor imagepath in imagepaths:\n    im = cv2.imread(os.path.join(img_path, imagepath), 1)\n    try:\n        rects = cascade.detectMultiScale(im, 1.3, 5)\n        x, y, w, h = rects[0]\n        rect = dlib.rectangle(int(x), int(y), int(x + w), int(y + h))\n        landmarks = np.matrix([[p.x, p.y]\n                               for p in predictor(im, rect).parts()])\n    except:\n#         print(&quot;没有检测到人脸&quot;)\n        continue  # 没有检测到人脸\n​\n    xmin = 10000\n    xmax = 0\n    ymin = 10000\n    ymax = 0\n​\n    for i in range(48, 67):\n        x = landmarks[i, 0]\n        y = landmarks[i, 1]\n        if x &lt; xmin:\n            xmin = x\n        if x &gt; xmax:\n            xmax = x\n        if y &lt; ymin:\n            ymin = y\n        if y &gt; ymax:\n            ymax = y\n​\n    roiwidth = xmax - xmin\n    roiheight = ymax - ymin\n​\n    roi = im[ymin:ymax, xmin:xmax, 0:3]\n​\n    if roiwidth &gt; roiheight:\n        dstlen = 1.5 * roiwidth\n    else:\n        dstlen = 1.5 * roiheight\n​\n    diff_xlen = dstlen - roiwidth\n    diff_ylen = dstlen - roiheight\n​\n    newx = xmin\n    newy = ymin\n​\n    imagerows, imagecols, channel = im.shape\n    if newx &gt;= diff_xlen / 2 and newx + roiwidth + diff_xlen / 2 &lt; imagecols:\n        newx = newx - diff_xlen / 2\n    elif newx &lt; diff_xlen / 2:\n        newx = 0\n    else:\n        newx = imagecols - dstlen\n​\n    if newy &gt;= diff_ylen / 2 and newy + roiheight + diff_ylen / 2 &lt; imagerows:\n        newy = newy - diff_ylen / 2\n    elif newy &lt; diff_ylen / 2:\n        newy = 0\n    else:\n        newy = imagecols - dstlen\n​\n    roi = im[int(newy):int(newy + dstlen), int(newx):int(newx + dstlen), 0:3]\n    roi = cv2.cvtColor(roi, cv2.COLOR_BGR2RGB)\n    roiresized = cv2.resize(roi,\n                            (testsize, testsize)).astype(np.float32) / 255.0\n    imgblob = data_transforms(roiresized).unsqueeze(0)\n    imgblob.requires_grad = False\n    imgblob = Variable(imgblob)\n    torch.no_grad()\n    predict = F.softmax(net(imgblob))\n    print(predict)\n    index = np.argmax(predict.detach().numpy())\n​\n    im_show = cv2.imread(os.path.join(img_path, imagepath), 1)\n    im_h, im_w, im_c = im_show.shape\n    pos_x = int(newx + dstlen)\n    pos_y = int(newy + dstlen)\n    font = cv2.FONT_HERSHEY_SIMPLEX\n    cv2.rectangle(im_show, (int(newx), int(newy)),\n                  (int(newx + dstlen), int(newy + dstlen)), (0, 255, 255), 2)\n    if index == 0:\n        cv2.putText(im_show, &#39;none&#39;, (pos_x, pos_y), font, 1.5, (0, 0, 255), 2)\n    if index == 1:\n        cv2.putText(im_show, &#39;pout&#39;, (pos_x, pos_y), font, 1.5, (0, 0, 255), 2)\n    if index == 2:\n        cv2.putText(im_show, &#39;smile&#39;, (pos_x, pos_y), font, 1.5, (0, 0, 255), 2)\n    if index == 3:\n        cv2.putText(im_show, &#39;open&#39;, (pos_x, pos_y), font, 1.5, (0, 0, 255), 2)\n#     cv2.namedWindow(&#39;result&#39;, 0)\n#     cv2.imshow(&#39;result&#39;, im_show)\n    cv2.imwrite(os.path.join(&#39;results&#39;, imagepath), im_show)\n#     print(os.path.join(&#39;results&#39;, imagepath))\n    plt.imshow(im_show[:, :, ::-1])  # 这里需要交换通道，因为 matplotlib 保存图片的通道顺序是 RGB，而在 OpenCV 中是 BGR\n    plt.show()\n#     cv2.waitKey(0)\n# cv2.destroyAllWindows()\ntensor([[8.1330e-03, 6.7033e-04, 9.8497e-01, 6.2311e-03]],\n       grad_fn=&lt;SoftmaxBackward&gt;)\n\ntensor([[1.0822e-06, 1.9005e-09, 1.0000e+00, 2.3623e-07]],\n       grad_fn=&lt;SoftmaxBackward&gt;)\n\ntensor([[9.9190e-01, 3.7207e-03, 4.3589e-03, 1.5936e-05]],\n       grad_fn=&lt;SoftmaxBackward&gt;)\n\ntensor([[4.3434e-07, 1.2525e-06, 1.1251e-05, 9.9999e-01]],\n       grad_fn=&lt;SoftmaxBackward&gt;)\n\ntensor([[0.0899, 0.8970, 0.0115, 0.0016]], grad_fn=&lt;SoftmaxBackward&gt;)</code></pre>\n<p>再次说明：0 代表 none、 1 代表pouting、2 代表 smile、3 代表 openmouth</p>\n<p>上面展示的图片上方会有一个输出，如：tensor([[8.1330e-03, 6.7033e-04, 9.8497e-01, 6.2311e-03]])</p>\n<p>这个代表的含义是，该图片在这个模型预测下，是该类别的可能性，比如上面这个例子 9.8497e-01 是四个值最大的，它的索引是 2（从 0 开始算），所以预测该图片为 smile</p>\n<p>以上就是本训练营的全部内容了，希望通过本次训练营，可以帮助大家搭建起一个深度学习项目的框架，然后将所学的知识应用到自己的项目、工作中。谢谢！</p>\n<p>– By：有三AI 团队</p>\n<p>聚焦于让大家能够系统性地完成AI各个领域所需的专业知识的学习，实现三人行必有AI，三人行必有我师的愿景。</p>\n",
            "tags": [
                "人工智能"
            ]
        },
        {
            "id": "http://47.97.229.110/2021/01/29/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0_2-day/",
            "url": "http://47.97.229.110/2021/01/29/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0_2-day/",
            "title": "深度学习_2_day",
            "date_published": "2021-01-29T13:39:01.000Z",
            "content_html": "<p>基于人脸的常见表情识别(1)——深度学习基础知识<br>神经网络</p>\n<ol>\n<li>感知机</li>\n<li>多层感知机与反向传播</li>\n</ol>\n<p>卷积神经网络</p>\n<ol>\n<li>全连接神经网络的2大缺陷</li>\n<li>卷积神经网络的崛起</li>\n</ol>\n<p>卷积神经网络的基本网络层</p>\n<ol>\n<li>什么是卷积？</li>\n<li>填充（Padding）</li>\n<li>步长（Stride）</li>\n<li>池化</li>\n<li>卷积和池化输出尺寸计算</li>\n<li>为什么要用卷积来学习呢？</li>\n<li>卷积神经网络的优势在哪？<br>本训练营以理论结合实战的方式，帮助大家从 0 完成一个人脸常见表情的识别，接下来是本训练营的理论部分。不要觉得理论枯燥哦，万丈高楼平地起，基础打牢了，后面学什么都容易，让我们开始吧~</li>\n</ol>\n<p>神经网络</p>\n<ol>\n<li>感知机<br>感知机（Perceptron）是 Frank Rosenblatt 在1957年提出的概念，其结构与MP模型类似，一般被视为最简单的人工神经网络，也作为二元线性分类器被广泛使用。通常情况下指单层的人工神经网络，以区别于多层感知机（Multilayer Perceptron）。尽管感知机结构简单，但能够学习并解决较复杂问题。</li>\n</ol>\n<p>Image</p>\n<p>假设我们有一个n维输入的单层感知机，$x_1$ 至 $x_n$ 为 n 维输入向量的各个分量，$w_{1j}$ 至 $w_{nj}$为各个输入分量连接到感知机的权量（或称权值），theta 为阈值，f 为激活函数（又称为激励函数或传递函数），o 为标量输出。理想的激活函数通常为阶跃函数或者sigmoid函数。感知机的输出是输入向量x与权重向量w求得内积后，经激活函数f所得到的标量。</p>\n<p>单层感知器类似一个逻辑回归模型，可以做线性分类任务，但是不能做更复杂的任务。第二次AI浪潮中马文·明斯基在其著作中证明了感知机本质上是一种线性模型，只能处理线性分类问题，就连最简单的 XOR（异或）问题都无法正确解决。作为人工智能领域的开创者之一，这一声明也直接或间接促使神经网络的研究陷入了近 20 年的停滞。</p>\n<ol start=\"2\">\n<li>多层感知机与反向传播<br>不过就算在低谷期，1974 年哈佛大学的 Paul Werbos 仍然证明增加一个网络层，利用反向传播算法可以搞定 XOR 问题。到了后来 Rummelhart，McClelland 以及 Hinton 在 1986 年正式在多层感知器 (MLP) 中使用 BP 算法，采用 Sigmoid 进行非线性映射，有效解决了非线性分类和学习的问题。</li>\n</ol>\n<p>Image</p>\n<p>多层感知机（Multi-Layer Perceptron）是由单层感知机推广而来，最主要的特点是有多个神经元层。一般将 MLP 的第一层称为输入层，中间的层为隐藏层，最后一层为输出层。MLP 并没有规定隐藏层的数量，因此可以根据实际处理需求选择合适的隐藏层层数，且对于隐藏层和输出层中每层神经元的个数也没有限制。</p>\n<p>多层感知机的关键问题在于如何训练其中各层间的连接权值，方法有一些不过大家最熟知的就是反向传播BP算法了。</p>\n<p>反向传播算法的具体推导涉及大量的公式，因此我们就不写了，大家随便找一本书都能找到资料，勤快的可以自己推导一遍。</p>\n<p>这里给大家一个实际的案例来体会：</p>\n<p>Image</p>\n<p>输出为y，损失函数为E。</p>\n<p>$$ \\begin{array}{l} y=h_{1} w_{h 1}+h_{2} w_{h 2}=x_{1} w_{11}+x_{2} w_{12}+x_{2} w_{21}+x_{2} w_{22} \\ E=\\frac{1}{2}(y-t)^{2} \\end{array} $$</p>\n<p>假如某一时刻值如下：</p>\n<p>$$ \\begin{array}{l} \\mathrm{x}<em>{1}=1, \\mathrm{x}</em>{2}=-1, \\mathrm{w}<em>{11}=0.1, \\mathrm{w}</em>{21}=-0.1, \\mathrm{w}<em>{12}=-0.1 \\ \\mathrm{w}</em>{22}=0.1, \\mathrm{w}<em>{\\mathrm{h} 1}=0.8, \\mathrm{w}</em>{\\mathrm{h} 2}=0.9, \\mathrm{t}=0 \\end{array} $$</p>\n<p>$$ \\begin{array}{l} h_{1}=w_{11} x_{1}+w_{12} x_{2}=0.2 \\ h_{2}=w_{21} x_{1}+w_{22} x_{2}=-0.2 \\ y=h_{1} w_{h 1}+h_{2} w_{h 2}=-0.02 \\end{array} $$</p>\n<p>那么我们可以计算E对$W_{h1}$的误差传播值为：</p>\n<p>$$ \\frac{\\partial \\mathrm{E}}{\\partial w_{h 1}}=\\frac{\\partial \\mathrm{E}}{\\partial \\mathrm{y}} \\frac{\\partial y}{\\partial w_{h 1}}=(y-t) h_{1}=-0.004 $$</p>\n<p>下次更新$W_{h1}$这个参数的时候就可以采用：</p>\n<p>$$ w_{h 1}=w_{h 1}-\\eta \\frac{\\partial E}{\\partial w_{h 1}} $$</p>\n<p>η就是学习率了，原理就是这样，一层一层推导下去就行了。</p>\n<p>反向传播算法让多层感知机，或者说传统的全连接神经网络有了训练的手段，引发了神经网络的第二次热潮，虽然为期不长，毕竟当时算力和数据都很有限，但是全连接神经网络总算是正式起来了。</p>\n<p>卷积神经网络</p>\n<ol>\n<li>全连接神经网络的2大缺陷<br>传统的BP神经网络在20世纪80年代左右流行，但是很快因为SVM等核方法的诞生而黯然失色。这是因为传统的BP神经网络有几个重大的缺陷。</li>\n</ol>\n<p>首先是原理上的缺陷：BP神经网络仍然是有监督的传统机器学习方法，遵循着以下思路。</p>\n<p>Image</p>\n<p>也就是说，不过是在最后面将SVM或者其他分类器换成神经网络，在大部分情况下其实没有什么优势，甚至增加了问题的复杂度。</p>\n<p>提取的特征虽然是研究者们经过反复实验证明有效的特征，但仍然会一定程度上丢失了图像中的结构信息，从而丢失了一些对旋转扭曲等的不变性。而且要求输入的大小是固定的。为了学习到如偏移等微小的变化，需要有足够多的参数和足够多丰富的样本，最终学习到的权重，很可能在不同的位置处还会有非常相似的权重。</p>\n<p>有人可能会说，直接把图像作为输入而不提取特征行不行？请接着往下看。</p>\n<p>再一个就是结构上的缺陷：参数巨多，丢失空间信息。<br>全连接神经网络从BP算法提出开始，发展于90年代，那时候的计算机属于CPU时代，根本就无法撑起海量参数的计算。</p>\n<p>如果一个隐藏层特征图像大小为100×100，输入层的特征图像大小为100×100，这意味着学习这一层需要100×100×100×100=$10^8$的参数。如果以32位的浮点数进行存储，就需要$4×10^8$的字节的存储量，约等于400MB的参数量。仅仅这样的一个网络层，其模型参数量已经超过了AlexNet网络的参数量，而100×100的特征图像分辨率，已经低于很多任务能够成功解决的下限。除了计算过程中需要存储的海量的参数，还有海量的计算，这些都超过了当时硬件的能力，因此大大限制了网络的大小，尤其是对于一些大的图像输入。</p>\n<ol start=\"2\">\n<li>卷积神经网络的崛起<br>不管是历史局限性也好，还是神经网络有种种毛病，总之80年代后的20年间它不是主流。</li>\n</ol>\n<p>不过在上个世纪90年代研究神经网络的学者们没有停止，经典的诸如LeNet5这样的网络被提出。</p>\n<p>Image</p>\n<p>LeNet5，1999年由深度学习三巨头中LeCun， Bengi的提出，成功用于银行支票上的手写数字识别，最重要的两个概念（局部连接+池化）</p>\n<p>下面这个视频记录了1993年Yann LeCun展示的，用于文本识别的世界上第一个卷积网络，所有人都可以通过当时的视频，亲自深刻感受到，当今经典又伟大的CNN，是如何诞生的。</p>\n<p>为什么是卷积神经网络呢？首先自然是要知道什么是卷积神经网络。</p>\n<p>卷积神经网络的基本网络层<br>卷积神经网络：英文全称：Convolutional Neural Networks、简称：CNN</p>\n<p>CNN 主要包含卷积层、池化层和全连接层</p>\n<p>卷积层：用于对图像进行特征提取操作，其卷积核权重是共享权值的，对应的相关概念还包括步长，填充。<br>池化层：用于降低特征图大小，降低后续操作的计算量和参数量<br>全连接层：最终进行分类输出使用，本质就是多层感知机</p>\n<ol>\n<li>什么是卷积？<br>卷积在工程和数学上有非常多的应用，在信号处理领域中，任意一个线性系统的输出，就是输入信号和系统激励函数的卷积。放到数字图像处理领域，卷积操作一般指图像领域的二维卷积。</li>\n</ol>\n<p>Image</p>\n<p>一个二维卷积的案例如上，在图像上滑动，取与卷积核大小相等的区域，逐像素做乘法然后相加。 例如原始图像大小是5×5，卷积核大小是3×3。首先卷积核与原始图像左上角3×3对应位置的元素相乘求和，得到的数值作为结果矩阵第一行第一列的元素值，然后卷积核向右移动一个单位（即步长stride为1），与原始图像前三行第2、3、4列所对应位置的元素分别相乘并求和，得到的数值作为结果矩阵第一行第二列的元素值，以此类推。</p>\n<p>故卷积就是：一个核矩阵在一个原始矩阵上从上往下、从左往右扫描，每次扫描都得到一个结果，将所有结果组合到一起得到一个新的结果矩阵。 注意这里我们不区分卷积和互相关，它们的区别只在于权重算子是否进行了翻转。之所以不重视，是因为在机器学习中，卷积核是否翻转，并不影响算法学习。</p>\n<p>以下的代码可以帮助理解：</p>\n<pre><code class=\"python\">import torch \nfrom torch import nn\n​\ndef corr2d(X, K):  # X 是输入，K是卷积核\n    h, w = K.shape  # 获取卷积核的大小\n    Y = torch.zeros((X.shape[0] - h + 1, X.shape[1] - w + 1))\n    for i in range(Y.shape[0]):\n        for j in range(Y.shape[1]):\n            Y[i, j] = (X[i: i + h, j: j + w] * K).sum()  # 累加\n    return Y\n​\nX = torch.tensor([[0, 1, 2], [3, 4, 5], [6, 7, 8]]) # 模拟一个输入\nK = torch.tensor([[0, 1], [2, 3]])                  # 模拟一个卷积核\ncorr2d(X, K)\ntensor([[19., 25.],\n        [37., 43.]])</code></pre>\n<p>下图就是上面程序的模拟图 Image</p>\n<ol start=\"2\">\n<li>填充（Padding）<br>使卷积后图像分辨率不变，方便计算特征图尺寸的变化<br>弥补边界信息“丢失”<br>填充（padding）是指在输入高和宽的两侧填充元素（通常是0元素）。下图我们在原输入高和宽的两侧分别添加了值为0的元素，使得输入高和宽从3变成了5，并导致输出高和宽由2增加到4。下图阴影部分为第一个输出元素及其计算所使用的输入和核数组元素：0×0+0×1+0×2+0×3=0。</li>\n</ol>\n<p>Image</p>\n<ol start=\"3\">\n<li>步长（Stride）<br>卷积窗口从输入数组的最左上方开始，按从左往右、从上往下的顺序，依次在输入数组上滑动。我们将每次滑动的行数和列数称为步幅或步长（stride）。</li>\n</ol>\n<p>下图展示了在高上步幅为3、在宽上步幅为2的卷积运算。可以看到，输出第一列第二个元素时，卷积窗口向下滑动了3行，而在输出第一行第二个元素时卷积窗口向右滑动了2列。当卷积窗口在输入上再向右滑动2列时，由于输入元素无法填满窗口，无结果输出。下图阴影部分为输出元素及其计算所使用的输入和核数组元素：0×0+0×1+1×2+2×3=8、0×0+6×1+0×2+0×3=6。</p>\n<p>Image</p>\n<ol start=\"4\">\n<li>池化<br>对图像进行下采样，降低图像分辨率。</li>\n</ol>\n<p>池化层的作用：使特征图变小，简化网络计算复杂度；压缩特征，提取主要特征</p>\n<p>常见的池化操作可以分为：最大池化（Max Pool）、平均池化（Avg Pool），示意图如下：</p>\n<p>Image</p>\n<ol start=\"5\">\n<li>卷积和池化输出尺寸计算<br>假设输入图片的高和宽一致，卷积核的宽和高一致，那么输入图像的尺寸与输出图像的尺寸有如下关系：</li>\n</ol>\n<p>其中，$F_{in}$ 是输入图像、k 是卷积核的大小、p 是图像填充的大小、s 是卷积核的步幅、$F_o$ 是输出、$\\lfloor 6.6 \\rfloor$ 是向下取整的意思，比如结果是 6.6，那么向下取整就是 6</p>\n<p>$$F_{o}=\\left\\lfloor\\frac{F_{\\text {in }}-k+2 p}{s}\\right\\rfloor+1$$</p>\n<p>Image</p>\n<p>除此之外，卷积神经网络还包括许多优化技术，大家可以参考相关资料。</p>\n<ol start=\"6\">\n<li>为什么要用卷积来学习呢？<br>图像都是用方形矩阵来表达的，学习的本质就是要抽象出特征，以边缘检测为例。它就是识别数字图像中亮度变化明显的点，这些点连接起来往往是物体的边缘。</li>\n</ol>\n<p>传统的边缘检测常用的方法包括一阶和二阶导数法，本质上都是利用一个卷积核在原图上进行滑动，只是其中各个位置的系数不同，比如3×3的sobel算子计算x方向的梯度幅度，使用的就是下面的卷积核算子。</p>\n<p>Image</p>\n<p>如果要用sobel算子完成一次完整的边缘检测，就要同时检测x方向和y方向，然后进行融合。这就是两个通道的卷积，先用两个卷积核进行通道内的信息提取，再进行通道间的信息融合。 这就是卷积提取特征的本质，而所有基于卷积神经网络来学习的图像算法，都是通过不断的卷积来进行特征的抽象，直到实现网络的目标。</p>\n<ol start=\"7\">\n<li>卷积神经网络的优势在哪？<br>前面说了全连接神经网络的原理和结构上的缺陷，而这正好是卷积的优势。</li>\n</ol>\n<p>学习原理上的改进。<br>卷积神经网络不再是有监督学习了，不需要从图像中提取特征，而是直接从原始图像数据进行学习，这样可以最大程度的防止信息在还没有进入网络之前就丢失。</p>\n<p>学习方式的改进。<br>前面说了全连接神经网络一层的结果是与上一层的节点全部连接的，100×100的图像，如果隐藏层也是同样大小（100×100个）的神经元，光是一层网络，就已经有 10^8 个参数。要优化和存储这样的参数量，是无法想象的，所以经典的神经网络，基本上隐藏层在一两层左右。而卷积神经网络某一层的结点，只与上一层的一个图像块相连。</p>\n<p>用于产生同一个图像中各个空间位置像素的卷积核是同一个，这就是所谓的权值共享。对于与全连接层同样多的隐藏层，假如每个神经元只和输入10×10的局部patch相连接，且卷积核移动步长为10，则参数为：100×100×10×10，降低了2个数量级。 又能更好的学习，参数又低，卷积神经网络当然是可以成功了。</p>\n<p>以上就是本训练营所有理论知识了，接下来将是项目实战部分，是不是迫不及待想要敲代码了</p>\n<p>– By：有三AI 团队</p>\n<p>聚焦于让大家能够系统性地完成AI各个领域所需的专业知识的学习，实现三人行必有AI，三人行必有我师的愿景。</p>\n",
            "tags": [
                "人工智能"
            ]
        },
        {
            "id": "http://47.97.229.110/2021/01/29/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0_3-day/",
            "url": "http://47.97.229.110/2021/01/29/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0_3-day/",
            "title": "深度学习_3_day",
            "date_published": "2021-01-29T13:39:01.000Z",
            "content_html": "<p>基于人脸的常见表情识别——数据获取与整理<br>项目背景</p>\n<p>数据获取<br>2.1 数据爬取</p>\n<p>数据整理<br>3.1 图片格式统一<br>3.2 数据清洗<br>3.3 提取嘴唇区域</p>\n<p>该 Task 就是本训练营的实战部分了，这一部分我们会讲解如何获取数据集，并对数据集进行整理。</p>\n<p>这个 Task 会涉及到数据集等文件的下载，请运行以下代码下载相关文件，由于需要对下载的文件进行解压，所以速度会比较慢，请耐心等候。（大概需要 8 分钟左右）</p>\n<p>如果你不是第一次运行这个项目，那么就跳过以下代码</p>\n<pre><code class=\"python\">print(&quot;****************下载文件中。。。&quot;)\n!wget http://tianchi-media.oss-cn-beijing.aliyuncs.com/dragonball/DL/other/data/Emotion_Recognition_File.zip\nprint(&quot;****************下载完成。。。&quot;)\nprint(&quot;****************解压文件中。。。&quot;)\n!unzip -q -o ./Emotion_Recognition_File.zip -d Emotion_Recognition_File/\nprint(&quot;****************解压完毕***************&quot;)</code></pre>\n<p>为了帮助大家理解所下载的文件，这里将会做一个简单的说明</p>\n<p>所有下载的文件均在 Emotion_Recognition_File （表情识别的英文名称）文件夹下，以下对各个文件进行说明</p>\n<p>img_type_test：放置了不同后缀名的图片，在 3.1 图片格式统一 将会使用到<br>face_detect_model：放置了人脸检测所需要的模型，在 3.2 数据清洗、3.3 提取嘴唇区域 将会使用到<br>face_det_img：放置了一些包含人脸的图片和不包含人人脸的图片，在 3.2 数据清洗 将会使用到<br>mouth_det_img：放置了一些包含人脸的图片，在 3.3 提取嘴唇区域 将会使用到<br>train_val_data：放置了本训练营为各位读者准备的数据集，将会在下一个 Task 用到<br>test_img：放置了包含 4 种表情的图片各一张，将会在下一个 Task 用到，我们就是使用这个文件夹里的图片来展示我们的成果<br>项目背景<br>对于很多初⼊深度学习计算机视觉领域的朋友来说，当前开源资料⾮常多，但有时候难以适从，其中很多资料都没有包含完整的项⽬流程，⽽只是对某个流程的部分截取，对能⼒的锻炼不够。图像分类是整个计算机视觉领域中最基础的任务，也是最重要的任务之⼀，最适合拿来进⾏学习实践。为了让新⼿们能够⼀次性体验⼀个⼯业级别的图像分类任务的完整流程，本次我们选择带领⼤家完成⼀个对图片中⼈脸进⾏表情识别的任务。</p>\n<p>⼈脸表情识别(facial expression recognition, FER)作为⼈脸识别技术中的⼀个重要组成部分，近年来在⼈机交互、安全、机器⼈制造、⾃动化、医疗、通信和驾驶领域得到了⼴泛的关注，成为学术界和⼯业界的研究热点，是⼈脸属性分析的重点。</p>\n<p>数据获取<br>很多实际项⽬我们不会有现成的数据集，虽然可以通过开源数据集获取，但是我们还是要学会⾃⼰从零开始获取和整理。下⾯讲述如何准备好本次项⽬所需要的数据集，包括以下部分:</p>\n<p>学会使⽤爬⾍爬取图像。<br>对获得的图⽚数据进⾏整理，包括重命名，格式统⼀。<br>利⽤⼈脸检测算法删选出有⽤的样本，利⽤关键点检测算法裁剪出⽤于算法训练的嘴唇区域。<br>2.1 数据爬取<br>由于没有直接对应的开源数据集，或者开源数据集中的数据⽐较少，尤其是对于嘟嘴，⼤笑等类的数据。搜索引擎上有海量数据，所以我们可以从中爬取。下⾯开始讲述具体的步骤，我们的任务是⼀个表情分类任务，因此需要爬取相关图⽚，包括嘟嘴（pout），微笑（smile），⼤笑（openmouth）、无表情（none）等表情。</p>\n<p>当前有很多开源的爬虫项目，即使你不懂爬虫的知识，也能够很容易的爬取互联网的资源，下文整理了一些常见的爬虫项目，可以参考进行学习。 【杂谈】深度学习必备，各路免费爬虫一举拿下</p>\n<p>本项目使用的爬虫项目是：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3Njemhlbmd5YWJpbi9JbWFnZS1Eb3dubG9hZGVy\">https://github.com/sczhengyabin/Image-Downloader</span> ，可以按要求爬取百度、Bing、Google 上的图片，提供了非常人性化的 GUI 方便操作，使用方法如下：</p>\n<p>下载爬虫工具</p>\n<p>图片无法加载时显示的文字<br>使用 python image_downloader_gui.py 调用GUI界面，配置好参数(关键词，路径，爬取数目等)，关键词可以直接在这里输入也可以选择从txt文件中选择。</p>\n<p>可以配置需要爬取的样本数目，这里一次爬了2000张，妥妥的3分钟搞定。</p>\n<p>该项目的 GUI 界面如下，我们尝试爬取“嘟嘴”的相关表情：</p>\n<p>图片无法加载时显示的文字<br>爬取图⽚结果如下：</p>\n<p>图片无法加载时显示的文字<br>⾃此就可以获得数千张图像，然后进⾏第⼆步，数据整理。</p>\n<p>TIPS：读者可以下载 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3Njemhlbmd5YWJpbi9JbWFnZS1Eb3dubG9hZGVy\">https://github.com/sczhengyabin/Image-Downloader</span> 这个项目中的爬虫工具，在自己的电脑尝试一下数据爬取，相信通过操作，会加深你的印象</p>\n<p>数据整理<br>爬取得到的数据是⽐较脏的，需要进⾏整理，主要包括统⼀图⽚后缀和重命名。统⼀后缀格式可以减少以后写数据 API 时的压⼒，也可以测试图⽚是不是可以正常的读取，及时防⽌未知问题的出现，这很重要。</p>\n<p>3.1 图片格式统一<br>以下代码可以实现对图片格式的统一，我们在 img_type_test 文件下放置了几张测试图片，读者可以运行尝试。『读者也可以上传不同格式（如 jpg、jpeg、png 等）的图片到 img_type_test 文件下，然后运行下面的代码，下面的代码读取每种图片，然后将其转为 jpg 格式，同时会将原始的图片删除』</p>\n<pre><code class=\"python\">import os\nimport sys\nimport cv2\nimport numpy as np\n​\n​\ndef listfiles(rootDir):\n    list_dirs = os.walk(rootDir) \n    for root, dirs, files in list_dirs:  # 遍历文件夹下的图片\n        for d in dirs:\n            print((os.path.join(root, d)))\n        for f in files:\n            fileid = f.split(&#39;.&#39;)[0]  # 获得图片的名字，不含后缀\n            filepath = os.path.join(root, f) \n            print(filepath)\n            try:\n                src = cv2.imread(filepath, 1)  # 读取原始图片，数据会加载到内存中\n                print(&quot;src=&quot;, filepath, src.shape)\n                os.remove(filepath) # 移除原来的图片\n                cv2.imwrite(os.path.join(root, fileid + &quot;.jpg&quot;), src)  # 保存经过格式转换的图片\n            except:\n                os.remove(filepath)\n                continue\n​\npath = &quot;./Emotion_Recognition_File/img_type_test/&quot;  # 输入图片路径即可，可以在这个文件夹下放置各种后缀名的图片，代码会将所有图片统一成 jpg 格式\nlistfiles(path)\n./Emotion_Recognition_File/img_type_test/000012.jpg\nsrc= ./Emotion_Recognition_File/img_type_test/000012.jpg (218, 178, 3)\n./Emotion_Recognition_File/img_type_test/000039.jpg\nsrc= ./Emotion_Recognition_File/img_type_test/000039.jpg (218, 178, 3)\n./Emotion_Recognition_File/img_type_test/000063.jpg\nsrc= ./Emotion_Recognition_File/img_type_test/000063.jpg (218, 178, 3)\n./Emotion_Recognition_File/img_type_test/000104.jpg\nsrc= ./Emotion_Recognition_File/img_type_test/000104.jpg (218, 178, 3)\n./Emotion_Recognition_File/img_type_test/000112.jpg\nsrc= ./Emotion_Recognition_File/img_type_test/000112.jpg (218, 178, 3)\n统⼀格式为jpg之后预览如下：\n\n图片无法加载时显示的文字\n3.2 数据清洗\n利⽤搜索引擎爬取得到的图⽚肯定有不符合要求的，数据清洗主要是删除不合适的图⽚，即⾮⼈脸的照⽚。\n\n图片无法加载时显示的文字\n可以采⽤⾁眼观察的⽅式，也可以利⽤程序进⾏筛选，我们调⽤ OpenCV 的⼈脸检测算法进⾏筛选，代码如下：\n\n# coding:utf8\nimport cv2\nimport dlib\nimport numpy as np\nimport sys\nimport os\nimport matplotlib.pyplot as plt\n​\n# 人脸检测的接口，这个是 OpenCV 中自带的\ncascade_path = &#39;./Emotion_Recognition_File/face_detect_model/haarcascade_frontalface_default.xml&#39;\ncascade = cv2.CascadeClassifier(cascade_path)\n​\nimg_path = &quot;./Emotion_Recognition_File/face_det_img/&quot; # 测试图片路径\nimages = os.listdir(img_path)\nfor image in images:\n    im = cv2.imread(os.path.join(img_path, image), 1) # 读取图片\n    rects = cascade.detectMultiScale(im, 1.3, 5)  # 人脸检测函数\n    print(&quot;检测到人脸的数量&quot;, len(rects))\n    if len(rects) == 0:  # len(rects) 是检测人脸的数量，如果没有检测到人脸的话，会显示出图片，适合本地调试使用，在服务器上可能不会显示\n#         cv2.namedWindow(&#39;Result&#39;, 0)\n#         cv2.imshow(&#39;Result&#39;, im)\n#         print(&quot;没有检测到人脸&quot;)\n        pass\n    plt.imshow(im[:, :, ::-1])  # 显示\n    plt.show()\n#         os.remove(os.path.join(img_path, image)) # \n#         k = cv2.waitKey(0)\n#         if k == ord(&#39;q&#39;): # 在英文状态下，按下按键 q 会关闭显示窗口    \n#             break\n#     print()\n# cv2.destroyAllWindows()   </code></pre>\n<p>检测到人脸的数量 1</p>\n<p>检测到人脸的数量 1</p>\n<p>检测到人脸的数量 0</p>\n<p>如果上面的代码运行结果与下面类似，可以重新运行代码</p>\n<p>图片无法加载时显示的文字<br>这个⼈脸检测算法是传统算法，召回率不⾼，因此会有⼀些好样本被删除。经过处理后，可以看到都是⽐较好的样本了，后⾯提取⼈脸关键点也会简单很多。</p>\n<p>图片无法加载时显示的文字<br>如果利⽤⼈脸检测算法仍然⽆法清除⼲净样本，则需要⼿动筛选。当然如果你使⽤多个关键词或者使⽤不同的搜索引擎同样的关键词，或者从视频中提取图⽚，那么爬取回来的图⽚很可能有重复或者⾮常的相似，这样的数据集需要去重。</p>\n<p>3.3 提取嘴唇区域<br>接下来我们要将样本处理成我们真正训练所需要的图像，本任务只对嘴唇部分的表情进⾏识别，所以我们的目标就是获取人脸嘴唇区域的图像，然后进行分类。我们利⽤ Opencv+Dlib 算法提取嘴唇区域， Dlib 算法会得到⾯部的 68 个关键点，我们从中得到嘴唇区域，并适当扩⼤。</p>\n<p>人脸 68 点位置图如下：</p>\n<p>图片无法加载时显示的文字<br>下面的代码可以对图片进行人脸检测，检测到人脸后，会将嘴巴区域分割出来，形成数据集！</p>\n<p>读者可以尝试运行代码，便可以理解这样做的意义</p>\n<pre><code class=\"python\"># coding:utf8\n​\nimport cv2\nimport dlib\nimport numpy as np\nimport sys\nimport os\nimport matplotlib.pyplot as plt\n​\n# 配置 Dlib 关键点检测路径\n# 文件可以从 http://dlib.net/files/ 下载\nPREDICTOR_PATH = &quot;./Emotion_Recognition_File/face_detect_model/shape_predictor_68_face_landmarks.dat&quot;\npredictor = dlib.shape_predictor(PREDICTOR_PATH)\n# 配置人脸检测器路径\ncascade_path = &#39;./Emotion_Recognition_File/face_detect_model/haarcascade_frontalface_default.xml&#39;\ncascade = cv2.CascadeClassifier(cascade_path)\n​\n# 调用 cascade.detectMultiScale 人脸检测器和 Dlib 的关键点检测算法 predictor 获得关键点结果\ndef get_landmarks(im):\n    rects = cascade.detectMultiScale(im, 1.3, 5) # 人脸检测\n    x, y, w, h = rects[0]  # 获取人脸的四个属性值，左上角坐标 x,y 、高宽 w、h\n#     print(x, y, w, h)\n    rect = dlib.rectangle(int(x), int(y), int(x + w), int(y + h)) \n    return np.matrix([[p.x, p.y] for p in predictor(im, rect).parts()])\n​\n​\ndef annotate_landmarks(im, landmarks):\n    im = im.copy()\n    for idx, point in enumerate(landmarks):\n        pos = (point[0, 0], point[0, 1])\n        cv2.putText(im,\n                    str(idx),\n                    pos,\n                    fontFace=cv2.FONT_HERSHEY_SCRIPT_SIMPLEX,\n                    fontScale=0.4,\n                    color=(0, 0, 255))\n        cv2.circle(im, pos, 5, color=(0, 255, 255))\n    return im\n​\n​\ndef getlipfromimage(im, landmarks):\n    xmin = 10000\n    xmax = 0\n    ymin = 10000\n    ymax = 0\n    # 根据最外围的关键点获取包围嘴唇的最小矩形框\n    # 68 个关键点是从\n    # 左耳朵0 -下巴-右耳朵16-左眉毛（17-21）-右眉毛（22-26）-左眼睛（36-41）\n    # 右眼睛（42-47）-鼻子从上到下（27-30）-鼻孔（31-35）\n    # 嘴巴外轮廓（48-59）嘴巴内轮廓（60-67）\n    for i in range(48, 67):\n        x = landmarks[i, 0]\n        y = landmarks[i, 1]\n        if x &lt; xmin:\n            xmin = x\n        if x &gt; xmax:\n            xmax = x\n        if y &lt; ymin:\n            ymin = y\n        if y &gt; ymax:\n            ymax = y\n​\n    print(&quot;xmin=&quot;, xmin)\n    print(&quot;xmax=&quot;, xmax)\n    print(&quot;ymin=&quot;, ymin)\n    print(&quot;ymax=&quot;, ymax)\n​\n    roiwidth = xmax - xmin\n    roiheight = ymax - ymin\n​\n    roi = im[ymin:ymax, xmin:xmax, 0:3]\n​\n    if roiwidth &gt; roiheight:\n        dstlen = 1.5 * roiwidth\n    else:\n        dstlen = 1.5 * roiheight\n​\n    diff_xlen = dstlen - roiwidth\n    diff_ylen = dstlen - roiheight\n​\n    newx = xmin\n    newy = ymin\n​\n    imagerows, imagecols, channel = im.shape\n    if newx &gt;= diff_xlen / 2 and newx + roiwidth + diff_xlen / 2 &lt; imagecols:\n        newx = newx - diff_xlen / 2\n    elif newx &lt; diff_xlen / 2:\n        newx = 0\n    else:\n        newx = imagecols - dstlen\n​\n    if newy &gt;= diff_ylen / 2 and newy + roiheight + diff_ylen / 2 &lt; imagerows:\n        newy = newy - diff_ylen / 2\n    elif newy &lt; diff_ylen / 2:\n        newy = 0\n    else:\n        newy = imagerows - dstlen\n​\n    roi = im[int(newy):int(newy + dstlen), int(newx):int(newx + dstlen), 0:3]\n    return roi\n​\n​\ndef listfiles(rootDir):\n    list_dirs = os.walk(rootDir)\n    for root, dirs, files in list_dirs:\n        for d in dirs:\n            print(os.path.join(root, d))\n        for f in files:\n            fileid = f.split(&#39;.&#39;)[0]\n​\n            filepath = os.path.join(root, f)\n            try:\n                im = cv2.imread(filepath, 1)\n                landmarks = get_landmarks(im)\n                roi = getlipfromimage(im, landmarks)\n                roipath = filepath.replace(&#39;.jpg&#39;, &#39;_mouth.png&#39;)\n#                 cv2.imwrite(roipath, roi)\n                plt.imshow(roi[:, :, ::-1])\n                plt.show()\n            except:\n#                 print(&quot;error&quot;)\n                continue\n​\n​\nlistfiles(&quot;./Emotion_Recognition_File/mouth_det_img/&quot;)\nxmin= 65\nxmax= 114\nymin= 150\nymax= 168\n\nxmin= 67\nxmax= 111\nymin= 151\nymax= 169\n\nxmin= 73\nxmax= 105\nymin= 149\nymax= 161\n\nxmin= 513\nxmax= 652\nymin= 406\nymax= 515\n\nxmin= 211\nxmax= 259\nymin= 287\nymax= 322</code></pre>\n<p>运行上面的代码会显示嘴巴区域图，如果看不到，重新运行一下即可</p>\n<p>（xmin，ymin） （xmax，ymax） 分别代表嘴唇区域在原始图像的位置，即左上角坐标和右下角坐标</p>\n<p>结果如下，⾃此就完成了⾃建数据集操作</p>\n<p>图片无法加载时显示的文字<br>每种表情放置在各自的文件夹下并命名</p>\n<p>图片无法加载时显示的文字<br>上面就是本训练营『数据获取与整理』部分的内容，有了数据，接下来的任务就可以训练我们的表情分类模型吧。</p>\n<p>加油！这也许是你的第一个深度学习模型了。</p>\n<p>– By：有三AI 团队</p>\n<p>聚焦于让大家能够系统性地完成AI各个领域所需的专业知识的学习，实现三人行必有AI，三人行必有我师的愿景。</p>\n<p>​</p>\n",
            "tags": [
                "人工智能",
                "人工智能"
            ]
        },
        {
            "id": "http://47.97.229.110/2021/01/29/python-2-day/",
            "url": "http://47.97.229.110/2021/01/29/python-2-day/",
            "title": "python_2_day",
            "date_published": "2021-01-29T13:39:01.000Z",
            "content_html": "<p>Python入门(中)<br>简介</p>\n<p>列表</p>\n<ol>\n<li>列表的定义</li>\n<li>列表的创建</li>\n<li>向列表中添加元素</li>\n<li>删除列表中的元素</li>\n<li>获取列表中的元素</li>\n<li>列表的常用操作符</li>\n<li>列表的其它方法<br>元组</li>\n<li>创建和访问一个元组</li>\n<li>更新和删除一个元组</li>\n<li>元组相关的操作符</li>\n<li>内置方法</li>\n<li>解压元组</li>\n</ol>\n<p>字符串</p>\n<ol>\n<li>字符串的定义</li>\n<li>字符串的切片与拼接</li>\n<li>字符串的常用内置方法</li>\n<li>字符串格式化</li>\n</ol>\n<p>字典</p>\n<ol>\n<li>可变类型与不可变类型</li>\n<li>字典的定义</li>\n<li>创建和访问字典</li>\n<li>字典的内置方法</li>\n</ol>\n<p>集合</p>\n<ol>\n<li>集合的创建</li>\n<li>访问集合中的值</li>\n<li>集合的内置方法</li>\n<li>集合的转换</li>\n<li>不可变集合</li>\n</ol>\n<p>序列</p>\n<ol>\n<li>针对序列的内置函数</li>\n</ol>\n<p>简介<br>Python 是一种通用编程语言，其在科学计算和机器学习领域具有广泛的应用。如果我们打算利用 Python 来执行机器学习，那么对 Python 有一些基本的了解就是至关重要的。本 Python 入门系列体验就是为这样的初学者精心准备的。</p>\n<p>本实验包括以下内容：</p>\n<p>列表<br>列表的定义<br>列表的创建<br>向列表中添加元素<br>删除列表中的元素<br>获取列表中的元素<br>列表的常用操作符<br>列表的其他方法<br>元组<br>创建和访问一个元组<br>更新和删除一个元组<br>元组相关的操作符<br>内置方法<br>解压元组<br>字符串<br>字符串的定义<br>字符串的切片与拼接<br>字符串的常用内置方法<br>字符串格式化<br>字典<br>可变类型与不可变类型<br>字典的定义<br>创建和访问字典<br>字典的内置方法<br>集合<br>集合的创建<br>访问集合中的值<br>集合的内置方法<br>集合的转换<br>不可变集合<br>序列<br>针对序列的内置函数<br>列表<br>简单数据类型</p>\n<pre><code class=\"python\">整型&lt;class &#39;int&#39;&gt;\n浮点型&lt;class &#39;float&#39;&gt;\n布尔型&lt;class &#39;bool&#39;&gt;\n容器数据类型\n\n列表&lt;class &#39;list&#39;&gt;\n元组&lt;class &#39;tuple&#39;&gt;\n字典&lt;class &#39;dict&#39;&gt;\n集合&lt;class &#39;set&#39;&gt;\n字符串&lt;class &#39;str&#39;&gt;</code></pre>\n<ol>\n<li>列表的定义<br>列表是有序集合，没有固定大小，能够保存任意数量任意类型的 Python 对象，语法为 [元素1, 元素2, …, 元素n]。</li>\n</ol>\n<p>关键点是「中括号 []」和「逗号 ,」<br>中括号 把所有元素绑在一起<br>逗号 将每个元素一一分开<br>2. 列表的创建<br>创建一个普通列表<br>【例子】</p>\n<pre><code class=\"python\">x = [&#39;Monday&#39;, &#39;Tuesday&#39;, &#39;Wednesday&#39;, &#39;Thursday&#39;, &#39;Friday&#39;]\nprint(x, type(x))\n# [&#39;Monday&#39;, &#39;Tuesday&#39;, &#39;Wednesday&#39;, &#39;Thursday&#39;, &#39;Friday&#39;] &lt;class &#39;list&#39;&gt;\n​\nx = [2, 3, 4, 5, 6, 7]\nprint(x, type(x))\n# [2, 3, 4, 5, 6, 7] &lt;class &#39;list&#39;&gt;</code></pre>\n<p>[‘Monday’, ‘Tuesday’, ‘Wednesday’, ‘Thursday’, ‘Friday’] &lt;class ‘list’&gt;<br>[2, 3, 4, 5, 6, 7] &lt;class ‘list’&gt;<br>利用range()创建列表<br>【例子】</p>\n<pre><code class=\"python\">x = list(range(10))\nprint(x, type(x))\n# [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] &lt;class &#39;list&#39;&gt;\n​\nx = list(range(1, 11, 2))\nprint(x, type(x))\n# [1, 3, 5, 7, 9] &lt;class &#39;list&#39;&gt;\n​\nx = list(range(10, 1, -2))\nprint(x, type(x))\n# [10, 8, 6, 4, 2] &lt;class &#39;list&#39;&gt;</code></pre>\n<p>[0, 1, 2, 3, 4, 5, 6, 7, 8, 9] &lt;class ‘list’&gt;<br>[1, 3, 5, 7, 9] &lt;class ‘list’&gt;<br>[10, 8, 6, 4, 2] &lt;class ‘list’&gt;<br>利用推导式创建列表<br>【例子】</p>\n<pre><code class=\"python\">x = [0] * 5\nprint(x, type(x))\n# [0, 0, 0, 0, 0] &lt;class &#39;list&#39;&gt;\n​\nx = [0 for i in range(5)]\nprint(x, type(x))\n# [0, 0, 0, 0, 0] &lt;class &#39;list&#39;&gt;\n​\nx = [i for i in range(10)]\nprint(x, type(x))\n# [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] &lt;class &#39;list&#39;&gt;</code></pre>\n<p>​<br>x = [i for i in range(1, 10, 2)]<br>print(x, type(x))</p>\n<h1 id=\"1-3-5-7-9-lt-class-‘list’-gt\"><a href=\"#1-3-5-7-9-lt-class-‘list’-gt\" class=\"headerlink\" title=\"[1, 3, 5, 7, 9] &lt;class ‘list’&gt;\"></a>[1, 3, 5, 7, 9] &lt;class ‘list’&gt;</h1><p>​<br>x = [i for i in range(10, 1, -2)]<br>print(x, type(x))</p>\n<h1 id=\"10-8-6-4-2-lt-class-‘list’-gt\"><a href=\"#10-8-6-4-2-lt-class-‘list’-gt\" class=\"headerlink\" title=\"[10, 8, 6, 4, 2] &lt;class ‘list’&gt;\"></a>[10, 8, 6, 4, 2] &lt;class ‘list’&gt;</h1><p>​<br>x = [i ** 2 for i in range(1, 10)]<br>print(x, type(x))</p>\n<h1 id=\"1-4-9-16-25-36-49-64-81-lt-class-‘list’-gt\"><a href=\"#1-4-9-16-25-36-49-64-81-lt-class-‘list’-gt\" class=\"headerlink\" title=\"[1, 4, 9, 16, 25, 36, 49, 64, 81] &lt;class ‘list’&gt;\"></a>[1, 4, 9, 16, 25, 36, 49, 64, 81] &lt;class ‘list’&gt;</h1><p>​<br>x = [i for i in range(100) if (i % 2) != 0 and (i % 3) == 0]<br>print(x, type(x))<br>​</p>\n<h1 id=\"3-9-15-21-27-33-39\"><a href=\"#3-9-15-21-27-33-39\" class=\"headerlink\" title=\"[3, 9, 15, 21, 27, 33, 39,\"></a>[3, 9, 15, 21, 27, 33, 39,</h1><p>[0, 0, 0, 0, 0] &lt;class ‘list’&gt;<br>[0, 0, 0, 0, 0] &lt;class ‘list’&gt;<br>[0, 1, 2, 3, 4, 5, 6, 7, 8, 9] &lt;class ‘list’&gt;<br>[1, 3, 5, 7, 9] &lt;class ‘list’&gt;<br>[10, 8, 6, 4, 2] &lt;class ‘list’&gt;<br>[1, 4, 9, 16, 25, 36, 49, 64, 81] &lt;class ‘list’&gt;<br>[3, 9, 15, 21, 27, 33, 39, 45, 51, 57, 63, 69, 75, 81, 87, 93, 99] &lt;class ‘list’&gt;<br>注意：</p>\n<p>由于list的元素可以是任何对象，因此列表中所保存的是对象的指针。即使保存一个简单的[1,2,3]，也有3个指针和3个整数对象。</p>\n<p>x = [a] * 4操作中，只是创建4个指向list的引用，所以一旦a改变，x中4个a也会随之改变。</p>\n<p>【例子】</p>\n<p>x = [[0] * 3] * 4<br>print(x, type(x))</p>\n<h1 id=\"0-0-0-0-0-0-0-0-0-0-0-0-lt-class-‘list’-gt\"><a href=\"#0-0-0-0-0-0-0-0-0-0-0-0-lt-class-‘list’-gt\" class=\"headerlink\" title=\"[[0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]] &lt;class ‘list’&gt;\"></a>[[0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]] &lt;class ‘list’&gt;</h1><p>​<br>x[0][0] = 1<br>print(x, type(x))</p>\n<h1 id=\"1-0-0-1-0-0-1-0-0-1-0-0-lt-class-‘list’-gt\"><a href=\"#1-0-0-1-0-0-1-0-0-1-0-0-lt-class-‘list’-gt\" class=\"headerlink\" title=\"[[1, 0, 0], [1, 0, 0], [1, 0, 0], [1, 0, 0]] &lt;class ‘list’&gt;\"></a>[[1, 0, 0], [1, 0, 0], [1, 0, 0], [1, 0, 0]] &lt;class ‘list’&gt;</h1><p>​<br>a = [0] * 3<br>x = [a] * 4<br>print(x, type(x))</p>\n<h1 id=\"0-0-0-0-0-0-0-0-0-0-0-0-lt-class-‘list’-gt-1\"><a href=\"#0-0-0-0-0-0-0-0-0-0-0-0-lt-class-‘list’-gt-1\" class=\"headerlink\" title=\"[[0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]] &lt;class ‘list’&gt;\"></a>[[0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]] &lt;class ‘list’&gt;</h1><p>​<br>x[0][0] = 1<br>print(x, type(x))</p>\n<h1 id=\"1-0-0-1-0-0-1-0-0-1-0-0-lt-class-‘list’-gt-1\"><a href=\"#1-0-0-1-0-0-1-0-0-1-0-0-lt-class-‘list’-gt-1\" class=\"headerlink\" title=\"[[1, 0, 0], [1, 0, 0], [1, 0, 0], [1, 0, 0]] &lt;class ‘list’&gt;\"></a>[[1, 0, 0], [1, 0, 0], [1, 0, 0], [1, 0, 0]] &lt;class ‘list’&gt;</h1><p>[[0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]] &lt;class ‘list’&gt;<br>[[1, 0, 0], [1, 0, 0], [1, 0, 0], [1, 0, 0]] &lt;class ‘list’&gt;<br>[[0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]] &lt;class ‘list’&gt;<br>[[1, 0, 0], [1, 0, 0], [1, 0, 0], [1, 0, 0]] &lt;class ‘list’&gt;<br>创建一个混合列表<br>【例子】</p>\n<p>mix = [1, ‘lsgo’, 3.14, [1, 2, 3]]<br>print(mix, type(mix))  </p>\n<h1 id=\"1-‘lsgo’-3-14-1-2-3-lt-class-‘list’-gt\"><a href=\"#1-‘lsgo’-3-14-1-2-3-lt-class-‘list’-gt\" class=\"headerlink\" title=\"[1, ‘lsgo’, 3.14, [1, 2, 3]] &lt;class ‘list’&gt;\"></a>[1, ‘lsgo’, 3.14, [1, 2, 3]] &lt;class ‘list’&gt;</h1><p>[1, ‘lsgo’, 3.14, [1, 2, 3]] &lt;class ‘list’&gt;<br>创建一个空列表<br>【例子】</p>\n<p>empty = []<br>print(empty, type(empty))  # [] &lt;class ‘list’&gt;<br>[] &lt;class ‘list’&gt;<br>列表不像元组，列表内容可更改 (mutable)，因此附加 (append, extend)、插入 (insert)、删除 (remove, pop) 这些操作都可以用在它身上。</p>\n<ol start=\"3\">\n<li>向列表中添加元素<br>list.append(obj) 在列表末尾添加新的对象，只接受一个参数，参数可以是任何数据类型，被追加的元素在 list 中保持着原结构类型。<br>【例子】</li>\n</ol>\n<p>x = [‘Monday’, ‘Tuesday’, ‘Wednesday’, ‘Thursday’, ‘Friday’]<br>x.append(‘Thursday’)<br>print(x)  </p>\n<h1 id=\"‘Monday’-‘Tuesday’-‘Wednesday’-‘Thursday’-‘Friday’-‘Thursday’\"><a href=\"#‘Monday’-‘Tuesday’-‘Wednesday’-‘Thursday’-‘Friday’-‘Thursday’\" class=\"headerlink\" title=\"[‘Monday’, ‘Tuesday’, ‘Wednesday’, ‘Thursday’, ‘Friday’, ‘Thursday’]\"></a>[‘Monday’, ‘Tuesday’, ‘Wednesday’, ‘Thursday’, ‘Friday’, ‘Thursday’]</h1><p>​<br>print(len(x))  # 6<br>[‘Monday’, ‘Tuesday’, ‘Wednesday’, ‘Thursday’, ‘Friday’, ‘Thursday’]<br>6<br>此元素如果是一个 list，那么这个 list 将作为一个整体进行追加，注意append()和extend()的区别。</p>\n<p>【例子】</p>\n<p>x = [‘Monday’, ‘Tuesday’, ‘Wednesday’, ‘Thursday’, ‘Friday’]<br>x.append([‘Thursday’, ‘Sunday’])<br>print(x)  </p>\n<h1 id=\"‘Monday’-‘Tuesday’-‘Wednesday’-‘Thursday’-‘Friday’-‘Thursday’-‘Sunday’\"><a href=\"#‘Monday’-‘Tuesday’-‘Wednesday’-‘Thursday’-‘Friday’-‘Thursday’-‘Sunday’\" class=\"headerlink\" title=\"[‘Monday’, ‘Tuesday’, ‘Wednesday’, ‘Thursday’, ‘Friday’, [‘Thursday’, ‘Sunday’]]\"></a>[‘Monday’, ‘Tuesday’, ‘Wednesday’, ‘Thursday’, ‘Friday’, [‘Thursday’, ‘Sunday’]]</h1><p>​<br>print(len(x))  # 6<br>[‘Monday’, ‘Tuesday’, ‘Wednesday’, ‘Thursday’, ‘Friday’, [‘Thursday’, ‘Sunday’]]<br>6<br>list.extend(seq) 在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表）<br>【例子】</p>\n<p>x = [‘Monday’, ‘Tuesday’, ‘Wednesday’, ‘Thursday’, ‘Friday’]<br>x.extend([‘Thursday’, ‘Sunday’])<br>print(x)  </p>\n<h1 id=\"‘Monday’-‘Tuesday’-‘Wednesday’-‘Thursday’-‘Friday’-‘Thursday’-‘Sunday’-1\"><a href=\"#‘Monday’-‘Tuesday’-‘Wednesday’-‘Thursday’-‘Friday’-‘Thursday’-‘Sunday’-1\" class=\"headerlink\" title=\"[‘Monday’, ‘Tuesday’, ‘Wednesday’, ‘Thursday’, ‘Friday’, ‘Thursday’, ‘Sunday’]\"></a>[‘Monday’, ‘Tuesday’, ‘Wednesday’, ‘Thursday’, ‘Friday’, ‘Thursday’, ‘Sunday’]</h1><p>​<br>print(len(x))  # 7<br>[‘Monday’, ‘Tuesday’, ‘Wednesday’, ‘Thursday’, ‘Friday’, ‘Thursday’, ‘Sunday’]<br>7<br>严格来说 append 是追加，把一个东西整体添加在列表后，而 extend 是扩展，把一个东西里的所有元素添加在列表后。</p>\n<p>list.insert(index, obj) 在编号 index 位置插入 obj。<br>【例子】</p>\n<p>x = [‘Monday’, ‘Tuesday’, ‘Wednesday’, ‘Thursday’, ‘Friday’]<br>x.insert(2, ‘Sunday’)<br>print(x)</p>\n<h1 id=\"‘Monday’-‘Tuesday’-‘Sunday’-‘Wednesday’-‘Thursday’-‘Friday’\"><a href=\"#‘Monday’-‘Tuesday’-‘Sunday’-‘Wednesday’-‘Thursday’-‘Friday’\" class=\"headerlink\" title=\"[‘Monday’, ‘Tuesday’, ‘Sunday’, ‘Wednesday’, ‘Thursday’, ‘Friday’]\"></a>[‘Monday’, ‘Tuesday’, ‘Sunday’, ‘Wednesday’, ‘Thursday’, ‘Friday’]</h1><p>​<br>print(len(x))  # 6<br>[‘Monday’, ‘Tuesday’, ‘Sunday’, ‘Wednesday’, ‘Thursday’, ‘Friday’]<br>6<br>4. 删除列表中的元素<br>list.remove(obj) 移除列表中某个值的第一个匹配项<br>【例子】</p>\n<p>x = [‘Monday’, ‘Tuesday’, ‘Wednesday’, ‘Thursday’, ‘Friday’]<br>x.remove(‘Monday’)<br>print(x)  # [‘Tuesday’, ‘Wednesday’, ‘Thursday’, ‘Friday’]<br>[‘Tuesday’, ‘Wednesday’, ‘Thursday’, ‘Friday’]<br>list.pop([index=-1]) 移除列表中的一个元素（默认最后一个元素），并且返回该元素的值<br>【例子】</p>\n<p>x = [‘Monday’, ‘Tuesday’, ‘Wednesday’, ‘Thursday’, ‘Friday’]<br>y = x.pop()<br>print(y)  # Friday<br>​<br>y = x.pop(0)<br>print(y)  # Monday<br>​<br>y = x.pop(-2)<br>print(y)  # Wednesday<br>print(x)  # [‘Tuesday’, ‘Thursday’]<br>Friday<br>Monday<br>Wednesday<br>[‘Tuesday’, ‘Thursday’]<br>remove 和 pop 都可以删除元素，前者是指定具体要删除的元素，后者是指定一个索引。</p>\n<p>del var1[, var2 ……] 删除单个或多个对象。<br>【例子】</p>\n<p>如果知道要删除的元素在列表中的位置，可使用del语句。</p>\n<p>x = [‘Monday’, ‘Tuesday’, ‘Wednesday’, ‘Thursday’, ‘Friday’]<br>del x[0:2]<br>print(x)  # [‘Wednesday’, ‘Thursday’, ‘Friday’]<br>[‘Wednesday’, ‘Thursday’, ‘Friday’]<br>如果你要从列表中删除一个元素，且不再以任何方式使用它，就使用del语句；如果你要在删除元素后还能继续使用它，就使用方法pop()。</p>\n<ol start=\"5\">\n<li>获取列表中的元素<br>通过元素的索引值，从列表获取单个元素，注意，列表索引值是从0开始的。<br>通过将索引指定为-1，可让Python返回最后一个列表元素，索引 -2 返回倒数第二个列表元素，以此类推。<br>【例子】</li>\n</ol>\n<p>x = [‘Monday’, ‘Tuesday’, ‘Wednesday’, [‘Thursday’, ‘Friday’]]<br>print(x[0], type(x[0]))  # Monday &lt;class ‘str’&gt;<br>print(x[-1], type(x[-1]))  # [‘Thursday’, ‘Friday’] &lt;class ‘list’&gt;<br>print(x[-2], type(x[-2]))  # Wednesday &lt;class ‘str’&gt;<br>Monday &lt;class ‘str’&gt;<br>[‘Thursday’, ‘Friday’] &lt;class ‘list’&gt;<br>Wednesday &lt;class ‘str’&gt;<br>切片的通用写法是 start : stop : step</p>\n<p>情况 1 - “start :”<br>以 step 为 1 (默认) 从编号 start 往列表尾部切片。<br>【例子】</p>\n<p>x = [‘Monday’, ‘Tuesday’, ‘Wednesday’, ‘Thursday’, ‘Friday’]<br>print(x[3:])  # [‘Thursday’, ‘Friday’]<br>print(x[-3:])  # [‘Wednesday’, ‘Thursday’, ‘Friday’]<br>[‘Thursday’, ‘Friday’]<br>[‘Wednesday’, ‘Thursday’, ‘Friday’]<br>情况 2 - “: stop”<br>以 step 为 1 (默认) 从列表头部往编号 stop 切片。<br>【例子】</p>\n<p>week = [‘Monday’, ‘Tuesday’, ‘Wednesday’, ‘Thursday’, ‘Friday’]<br>print(week[:3])  # [‘Monday’, ‘Tuesday’, ‘Wednesday’]<br>print(week[:-3])  # [‘Monday’, ‘Tuesday’]<br>[‘Monday’, ‘Tuesday’, ‘Wednesday’]<br>[‘Monday’, ‘Tuesday’]<br>情况 3 - “start : stop”<br>以 step 为 1 (默认) 从编号 start 往编号 stop 切片。<br>【例子】</p>\n<p>week = [‘Monday’, ‘Tuesday’, ‘Wednesday’, ‘Thursday’, ‘Friday’]<br>print(week[1:3])  # [‘Tuesday’, ‘Wednesday’]<br>print(week[-3:-1])  # [‘Wednesday’, ‘Thursday’]<br>[‘Tuesday’, ‘Wednesday’]<br>[‘Wednesday’, ‘Thursday’]<br>情况 4 - “start : stop : step”<br>以具体的 step 从编号 start 往编号 stop 切片。注意最后把 step 设为 -1，相当于将列表反向排列。<br>【例子】</p>\n<p>week = [‘Monday’, ‘Tuesday’, ‘Wednesday’, ‘Thursday’, ‘Friday’]<br>print(week[1:4:2])  # [‘Tuesday’, ‘Thursday’]<br>print(week[:4:2])  # [‘Monday’, ‘Wednesday’]<br>print(week[1::2])  # [‘Tuesday’, ‘Thursday’]<br>print(week[::-1])  </p>\n<h1 id=\"‘Friday’-‘Thursday’-‘Wednesday’-‘Tuesday’-‘Monday’\"><a href=\"#‘Friday’-‘Thursday’-‘Wednesday’-‘Tuesday’-‘Monday’\" class=\"headerlink\" title=\"[‘Friday’, ‘Thursday’, ‘Wednesday’, ‘Tuesday’, ‘Monday’]\"></a>[‘Friday’, ‘Thursday’, ‘Wednesday’, ‘Tuesday’, ‘Monday’]</h1><p>[‘Tuesday’, ‘Thursday’]<br>[‘Monday’, ‘Wednesday’]<br>[‘Tuesday’, ‘Thursday’]<br>[‘Friday’, ‘Thursday’, ‘Wednesday’, ‘Tuesday’, ‘Monday’]<br>情况 5 - “ : “<br>复制列表中的所有元素（浅拷贝）。<br>【例子】</p>\n<p>eek = [‘Monday’, ‘Tuesday’, ‘Wednesday’, ‘Thursday’, ‘Friday’]<br>print(week[:])  </p>\n<h1 id=\"‘Monday’-‘Tuesday’-‘Wednesday’-‘Thursday’-‘Friday’\"><a href=\"#‘Monday’-‘Tuesday’-‘Wednesday’-‘Thursday’-‘Friday’\" class=\"headerlink\" title=\"[‘Monday’, ‘Tuesday’, ‘Wednesday’, ‘Thursday’, ‘Friday’]\"></a>[‘Monday’, ‘Tuesday’, ‘Wednesday’, ‘Thursday’, ‘Friday’]</h1><p>[‘Monday’, ‘Tuesday’, ‘Wednesday’, ‘Thursday’, ‘Friday’]<br>【例子】浅拷贝与深拷贝</p>\n<p>list1 = [123, 456, 789, 213]<br>list2 = list1<br>list3 = list1[:]<br>​<br>print(list2)  # [123, 456, 789, 213]<br>print(list3)  # [123, 456, 789, 213]<br>list1.sort()<br>print(list2)  # [123, 213, 456, 789]<br>print(list3)  # [123, 456, 789, 213]<br>​<br>list1 = [[123, 456], [789, 213]]<br>list2 = list1<br>list3 = list1[:]<br>print(list2)  # [[123, 456], [789, 213]]<br>print(list3)  # [[123, 456], [789, 213]]<br>list1[0][0] = 111<br>print(list2)  # [[111, 456], [789, 213]]<br>print(list3)  # [[111, 456], [789, 213]]<br>[123, 456, 789, 213]<br>[123, 456, 789, 213]<br>[123, 213, 456, 789]<br>[123, 456, 789, 213]<br>[[123, 456], [789, 213]]<br>[[123, 456], [789, 213]]<br>[[111, 456], [789, 213]]<br>[[111, 456], [789, 213]]<br>6. 列表的常用操作符<br>等号操作符：==<br>连接操作符 +<br>重复操作符 *<br>成员关系操作符 in、not in<br>「等号 ==」，只有成员、成员位置都相同时才返回True。</p>\n<p>列表拼接有两种方式，用「加号 +」和「乘号 *」，前者首尾拼接，后者复制拼接。</p>\n<p>【例子】</p>\n<pre><code class=\"python\">list1 = [123, 456]\nlist2 = [456, 123]\nlist3 = [123, 456]\n​\nprint(list1 == list2)  # False\nprint(list1 == list3)  # True\n​\nlist4 = list1 + list2  # extend()\nprint(list4)  # [123, 456, 456, 123]\n​\nlist5 = list3 * 3\nprint(list5)  # [123, 456, 123, 456, 123, 456]\n​\nlist3 *= 3\nprint(list3)  # [123, 456, 123, 456, 123, 456]\n​\nprint(123 in list3)  # True\nprint(456 not in list3)  # False</code></pre>\n<p>False<br>True<br>[123, 456, 456, 123]<br>[123, 456, 123, 456, 123, 456]<br>[123, 456, 123, 456, 123, 456]<br>True<br>False<br>前面三种方法（append, extend, insert）可对列表增加元素，它们没有返回值，是直接修改了原数据对象。 而将两个list相加，需要创建新的 list 对象，从而需要消耗额外的内存，特别是当 list 较大时，尽量不要使用 “+” 来添加list。</p>\n<ol start=\"7\">\n<li>列表的其它方法<br>list.count(obj) 统计某个元素在列表中出现的次数</li>\n</ol>\n<p>【例子】</p>\n<pre><code class=\"python\">list1 = [123, 456] * 3\nprint(list1)  # [123, 456, 123, 456, 123, 456]\nnum = list1.count(123)\nprint(num)  # 3\n[123, 456, 123, 456, 123, 456]\n3\nlist.index(x[, start[, end]]) 从列表中找出某个值第一个匹配项的索引位置</code></pre>\n<p>【例子】</p>\n<p>list1 = [123, 456] * 5<br>print(list1.index(123))  # 0<br>print(list1.index(123, 1))  # 2<br>print(list1.index(123, 3, 7))  # 4<br>0<br>2<br>4<br>list.reverse() 反向列表中元素</p>\n<p>【例子】</p>\n<pre><code class=\"python\">x = [123, 456, 789]\nx.reverse()\nprint(x)  # [789, 456, 123]\n[789, 456, 123]\nlist.sort(key=None, reverse=False) 对原列表进行排序。</code></pre>\n<p>key – 主要是用来进行比较的元素，只有一个参数，具体的函数的参数就是取自于可迭代对象中，指定可迭代对象中的一个元素来进行排序。<br>reverse – 排序规则，reverse = True 降序， reverse = False 升序（默认）。<br>该方法没有返回值，但是会对列表的对象进行排序。<br>【例子】</p>\n<pre><code class=\"python\">x = [123, 456, 789, 213]\nx.sort()\nprint(x)\n# [123, 213, 456, 789]\n​\nx.sort(reverse=True)\nprint(x)\n# [789, 456, 213, 123]\n​\n​\n# 获取列表的第二个元素\ndef takeSecond(elem):\n    return elem[1]\n​\n​\nx = [(2, 2), (3, 4), (4, 1), (1, 3)]\nx.sort(key=takeSecond)\nprint(x)\n# [(4, 1), (2, 2), (1, 3), (3, 4)]\n​\nx.sort(key=lambda a: a[0])\nprint(x)\n# [(1, 3), (2, 2), (3, 4), (4, 1)]</code></pre>\n<p>[123, 213, 456, 789]<br>[789, 456, 213, 123]<br>[(4, 1), (2, 2), (1, 3), (3, 4)]<br>[(1, 3), (2, 2), (3, 4), (4, 1)]<br>元组<br>「元组」定义语法为：(元素1, 元素2, …, 元素n)</p>\n<p>小括号把所有元素绑在一起<br>逗号将每个元素一一分开</p>\n<ol>\n<li>创建和访问一个元组<br>Python 的元组与列表类似，不同之处在于tuple被创建后就不能对其进行修改，类似字符串。<br>元组使用小括号，列表使用方括号。<br>元组与列表类似，也用整数来对它进行索引 (indexing) 和切片 (slicing)。<br>【例子】<pre><code class=\"python\">t1 = (1, 10.31, &#39;python&#39;)\nt2 = 1, 10.31, &#39;python&#39;\nprint(t1, type(t1))\n# (1, 10.31, &#39;python&#39;) &lt;class &#39;tuple&#39;&gt;\n​\nprint(t2, type(t2))\n# (1, 10.31, &#39;python&#39;) &lt;class &#39;tuple&#39;&gt;\n​\ntuple1 = (1, 2, 3, 4, 5, 6, 7, 8)\nprint(tuple1[1])  # 2\nprint(tuple1[5:])  # (6, 7, 8)\nprint(tuple1[:5])  # (1, 2, 3, 4, 5)\ntuple2 = tuple1[:]\nprint(tuple2)  # (1, 2, 3, 4, 5, 6, 7, 8)</code></pre>\n(1, 10.31, ‘python’) &lt;class ‘tuple’&gt;<br>(1, 10.31, ‘python’) &lt;class ‘tuple’&gt;<br>2<br>(6, 7, 8)<br>(1, 2, 3, 4, 5)<br>(1, 2, 3, 4, 5, 6, 7, 8)<br>创建元组可以用小括号 ()，也可以什么都不用，为了可读性，建议还是用 ()。<br>元组中只包含一个元素时，需要在元素后面添加逗号，否则括号会被当作运算符使用。<br>【例子】<pre><code class=\"python\">x = (1)\nprint(type(x))  # &lt;class &#39;int&#39;&gt;\nx = 2, 3, 4, 5\nprint(type(x))  # &lt;class &#39;tuple&#39;&gt;\nx = []\nprint(type(x))  # &lt;class &#39;list&#39;&gt;\nx = ()\nprint(type(x))  # &lt;class &#39;tuple&#39;&gt;\nx = (1,)\nprint(type(x))  # &lt;class &#39;tuple&#39;&gt;</code></pre>\n&lt;class ‘int’&gt;<br>&lt;class ‘tuple’&gt;<br>&lt;class ‘list’&gt;<br>&lt;class ‘tuple’&gt;<br>&lt;class ‘tuple’&gt;<br>【例子】<pre><code class=\"python\">print(8 * (8))  # 64\nprint(8 * (8,))  # (8, 8, 8, 8, 8, 8, 8, 8)\n64\n(8, 8, 8, 8, 8, 8, 8, 8)\n【例子】创建二维元组。\n</code></pre>\n</li>\n</ol>\n<p>x = (1, 10.31, ‘python’), (‘data’, 11)<br>print(x)</p>\n<h1 id=\"1-10-31-‘python’-‘data’-11\"><a href=\"#1-10-31-‘python’-‘data’-11\" class=\"headerlink\" title=\"((1, 10.31, ‘python’), (‘data’, 11))\"></a>((1, 10.31, ‘python’), (‘data’, 11))</h1><p>​<br>print(x[0])</p>\n<h1 id=\"1-10-31-‘python’\"><a href=\"#1-10-31-‘python’\" class=\"headerlink\" title=\"(1, 10.31, ‘python’)\"></a>(1, 10.31, ‘python’)</h1><p>print(x[0][0], x[0][1], x[0][2])</p>\n<h1 id=\"1-10-31-python\"><a href=\"#1-10-31-python\" class=\"headerlink\" title=\"1 10.31 python\"></a>1 10.31 python</h1><p>​<br>print(x[0][0:2])</p>\n<h1 id=\"1-10-31\"><a href=\"#1-10-31\" class=\"headerlink\" title=\"(1, 10.31)\"></a>(1, 10.31)</h1><pre><code>((1, 10.31, &#39;python&#39;), (&#39;data&#39;, 11))\n(1, 10.31, &#39;python&#39;)\n1 10.31 python\n(1, 10.31)\n2. 更新和删除一个元组\n【例子】\n``` python\nweek = (&#39;Monday&#39;, &#39;Tuesday&#39;, &#39;Thursday&#39;, &#39;Friday&#39;)\nweek = week[:2] + (&#39;Wednesday&#39;,) + week[2:]\nprint(week)  # (&#39;Monday&#39;, &#39;Tuesday&#39;, &#39;Wednesday&#39;, &#39;Thursday&#39;, &#39;Friday&#39;)\n(&#39;Monday&#39;, &#39;Tuesday&#39;, &#39;Wednesday&#39;, &#39;Thursday&#39;, &#39;Friday&#39;)\n【例子】元组有不可更改 (immutable) 的性质，因此不能直接给元组的元素赋值，但是只要元组中的元素可更改 (mutable)，那么我们可以直接更改其元素，注意这跟赋值其元素不同。\n\nt1 = (1, 2, 3, [4, 5, 6])\nprint(t1)  # (1, 2, 3, [4, 5, 6])\n​\nt1[3][0] = 9\nprint(t1)  # (1, 2, 3, [9, 5, 6])</code></pre>\n<p>(1, 2, 3, [4, 5, 6])<br>(1, 2, 3, [9, 5, 6])<br>3. 元组相关的操作符<br>等号操作符：==<br>连接操作符 +<br>重复操作符 *<br>成员关系操作符 in、not in<br>「等号 ==」，只有成员、成员位置都相同时才返回True。</p>\n<p>元组拼接有两种方式，用「加号 +」和「乘号 *」，前者首尾拼接，后者复制拼接。</p>\n<p>【例子】</p>\n<pre><code class=\"python\">t1 = (123, 456)\nt2 = (456, 123)\nt3 = (123, 456)\n​\nprint(t1 == t2)  # False\nprint(t1 == t3)  # True\n​\nt4 = t1 + t2\nprint(t4)  # (123, 456, 456, 123)\n​\nt5 = t3 * 3\nprint(t5)  # (123, 456, 123, 456, 123, 456)\n​\nt3 *= 3\nprint(t3)  # (123, 456, 123, 456, 123, 456)\n​\nprint(123 in t3)  # True\nprint(456 not in t3)  # False</code></pre>\n<p>False<br>True<br>(123, 456, 456, 123)<br>(123, 456, 123, 456, 123, 456)<br>(123, 456, 123, 456, 123, 456)<br>True<br>False<br>4. 内置方法<br>元组大小和内容都不可更改，因此只有 count 和 index 两种方法。</p>\n<p>【例子】</p>\n<pre><code class=\"python\">t = (1, 10.31, &#39;python&#39;)\nprint(t.count(&#39;python&#39;))  # 1\nprint(t.index(10.31))  # \\1</code></pre>\n<p>1<br>1<br>count(‘python’) 是记录在元组 t 中该元素出现几次，显然是 1 次<br>index(10.31) 是找到该元素在元组 t 的索引，显然是 1<br>5. 解压元组<br>【例子】解压（unpack）一维元组（有几个元素左边括号定义几个变量）</p>\n<p>t = (1, 10.31, ‘python’)<br>(a, b, c) = t<br>print(a, b, c)</p>\n<h1 id=\"1-10-31-python-1\"><a href=\"#1-10-31-python-1\" class=\"headerlink\" title=\"1 10.31 python\"></a>1 10.31 python</h1><p>1 10.31 python<br>【例子】解压二维元组（按照元组里的元组结构来定义变量）</p>\n<pre><code class=\"python\">t = (1, 10.31, (&#39;OK&#39;, &#39;python&#39;))\n(a, b, (c, d)) = t\nprint(a, b, c, d)\n# 1 10.31 OK python</code></pre>\n<p>1 10.31 OK python<br>【例子】如果你只想要元组其中几个元素，用通配符「*」，英文叫 wildcard，在计算机语言中代表一个或多个元素。下例就是把多个元素丢给了 rest 变量。</p>\n<pre><code class=\"python\">t = 1, 2, 3, 4, 5\na, b, *rest, c = t\nprint(a, b, c)  # 1 2 5\nprint(rest)  # [3, 4]</code></pre>\n<p>1 2 5<br>[3, 4]<br>【例子】如果你根本不在乎 rest 变量，那么就用通配符「*」加上下划线「_」。</p>\n<pre><code class=\"python\">t = 1, 2, 3, 4, 5\na, b, *_ = t\nprint(a, b)  # 1 2</code></pre>\n<p>1 2<br>字符串</p>\n<ol>\n<li>字符串的定义<br>Python 中字符串被定义为引号之间的字符集合。<br>Python 支持使用成对的 单引号 或 双引号。<br>【例子】<pre><code class=\"python\">t1 = &#39;i love Python!&#39;\nprint(t1, type(t1))\n# i love Python! &lt;class &#39;str&#39;&gt;\n​\nt2 = &quot;I love Python!&quot;\nprint(t2, type(t2))\n# I love Python! &lt;class &#39;str&#39;&gt;\n​\nprint(5 + 8)  # 13\nprint(&#39;5&#39; + &#39;8&#39;)  # 58</code></pre>\ni love Python! &lt;class ‘str’&gt;<br>I love Python! &lt;class ‘str’&gt;<br>13<br>58<br>Python 的常用转义字符<br>转义字符    描述<br>\\    反斜杠符号<br>&#39;    单引号<br>&quot;    双引号<br>\\n    换行<br>\\t    横向制表符(TAB)<br>\\r    回车<br>【例子】如果字符串中需要出现单引号或双引号，可以使用转义符号\\对字符串中的符号进行转义。<pre><code class=\"python\">print(&#39;let\\&#39;s go&#39;)  # let&#39;s go\nprint(&quot;let&#39;s go&quot;)  # let&#39;s go\nprint(&#39;C:\\\\now&#39;)  # C:\\now\nprint(&quot;C:\\\\Program Files\\\\Intel\\\\Wifi\\\\Help&quot;)\n# C:\\Program Files\\Intel\\Wifi\\Help</code></pre>\nlet’s go<br>let’s go<br>C:\\now<br>C:\\Program Files\\Intel\\Wifi\\Help<br>【例子】原始字符串只需要在字符串前边加一个英文字母 r 即可。<pre><code class=\"python\">print(r&#39;C:\\Program Files\\Intel\\Wifi\\Help&#39;)  \n# C:\\Program Files\\Intel\\Wifi\\Help</code></pre>\nC:\\Program Files\\Intel\\Wifi\\Help<br>【例子】三引号允许一个字符串跨多行，字符串中可以包含换行符、制表符以及其他特殊字符。<pre><code class=\"python\">para_str = &quot;&quot;&quot;这是一个多行字符串的实例\n多行字符串可以使用制表符\nTAB ( \\t )。\n也可以使用换行符 [ \\n ]。\n&quot;&quot;&quot;\nprint(para_str)\n# 这是一个多行字符串的实例\n# 多行字符串可以使用制表符\n# TAB (    )。\n# 也可以使用换行符 [\n#  ]。\n​\npara_str = &#39;&#39;&#39;这是一个多行字符串的实例\n多行字符串可以使用制表符\nTAB ( \\t )。\n也可以使用换行符 [ \\n ]。\n&#39;&#39;&#39;\nprint(para_str)\n# 这是一个多行字符串的实例\n# 多行字符串可以使用制表符\n# TAB (      )。\n# 也可以使用换行符 [ \n#  ]。</code></pre>\n这是一个多行字符串的实例<br>多行字符串可以使用制表符<br>TAB (      )。<br>也可以使用换行符 [<br>]。</li>\n</ol>\n<p>这是一个多行字符串的实例<br>多行字符串可以使用制表符<br>TAB (      )。<br>也可以使用换行符 [<br> ]。</p>\n<ol start=\"2\">\n<li>字符串的切片与拼接<br>类似于元组具有不可修改性<br>从 0 开始 (和 Java 一样)<br>切片通常写成 start:end 这种形式，包括「start 索引」对应的元素，不包括「end索引」对应的元素。<br>索引值可正可负，正索引从 0 开始，从左往右；负索引从 -1 开始，从右往左。使用负数索引时，会从最后一个元素开始计数。最后一个元素的位置编号是 -1。<br>【例子】<pre><code class=\"python\">str1 = &#39;I Love LsgoGroup&#39;\nprint(str1[:6])  # I Love\nprint(str1[5])  # e\nprint(str1[:6] + &quot; 插入的字符串 &quot; + str1[6:])  \n# I Love 插入的字符串  LsgoGroup\n​\ns = &#39;Python&#39;\nprint(s)  # Python\nprint(s[2:4])  # th\nprint(s[-5:-2])  # yth\nprint(s[2])  # t\nprint(s[-1])  # n</code></pre>\nI Love<br>e<br>I Love 插入的字符串  LsgoGroup<br>Python<br>th<br>yth<br>t<br>n</li>\n<li>字符串的常用内置方法<br>capitalize() 将字符串的第一个字符转换为大写。<br>【例子】<pre><code class=\"python\">str2 = &#39;xiaoxie&#39;\nprint(str2.capitalize())  # Xiaoxie</code></pre>\nXiaoxie<br>lower() 转换字符串中所有大写字符为小写。<br>upper() 转换字符串中的小写字母为大写。<br>swapcase() 将字符串中大写转换为小写，小写转换为大写。<br>【例子】<pre><code class=\"python\">str2 = &quot;DAXIExiaoxie&quot;\nprint(str2.lower())  # daxiexiaoxie\nprint(str2.upper())  # DAXIEXIAOXIE\nprint(str2.swapcase())  # daxieXIAOXIE</code></pre>\ndaxiexiaoxie<br>DAXIEXIAOXIE<br>daxieXIAOXIE<br>count(str, beg= 0,end=len(string)) 返回str在 string 里面出现的次数，如果beg或者end指定则返回指定范围内str出现的次数。<br>【例子】<pre><code class=\"python\">str2 = &quot;DAXIExiaoxie&quot;\nprint(str2.count(&#39;xi&#39;))  # 2</code></pre>\n2<br>endswith(suffix, beg=0, end=len(string)) 检查字符串是否以指定子字符串 suffix 结束，如果是，返回 True，否则返回 False。如果 beg 和 end 指定值，则在指定范围内检查。<br>startswith(substr, beg=0,end=len(string)) 检查字符串是否以指定子字符串 substr 开头，如果是，返回 True，否则返回 False。如果 beg 和 end 指定值，则在指定范围内检查。<br>【例子】<pre><code class=\"python\">str2 = &quot;DAXIExiaoxie&quot;\nprint(str2.endswith(&#39;ie&#39;))  # True\nprint(str2.endswith(&#39;xi&#39;))  # False\nprint(str2.startswith(&#39;Da&#39;))  # False\nprint(str2.startswith(&#39;DA&#39;))  # True</code></pre>\nTrue<br>False<br>False<br>True<br>find(str, beg=0, end=len(string)) 检测 str 是否包含在字符串中，如果指定范围 beg 和 end，则检查是否包含在指定范围内，如果包含，返回开始的索引值，否则返回 -1。<br>rfind(str, beg=0,end=len(string)) 类似于 find() 函数，不过是从右边开始查找。<br>【例子】<pre><code class=\"python\">str2 = &quot;DAXIExiaoxie&quot;\nprint(str2.find(&#39;xi&#39;))  # 5\nprint(str2.find(&#39;ix&#39;))  # -1\nprint(str2.rfind(&#39;xi&#39;))  # 9</code></pre>\n5</li>\n</ol>\n<p>-1<br>9<br>isnumeric() 如果字符串中只包含数字字符，则返回 True，否则返回 False。<br>【例子】</p>\n<pre><code class=\"python\">str3 = &#39;12345&#39;\nprint(str3.isnumeric())  # True\nstr3 += &#39;a&#39;\nprint(str3.isnumeric())  # False</code></pre>\n<p>True<br>False<br>ljust(width[, fillchar])返回一个原字符串左对齐，并使用fillchar（默认空格）填充至长度width的新字符串。<br>rjust(width[, fillchar])返回一个原字符串右对齐，并使用fillchar（默认空格）填充至长度width的新字符串。<br>【例子】</p>\n<pre><code class=\"python\">str4 = &#39;1101&#39;\nprint(str4.ljust(8, &#39;0&#39;))  # 11010000\nprint(str4.rjust(8, &#39;0&#39;))  # 00001101</code></pre>\n<p>11010000<br>00001101<br>lstrip([chars]) 截掉字符串左边的空格或指定字符。<br>rstrip([chars]) 删除字符串末尾的空格或指定字符。<br>strip([chars]) 在字符串上执行lstrip()和rstrip()。<br>【例子】</p>\n<pre><code class=\"python\">str5 = &#39; I Love LsgoGroup &#39;\nprint(str5.lstrip())  # &#39;I Love LsgoGroup &#39;\nprint(str5.lstrip().strip(&#39;I&#39;))  # &#39; Love LsgoGroup &#39;\nprint(str5.rstrip())  # &#39; I Love LsgoGroup&#39;\nprint(str5.strip())  # &#39;I Love LsgoGroup&#39;\nprint(str5.strip().strip(&#39;p&#39;))  # &#39;I Love LsgoGrou&#39;</code></pre>\n<p>I Love LsgoGroup<br> Love LsgoGroup<br> I Love LsgoGroup<br>I Love LsgoGroup<br>I Love LsgoGrou<br>partition(sub) 找到子字符串sub，把字符串分为一个三元组(pre_sub,sub,fol_sub)，如果字符串中不包含sub则返回(‘原字符串’,’’,’’)。<br>rpartition(sub)类似于partition()方法，不过是从右边开始查找。<br>【例子】</p>\n<p>str5 = ‘ I Love LsgoGroup ‘<br>print(str5.strip().partition(‘o’))  # (‘I L’, ‘o’, ‘ve LsgoGroup’)<br>print(str5.strip().partition(‘m’))  # (‘I Love LsgoGroup’, ‘’, ‘’)<br>print(str5.strip().rpartition(‘o’))  # (‘I Love LsgoGr’, ‘o’, ‘up’)<br>(‘I L’, ‘o’, ‘ve LsgoGroup’)<br>(‘I Love LsgoGroup’, ‘’, ‘’)<br>(‘I Love LsgoGr’, ‘o’, ‘up’)<br>replace(old, new [, max]) 把 将字符串中的old替换成new，如果max指定，则替换不超过max次。<br>【例子】</p>\n<pre><code class=\"python\">str5 = &#39; I Love LsgoGroup &#39;\nprint(str5.strip().replace(&#39;I&#39;, &#39;We&#39;))  # We Love LsgoGroup</code></pre>\n<p>We Love LsgoGroup<br>split(str=””, num) 不带参数默认是以空格为分隔符切片字符串，如果num参数有设置，则仅分隔num个子字符串，返回切片后的子字符串拼接的列表。<br>【例子】</p>\n<p>str5 = ‘ I Love LsgoGroup ‘<br>print(str5.strip().split())  # [‘I’, ‘Love’, ‘LsgoGroup’]<br>print(str5.strip().split(‘o’))  # [‘I L’, ‘ve Lsg’, ‘Gr’, ‘up’]<br>[‘I’, ‘Love’, ‘LsgoGroup’]<br>[‘I L’, ‘ve Lsg’, ‘Gr’, ‘up’]<br>【例子】</p>\n<p>u = “<span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5iYWlkdS5jb20uY24mcXVvdDsv\">www.baidu.com.cn&quot;</span></p>\n<h1 id=\"使用默认分隔符\"><a href=\"#使用默认分隔符\" class=\"headerlink\" title=\"使用默认分隔符\"></a>使用默认分隔符</h1><p>print(u.split())  # [‘<span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5iYWlkdS5jb20uY24mLyMzOTtd\">www.baidu.com.cn&#39;]</span><br>​</p>\n<h1 id=\"以”-”为分隔符\"><a href=\"#以”-”为分隔符\" class=\"headerlink\" title=\"以”.”为分隔符\"></a>以”.”为分隔符</h1><p>print((u.split(‘.’)))  # [‘www’, ‘baidu’, ‘com’, ‘cn’]<br>​</p>\n<h1 id=\"分割0次\"><a href=\"#分割0次\" class=\"headerlink\" title=\"分割0次\"></a>分割0次</h1><p>print((u.split(“.”, 0)))  # [‘<span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5iYWlkdS5jb20uY24mLyMzOTtd\">www.baidu.com.cn&#39;]</span><br>​</p>\n<h1 id=\"分割一次\"><a href=\"#分割一次\" class=\"headerlink\" title=\"分割一次\"></a>分割一次</h1><p>print((u.split(“.”, 1)))  # [‘www’, ‘baidu.com.cn’]<br>​</p>\n<h1 id=\"分割两次\"><a href=\"#分割两次\" class=\"headerlink\" title=\"分割两次\"></a>分割两次</h1><p>print(u.split(“.”, 2))  # [‘www’, ‘baidu’, ‘com.cn’]<br>​</p>\n<h1 id=\"分割两次，并取序列为1的项\"><a href=\"#分割两次，并取序列为1的项\" class=\"headerlink\" title=\"分割两次，并取序列为1的项\"></a>分割两次，并取序列为1的项</h1><p>print((u.split(“.”, 2)[1]))  # baidu<br>​</p>\n<h1 id=\"分割两次，并把分割后的三个部分保存到三个变量\"><a href=\"#分割两次，并把分割后的三个部分保存到三个变量\" class=\"headerlink\" title=\"分割两次，并把分割后的三个部分保存到三个变量\"></a>分割两次，并把分割后的三个部分保存到三个变量</h1><p>u1, u2, u3 = u.split(“.”, 2)<br>print(u1)  # www<br>print(u2)  # baidu<br>print(u3)  # com.cn<br>[‘<span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5iYWlkdS5jb20uY24mLyMzOTtd\">www.baidu.com.cn&#39;]</span><br>[‘www’, ‘baidu’, ‘com’, ‘cn’]<br>[‘<span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5iYWlkdS5jb20uY24mLyMzOTtd\">www.baidu.com.cn&#39;]</span><br>[‘www’, ‘baidu.com.cn’]<br>[‘www’, ‘baidu’, ‘com.cn’]<br>baidu<br>www<br>baidu<br>com.cn<br>【例子】去掉换行符</p>\n<pre><code class=\"python\">c = &#39;&#39;&#39;say\nhello\nbaby&#39;&#39;&#39;\n​\nprint(c)\n# say\n# hello\n# baby\n​\nprint(c.split(&#39;\\n&#39;))  # [&#39;say&#39;, &#39;hello&#39;, &#39;baby&#39;]</code></pre>\n<p>say<br>hello<br>baby<br>[‘say’, ‘hello’, ‘baby’]<br>【例子】</p>\n<pre><code class=\"python\">string = &quot;hello boy&lt;[www.baidu.com]&gt;byebye&quot;\nprint(string.split(&#39;[&#39;)[1].split(&#39;]&#39;)[0])  # www.baidu.com\nprint(string.split(&#39;[&#39;)[1].split(&#39;]&#39;)[0].split(&#39;.&#39;))  # [&#39;www&#39;, &#39;baidu&#39;, &#39;com&#39;]</code></pre>\n<p><span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5iYWlkdS5jb20v\">www.baidu.com</span><br>[‘www’, ‘baidu’, ‘com’]<br>splitlines([keepends]) 按照行(‘\\r’, ‘\\r\\n’, \\n’)分隔，返回一个包含各行作为元素的列表，如果参数keepends为 False，不包含换行符，如果为 True，则保留换行符。<br>【例子】</p>\n<pre><code class=\"python\">str6 = &#39;I \\n Love \\n LsgoGroup&#39;\nprint(str6.splitlines())  # [&#39;I &#39;, &#39; Love &#39;, &#39; LsgoGroup&#39;]\nprint(str6.splitlines(True))  # [&#39;I \\n&#39;, &#39; Love \\n&#39;, &#39; LsgoGroup&#39;]</code></pre>\n<p>[‘I ‘, ‘ Love ‘, ‘ LsgoGroup’]<br>[‘I \\n’, ‘ Love \\n’, ‘ LsgoGroup’]<br>maketrans(intab, outtab) 创建字符映射的转换表，第一个参数是字符串，表示需要转换的字符，第二个参数也是字符串表示转换的目标。<br>translate(table, deletechars=””) 根据参数table给出的表，转换字符串的字符，要过滤掉的字符放到deletechars参数中。<br>【例子】</p>\n<pre><code class=\"python\">str7 = &#39;this is string example....wow!!!&#39;\nintab = &#39;aeiou&#39;\nouttab = &#39;12345&#39;\ntrantab = str7.maketrans(intab, outtab)\nprint(trantab)  # &#123;97: 49, 111: 52, 117: 53, 101: 50, 105: 51&#125;\nprint(str7.translate(trantab))  # th3s 3s str3ng 2x1mpl2....w4w!!!</code></pre>\n<p>{97: 49, 101: 50, 105: 51, 111: 52, 117: 53}<br>th3s 3s str3ng 2x1mpl2….w4w!!!<br>4. 字符串格式化<br>format 格式化函数<br>【例子】</p>\n<pre><code class=\"python\">str8 = &quot;&#123;0&#125; Love &#123;1&#125;&quot;.format(&#39;I&#39;, &#39;Lsgogroup&#39;)  # 位置参数\nprint(str8)  # I Love Lsgogroup\n​\nstr8 = &quot;&#123;a&#125; Love &#123;b&#125;&quot;.format(a=&#39;I&#39;, b=&#39;Lsgogroup&#39;)  # 关键字参数\nprint(str8)  # I Love Lsgogroup\n​\nstr8 = &quot;&#123;0&#125; Love &#123;b&#125;&quot;.format(&#39;I&#39;, b=&#39;Lsgogroup&#39;)  # 位置参数要在关键字参数之前\nprint(str8)  # I Love Lsgogroup\n​\nstr8 = &#39;&#123;0:.2f&#125;&#123;1&#125;&#39;.format(27.658, &#39;GB&#39;)  # 保留小数点后两位\nprint(str8)  # 27.66GB</code></pre>\n<p>I Love Lsgogroup<br>I Love Lsgogroup<br>I Love Lsgogroup<br>27.66GB<br>Python 字符串格式化符号<br>符 号    描述<br>%c    格式化字符及其ASCII码<br>%s    格式化字符串，用str()方法处理对象<br>%r    格式化字符串，用rper()方法处理对象<br>%d    格式化整数<br>%o    格式化无符号八进制数<br>%x    格式化无符号十六进制数<br>%X    格式化无符号十六进制数（大写）<br>%f    格式化浮点数字，可指定小数点后的精度<br>%e    用科学计数法格式化浮点数<br>%E    作用同%e，用科学计数法格式化浮点数<br>%g    根据值的大小决定使用%f或%e<br>%G    作用同%g，根据值的大小决定使用%f或%E<br>【例子】</p>\n<pre><code class=\"python\">print(&#39;%c&#39; % 97)  # a\nprint(&#39;%c %c %c&#39; % (97, 98, 99))  # a b c\nprint(&#39;%d + %d = %d&#39; % (4, 5, 9))  # 4 + 5 = 9\nprint(&quot;我叫 %s 今年 %d 岁!&quot; % (&#39;小明&#39;, 10))  # 我叫 小明 今年 10 岁!\nprint(&#39;%o&#39; % 10)  # 12\nprint(&#39;%x&#39; % 10)  # a\nprint(&#39;%X&#39; % 10)  # A\nprint(&#39;%f&#39; % 27.658)  # 27.658000\nprint(&#39;%e&#39; % 27.658)  # 2.765800e+01\nprint(&#39;%E&#39; % 27.658)  # 2.765800E+01\nprint(&#39;%g&#39; % 27.658)  # 27.658\ntext = &quot;I am %d years old.&quot; % 22\nprint(&quot;I said: %s.&quot; % text)  # I said: I am 22 years old..\nprint(&quot;I said: %r.&quot; % text)  # I said: &#39;I am 22 years old.&#39;</code></pre>\n<p>a<br>a b c<br>4 + 5 = 9<br>我叫 小明 今年 10 岁!<br>12<br>a<br>A<br>27.658000<br>2.765800e+01<br>2.765800E+01<br>27.658<br>I said: I am 22 years old..<br>I said: ‘I am 22 years old.’.<br>格式化操作符辅助指令<br>符号    功能<br>m.n    m 是显示的最小总宽度,n 是小数点后的位数（如果可用的话）</p>\n<ul>\n<li>   用作左对齐</li>\n</ul>\n<ul>\n<li>   在正数前面显示加号( + )<h1 id=\"在八进制数前面显示零-‘0’-，在十六进制前面显示’0x’或者’0X’-取决于用的是’x’还是’X’\"><a href=\"#在八进制数前面显示零-‘0’-，在十六进制前面显示’0x’或者’0X’-取决于用的是’x’还是’X’\" class=\"headerlink\" title=\"在八进制数前面显示零(‘0’)，在十六进制前面显示’0x’或者’0X’(取决于用的是’x’还是’X’)\"></a>在八进制数前面显示零(‘0’)，在十六进制前面显示’0x’或者’0X’(取决于用的是’x’还是’X’)</h1>0    显示的数字前面填充’0’而不是默认的空格<br>【例子】<pre><code class=\"python\">print(&#39;%5.1f&#39; % 27.658)  # &#39; 27.7&#39;\nprint(&#39;%.2e&#39; % 27.658)  # 2.77e+01\nprint(&#39;%10d&#39; % 10)  # &#39;        10&#39;\nprint(&#39;%-10d&#39; % 10)  # &#39;10        &#39;\nprint(&#39;%+d&#39; % 10)  # +10\nprint(&#39;%#o&#39; % 10)  # 0o12\nprint(&#39;%#x&#39; % 108)  # 0x6c\nprint(&#39;%010d&#39; % 5)  # 0000000005</code></pre>\n</li>\n</ul>\n<p> 27.7<br>2.77e+01<br>        10<br>10<br>+10<br>0o12<br>0x6c<br>0000000005<br>字典</p>\n<ol>\n<li>可变类型与不可变类型<br>序列是以连续的整数为索引，与此不同的是，字典以”关键字”为索引，关键字可以是任意不可变类型，通常用字符串或数值。<br>字典是 Python 唯一的一个 映射类型，字符串、元组、列表属于序列类型。<br>那么如何快速判断一个数据类型 X 是不是可变类型的呢？两种方法：</li>\n</ol>\n<p>麻烦方法：用 id(X) 函数，对 X 进行某种操作，比较操作前后的 id，如果不一样，则 X 不可变，如果一样，则 X 可变。<br>便捷方法：用 hash(X)，只要不报错，证明 X 可被哈希，即不可变，反过来不可被哈希，即可变。<br>【例子】</p>\n<pre><code class=\"python\">i = 1\nprint(id(i))  # 140732167000896\ni = i + 2\nprint(id(i))  # 140732167000960\n​\nl = [1, 2]\nprint(id(l))  # 4300825160\nl.append(&#39;Python&#39;)\nprint(id(l))  # 4300825160</code></pre>\n<p>140731832701760<br>140731832701824<br>2131670369800<br>2131670369800<br>整数 i 在加 1 之后的 id 和之前不一样，因此加完之后的这个 i (虽然名字没变)，但不是加之前的那个 i 了，因此整数是不可变类型。<br>列表 l 在附加 ‘Python’ 之后的 id 和之前一样，因此列表是可变类型。<br>【例子】</p>\n<pre><code class=\"python\">print(hash(&#39;Name&#39;))  # 7047218704141848153\n​\nprint(hash((1, 2, &#39;Python&#39;)))  # 1704535747474881831\n​\nprint(hash([1, 2, &#39;Python&#39;]))\n# TypeError: unhashable type: &#39;list&#39;</code></pre>\n<p>​<br>​<br>-6668157630988609386<br>-1857436431894091236</p>\n<hr>\n<p>TypeError                                 Traceback (most recent call last)<br><ipython-input-1-6416367464f8> in <module>()<br>      3 print(hash((1, 2, ‘Python’)))  # 1704535747474881831<br>      4<br>—-&gt; 5 print(hash([1, 2, ‘Python’]))<br>      6 # TypeError: unhashable type: ‘list’</p>\n<p>TypeError: unhashable type: ‘list’<br>print(hash({1, 2, 3}))</p>\n<h1 id=\"TypeError-unhashable-type-‘set’\"><a href=\"#TypeError-unhashable-type-‘set’\" class=\"headerlink\" title=\"TypeError: unhashable type: ‘set’\"></a>TypeError: unhashable type: ‘set’</h1><p>数值、字符和元组 都能被哈希，因此它们是不可变类型。<br>列表、集合、字典不能被哈希，因此它是可变类型。<br>2. 字典的定义<br>字典 是无序的 键:值（key:value）对集合，键必须是互不相同的（在同一个字典之内）。</p>\n<p>dict 内部存放的顺序和 key 放入的顺序是没有关系的。<br>dict 查找和插入的速度极快，不会随着 key 的增加而增加，但是需要占用大量的内存。<br>字典 定义语法为 {元素1, 元素2, …, 元素n}</p>\n<p>其中每一个元素是一个「键值对」– 键:值 (key:value)<br>关键点是「大括号 {}」,「逗号 ,」和「冒号 :」<br>大括号 – 把所有元素绑在一起<br>逗号 – 将每个键值对分开<br>冒号 – 将键和值分开<br>3. 创建和访问字典<br>【例子】</p>\n<pre><code class=\"python\">brand = [&#39;李宁&#39;, &#39;耐克&#39;, &#39;阿迪达斯&#39;]\nslogan = [&#39;一切皆有可能&#39;, &#39;Just do it&#39;, &#39;Impossible is nothing&#39;]\nprint(&#39;耐克的口号是:&#39;, slogan[brand.index(&#39;耐克&#39;)])  \n# 耐克的口号是: Just do it\n​\ndic = &#123;&#39;李宁&#39;: &#39;一切皆有可能&#39;, &#39;耐克&#39;: &#39;Just do it&#39;, &#39;阿迪达斯&#39;: &#39;Impossible is nothing&#39;&#125;\nprint(&#39;耐克的口号是:&#39;, dic[&#39;耐克&#39;])  \n# 耐克的口号是: Just do it</code></pre>\n<p>耐克的口号是: Just do it<br>耐克的口号是: Just do it<br>【例子】通过字符串或数值作为key来创建字典。</p>\n<pre><code class=\"python\">dic1 = &#123;1: &#39;one&#39;, 2: &#39;two&#39;, 3: &#39;three&#39;&#125;\nprint(dic1)  # &#123;1: &#39;one&#39;, 2: &#39;two&#39;, 3: &#39;three&#39;&#125;\nprint(dic1[1])  # one\nprint(dic1[4])  # KeyError: 4\n​\n&#123;1: &#39;one&#39;, 2: &#39;two&#39;, 3: &#39;three&#39;&#125;\none\n---------------------------------------------------------------------------\nKeyError                                  Traceback (most recent call last)\n&lt;ipython-input-2-bb8d02bd63a3&gt; in &lt;module&gt;()\n      2 print(dic1)  # &#123;1: &#39;one&#39;, 2: &#39;two&#39;, 3: &#39;three&#39;&#125;\n      3 print(dic1[1])  # one\n----&gt; 4 print(dic1[4])  # KeyError: 4\n\nKeyError: 4\ndic2 = &#123;&#39;rice&#39;: 35, &#39;wheat&#39;: 101, &#39;corn&#39;: 67&#125;\nprint(dic2)  # &#123;&#39;wheat&#39;: 101, &#39;corn&#39;: 67, &#39;rice&#39;: 35&#125;\nprint(dic2[&#39;rice&#39;])  # 35</code></pre>\n<p>{‘rice’: 35, ‘wheat’: 101, ‘corn’: 67}<br>35<br>注意：如果我们取的键在字典中不存在，会直接报错KeyError。</p>\n<p>【例子】通过元组作为key来创建字典，但一般不这样使用。</p>\n<pre><code class=\"python\">dic = &#123;(1, 2, 3): &quot;Tom&quot;, &quot;Age&quot;: 12, 3: [3, 5, 7]&#125;\nprint(dic)  # &#123;(1, 2, 3): &#39;Tom&#39;, &#39;Age&#39;: 12, 3: [3, 5, 7]&#125;</code></pre>\n<p>print(type(dic))  # &lt;class ‘dict’&gt;<br>{(1, 2, 3): ‘Tom’, ‘Age’: 12, 3: [3, 5, 7]}<br>&lt;class ‘dict’&gt;<br>通过构造函数dict来创建字典。</p>\n<p>dict() 创建一个空的字典。<br>【例子】通过key直接把数据放入字典中，但一个key只能对应一个value，多次对一个key放入 value，后面的值会把前面的值冲掉。</p>\n<pre><code class=\"python\">dic = dict()\ndic[&#39;a&#39;] = 1\ndic[&#39;b&#39;] = 2\ndic[&#39;c&#39;] = 3\n​\nprint(dic)\n# &#123;&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3&#125;\n​\ndic[&#39;a&#39;] = 11\nprint(dic)\n# &#123;&#39;a&#39;: 11, &#39;b&#39;: 2, &#39;c&#39;: 3&#125;\n​\ndic[&#39;d&#39;] = 4\nprint(dic)\n# &#123;&#39;a&#39;: 11, &#39;b&#39;: 2, &#39;c&#39;: 3, &#39;d&#39;: 4&#125;</code></pre>\n<p>{‘a’: 1, ‘b’: 2, ‘c’: 3}<br>{‘a’: 11, ‘b’: 2, ‘c’: 3}<br>{‘a’: 11, ‘b’: 2, ‘c’: 3, ‘d’: 4}<br>dict(mapping) new dictionary initialized from a mapping object’s (key, value) pairs<br>【例子】</p>\n<pre><code class=\"python\">dic1 = dict([(&#39;apple&#39;, 4139), (&#39;peach&#39;, 4127), (&#39;cherry&#39;, 4098)])\nprint(dic1)  # &#123;&#39;cherry&#39;: 4098, &#39;apple&#39;: 4139, &#39;peach&#39;: 4127&#125;\n​\ndic2 = dict(((&#39;apple&#39;, 4139), (&#39;peach&#39;, 4127), (&#39;cherry&#39;, 4098)))\nprint(dic2)  # &#123;&#39;peach&#39;: 4127, &#39;cherry&#39;: 4098, &#39;apple&#39;: 4139&#125;</code></pre>\n<p>{‘apple’: 4139, ‘peach’: 4127, ‘cherry’: 4098}<br>{‘apple’: 4139, ‘peach’: 4127, ‘cherry’: 4098}<br>dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs in the keyword argument list. For example: dict(one=1, two=2)<br>【例子】这种情况下，键只能为字符串类型，并且创建的时候字符串不能加引号，加上就会直接报语法错误。</p>\n<pre><code class=\"python\">dic = dict(name=&#39;Tom&#39;, age=10)\nprint(dic)  # &#123;&#39;name&#39;: &#39;Tom&#39;, &#39;age&#39;: 10&#125;\nprint(type(dic))  # &lt;class &#39;dict&#39;&gt;</code></pre>\n<p>{‘name’: ‘Tom’, ‘age’: 10}<br>&lt;class ‘dict’&gt;<br>4. 字典的内置方法<br>dict.fromkeys(seq[, value]) 用于创建一个新字典，以序列 seq 中元素做字典的键，value 为字典所有键对应的初始值。<br>【例子】</p>\n<pre><code class=\"python\">seq = (&#39;name&#39;, &#39;age&#39;, &#39;sex&#39;)\ndic1 = dict.fromkeys(seq)\nprint(dic1)\n# &#123;&#39;name&#39;: None, &#39;age&#39;: None, &#39;sex&#39;: None&#125;\n​\ndic2 = dict.fromkeys(seq, 10)\nprint(dic2)\n# &#123;&#39;name&#39;: 10, &#39;age&#39;: 10, &#39;sex&#39;: 10&#125;\n​\ndic3 = dict.fromkeys(seq, (&#39;小马&#39;, &#39;8&#39;, &#39;男&#39;))\nprint(dic3)\n# &#123;&#39;name&#39;: (&#39;小马&#39;, &#39;8&#39;, &#39;男&#39;), &#39;age&#39;: (&#39;小马&#39;, &#39;8&#39;, &#39;男&#39;), &#39;sex&#39;: (&#39;小马&#39;, &#39;8&#39;, &#39;男&#39;)&#125;</code></pre>\n<p>{‘name’: None, ‘age’: None, ‘sex’: None}<br>{‘name’: 10, ‘age’: 10, ‘sex’: 10}<br>{‘name’: (‘小马’, ‘8’, ‘男’), ‘age’: (‘小马’, ‘8’, ‘男’), ‘sex’: (‘小马’, ‘8’, ‘男’)}<br>dict.keys()返回一个可迭代对象，可以使用 list() 来转换为列表，列表为字典中的所有键。<br>【例子】</p>\n<pre><code class=\"python\">dic = &#123;&#39;Name&#39;: &#39;lsgogroup&#39;, &#39;Age&#39;: 7&#125;\nprint(dic.keys())  # dict_keys([&#39;Name&#39;, &#39;Age&#39;])\nlst = list(dic.keys())  # 转换为列表\nprint(lst)  # [&#39;Name&#39;, &#39;Age&#39;]\ndict_keys([&#39;Name&#39;, &#39;Age&#39;])</code></pre>\n<p>[‘Name’, ‘Age’]<br>dict.values()返回一个迭代器，可以使用 list() 来转换为列表，列表为字典中的所有值。<br>【例子】</p>\n<pre><code class=\"python\">dic = &#123;&#39;Sex&#39;: &#39;female&#39;, &#39;Age&#39;: 7, &#39;Name&#39;: &#39;Zara&#39;&#125;\nprint(dic.values())\n# dict_values([&#39;female&#39;, 7, &#39;Zara&#39;])\n​\nprint(list(dic.values()))\n# [7, &#39;female&#39;, &#39;Zara&#39;]\ndict_values([&#39;female&#39;, 7, &#39;Zara&#39;])</code></pre>\n<p>[‘female’, 7, ‘Zara’]<br>dict.items()以列表返回可遍历的 (键, 值) 元组数组。<br>【例子】</p>\n<pre><code class=\"python\">dic = &#123;&#39;Name&#39;: &#39;Lsgogroup&#39;, &#39;Age&#39;: 7&#125;\nprint(dic.items())\n# dict_items([(&#39;Name&#39;, &#39;Lsgogroup&#39;), (&#39;Age&#39;, 7)])\n​\nprint(tuple(dic.items()))\n# ((&#39;Name&#39;, &#39;Lsgogroup&#39;), (&#39;Age&#39;, 7))\n​\nprint(list(dic.items()))\n# [(&#39;Name&#39;, &#39;Lsgogroup&#39;), (&#39;Age&#39;, 7)]\ndict_items([(&#39;Name&#39;, &#39;Lsgogroup&#39;), (&#39;Age&#39;, 7)])</code></pre>\n<p>((‘Name’, ‘Lsgogroup’), (‘Age’, 7))<br>[(‘Name’, ‘Lsgogroup’), (‘Age’, 7)]<br>dict.get(key, default=None) 返回指定键的值，如果值不在字典中返回默认值。<br>【例子】</p>\n<pre><code class=\"python\">dic = &#123;&#39;Name&#39;: &#39;Lsgogroup&#39;, &#39;Age&#39;: 27&#125;\nprint(&quot;Age 值为 : %s&quot; % dic.get(&#39;Age&#39;))  # Age 值为 : 27\nprint(&quot;Sex 值为 : %s&quot; % dic.get(&#39;Sex&#39;, &quot;NA&quot;))  # Sex 值为 : NA\nprint(dic)  # &#123;&#39;Name&#39;: &#39;Lsgogroup&#39;, &#39;Age&#39;: 27&#125;</code></pre>\n<p>Age 值为 : 27<br>Sex 值为 : NA<br>{‘Name’: ‘Lsgogroup’, ‘Age’: 27}<br>dict.setdefault(key, default=None)和get()方法 类似, 如果键不存在于字典中，将会添加键并将值设为默认值。<br>【例子】</p>\n<pre><code class=\"python\">dic = &#123;&#39;Name&#39;: &#39;Lsgogroup&#39;, &#39;Age&#39;: 7&#125;\nprint(&quot;Age 键的值为 : %s&quot; % dic.setdefault(&#39;Age&#39;, None))  # Age 键的值为 : 7\nprint(&quot;Sex 键的值为 : %s&quot; % dic.setdefault(&#39;Sex&#39;, None))  # Sex 键的值为 : None\nprint(dic)  \n# &#123;&#39;Age&#39;: 7, &#39;Name&#39;: &#39;Lsgogroup&#39;, &#39;Sex&#39;: None&#125;</code></pre>\n<p>Age 键的值为 : 7<br>Sex 键的值为 : None<br>{‘Name’: ‘Lsgogroup’, ‘Age’: 7, ‘Sex’: None}<br>key in dict in 操作符用于判断键是否存在于字典中，如果键在字典 dict 里返回true，否则返回false。而not in操作符刚好相反，如果键在字典 dict 里返回false，否则返回true。<br>【例子】</p>\n<pre><code class=\"python\">dic = &#123;&#39;Name&#39;: &#39;Lsgogroup&#39;, &#39;Age&#39;: 7&#125;\n​\n# in 检测键 Age 是否存在\nif &#39;Age&#39; in dic:\n    print(&quot;键 Age 存在&quot;)\nelse:\n    print(&quot;键 Age 不存在&quot;)\n​\n# 检测键 Sex 是否存在\nif &#39;Sex&#39; in dic:\n    print(&quot;键 Sex 存在&quot;)\nelse:\n    print(&quot;键 Sex 不存在&quot;)\n​\n# not in 检测键 Age 是否存在\nif &#39;Age&#39; not in dic:\n    print(&quot;键 Age 不存在&quot;)\nelse:\n    print(&quot;键 Age 存在&quot;)\n​\n# 键 Age 存在\n# 键 Sex 不存在\n# 键 Age 存在</code></pre>\n<p>键 Age 存在<br>键 Sex 不存在<br>键 Age 存在<br>dict.pop(key[,default])删除字典给定键 key 所对应的值，返回值为被删除的值。key 值必须给出。若key不存在，则返回 default 值。<br>del dict[key] 删除字典给定键 key 所对应的值。<br>【例子】</p>\n<pre><code class=\"python\">dic1 = &#123;1: &quot;a&quot;, 2: [1, 2]&#125;\nprint(dic1.pop(1), dic1)  # a &#123;2: [1, 2]&#125;\n​\n# 设置默认值，必须添加，否则报错\nprint(dic1.pop(3, &quot;nokey&quot;), dic1)  # nokey &#123;2: [1, 2]&#125;\n​\ndel dic1[2]\nprint(dic1)  # &#123;&#125;</code></pre>\n<p>a {2: [1, 2]}<br>nokey {2: [1, 2]}<br>{}<br>dict.popitem()随机返回并删除字典中的一对键和值，如果字典已经为空，却调用了此方法，就报出KeyError异常。<br>【例子】</p>\n<pre><code class=\"python\">dic1 = &#123;1: &quot;a&quot;, 2: [1, 2]&#125;\nprint(dic1.popitem())  # &#123;2: [1, 2]&#125;\nprint(dic1)  # (1, &#39;a&#39;)</code></pre>\n<p>(2, [1, 2])<br>{1: ‘a’}<br>dict.clear()用于删除字典内所有元素。<br>【例子】</p>\n<pre><code class=\"python\">dic = &#123;&#39;Name&#39;: &#39;Zara&#39;, &#39;Age&#39;: 7&#125;\nprint(&quot;字典长度 : %d&quot; % len(dic))  # 字典长度 : 2\ndic.clear()\nprint(&quot;字典删除后长度 : %d&quot; % len(dic))  \n# 字典删除后长度 : 0</code></pre>\n<p>字典长度 : 2<br>字典删除后长度 : 0<br>dict.copy()返回一个字典的浅复制。<br>【例子】</p>\n<pre><code class=\"python\">dic1 = &#123;&#39;Name&#39;: &#39;Lsgogroup&#39;, &#39;Age&#39;: 7, &#39;Class&#39;: &#39;First&#39;&#125;\ndic2 = dic1.copy()\nprint(&quot;dic2&quot;)  \n# &#123;&#39;Age&#39;: 7, &#39;Name&#39;: &#39;Lsgogroup&#39;, &#39;Class&#39;: &#39;First&#39;&#125;</code></pre>\n<p>dic2<br>【例子】直接赋值和 copy 的区别</p>\n<pre><code class=\"python\">dic1 = &#123;&#39;user&#39;: &#39;lsgogroup&#39;, &#39;num&#39;: [1, 2, 3]&#125;\n​\n# 引用对象\ndic2 = dic1  \n# 浅拷贝父对象（一级目录），子对象（二级目录）不拷贝，还是引用\ndic3 = dic1.copy()  \n​\nprint(id(dic1))  # 148635574728\nprint(id(dic2))  # 148635574728\nprint(id(dic3))  # 148635574344\n​\n# 修改 data 数据\ndic1[&#39;user&#39;] = &#39;root&#39;\ndic1[&#39;num&#39;].remove(1)\n​\n# 输出结果\nprint(dic1)  # &#123;&#39;user&#39;: &#39;root&#39;, &#39;num&#39;: [2, 3]&#125;\nprint(dic2)  # &#123;&#39;user&#39;: &#39;root&#39;, &#39;num&#39;: [2, 3]&#125;\nprint(dic3)  # &#123;&#39;user&#39;: &#39;runoob&#39;, &#39;num&#39;: [2, 3]&#125;</code></pre>\n<p>2131669221448<br>2131669221448<br>2131669225120<br>{‘user’: ‘root’, ‘num’: [2, 3]}<br>{‘user’: ‘root’, ‘num’: [2, 3]}<br>{‘user’: ‘lsgogroup’, ‘num’: [2, 3]}<br>dict.update(dict2)把字典参数 dict2 的 key:value对 更新到字典 dict 里。<br>【例子】</p>\n<pre><code class=\"python\">dic = &#123;&#39;Name&#39;: &#39;Lsgogroup&#39;, &#39;Age&#39;: 7&#125;\ndic2 = &#123;&#39;Sex&#39;: &#39;female&#39;, &#39;Age&#39;: 8&#125;\ndic.update(dic2)\nprint(dic)  \n# &#123;&#39;Sex&#39;: &#39;female&#39;, &#39;Age&#39;: 8, &#39;Name&#39;: &#39;Lsgogroup&#39;&#125;</code></pre>\n<p>{‘Name’: ‘Lsgogroup’, ‘Age’: 8, ‘Sex’: ‘female’}<br>集合<br>Python 中set与dict类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在set中，没有重复的key。</p>\n<p>注意，key为不可变类型，即可哈希的值。</p>\n<p>【例子】</p>\n<pre><code class=\"python\">num = &#123;&#125;\nprint(type(num))  # &lt;class &#39;dict&#39;&gt;\nnum = &#123;1, 2, 3, 4&#125;\nprint(type(num))  # &lt;class &#39;set&#39;&gt;</code></pre>\n<p>&lt;class ‘dict’&gt;<br>&lt;class ‘set’&gt;</p>\n<ol>\n<li>集合的创建<br>先创建对象再加入元素。<br>在创建空集合的时候只能使用s = set()，因为s = {}创建的是空字典。<br>【例子】<pre><code class=\"python\">basket = set()\nbasket.add(&#39;apple&#39;)\nbasket.add(&#39;banana&#39;)\nprint(basket)  # &#123;&#39;banana&#39;, &#39;apple&#39;&#125;</code></pre>\n{‘banana’, ‘apple’}<br>直接把一堆元素用花括号括起来{元素1, 元素2, …, 元素n}。<br>重复元素在set中会被自动被过滤。<br>【例子】<pre><code class=\"python\">basket = &#123;&#39;apple&#39;, &#39;orange&#39;, &#39;apple&#39;, &#39;pear&#39;, &#39;orange&#39;, &#39;banana&#39;&#125;\nprint(basket)  # &#123;&#39;banana&#39;, &#39;apple&#39;, &#39;pear&#39;, &#39;orange&#39;&#125;</code></pre>\n{‘pear’, ‘orange’, ‘banana’, ‘apple’}<br>使用set(value)工厂函数，把列表或元组转换成集合。<br>【例子】<pre><code class=\"python\">a = set(&#39;abracadabra&#39;)\nprint(a)  \n# &#123;&#39;r&#39;, &#39;b&#39;, &#39;d&#39;, &#39;c&#39;, &#39;a&#39;&#125;\n​\nb = set((&quot;Google&quot;, &quot;Lsgogroup&quot;, &quot;Taobao&quot;, &quot;Taobao&quot;))\nprint(b)  \n# &#123;&#39;Taobao&#39;, &#39;Lsgogroup&#39;, &#39;Google&#39;&#125;\n​\nc = set([&quot;Google&quot;, &quot;Lsgogroup&quot;, &quot;Taobao&quot;, &quot;Google&quot;])\nprint(c)  \n# &#123;&#39;Taobao&#39;, &#39;Lsgogroup&#39;, &#39;Google&#39;&#125;</code></pre>\n{‘b’, ‘r’, ‘a’, ‘c’, ‘d’}<br>{‘Taobao’, ‘Google’, ‘Lsgogroup’}<br>{‘Taobao’, ‘Google’, ‘Lsgogroup’}<br>【例子】去掉列表中重复的元素<pre><code class=\"python\">lst = [0, 1, 2, 3, 4, 5, 5, 3, 1]\n​\ntemp = []\nfor item in lst:\n if item not in temp:\n     temp.append(item)\n​\nprint(temp)  # [0, 1, 2, 3, 4, 5]\n​\na = set(lst)\nprint(list(a))  # [0, 1, 2, 3, 4, 5]</code></pre>\n[0, 1, 2, 3, 4, 5]<br>[0, 1, 2, 3, 4, 5]<br>从结果发现集合的两个特点：无序 (unordered) 和唯一 (unique)。</li>\n</ol>\n<p>由于 set 存储的是无序集合，所以我们不可以为集合创建索引或执行切片(slice)操作，也没有键(keys)可用来获取集合中元素的值，但是可以判断一个元素是否在集合中。</p>\n<ol start=\"2\">\n<li>访问集合中的值<br>可以使用len()內建函数得到集合的大小。<br>【例子】<pre><code class=\"python\">s = set([&#39;Google&#39;, &#39;Baidu&#39;, &#39;Taobao&#39;])\nprint(len(s))  # 3\n3\n可以使用for把集合中的数据一个个读取出来。\n【例子】\n``` python\ns = set([&#39;Google&#39;, &#39;Baidu&#39;, &#39;Taobao&#39;])\nfor item in s:\n print(item)\n</code></pre>\n</li>\n</ol>\n<h1 id=\"Baidu\"><a href=\"#Baidu\" class=\"headerlink\" title=\"Baidu\"></a>Baidu</h1><h1 id=\"Google\"><a href=\"#Google\" class=\"headerlink\" title=\"Google\"></a>Google</h1><h1 id=\"Taobao\"><a href=\"#Taobao\" class=\"headerlink\" title=\"Taobao\"></a>Taobao</h1><pre><code>Baidu\nTaobao\nGoogle\n可以通过in或not in判断一个元素是否在集合中已经存在\n【例子】\n``` python\ns = set([&#39;Google&#39;, &#39;Baidu&#39;, &#39;Taobao&#39;])\nprint(&#39;Taobao&#39; in s)  # True\nprint(&#39;Facebook&#39; not in s)  # True</code></pre>\n<p>True<br>True<br>3. 集合的内置方法<br>set.add(elmnt)用于给集合添加元素，如果添加的元素在集合中已存在，则不执行任何操作。<br>【例子】</p>\n<pre><code class=\"python\">fruits = &#123;&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;&#125;\nfruits.add(&quot;orange&quot;)\nprint(fruits)  \n# &#123;&#39;orange&#39;, &#39;cherry&#39;, &#39;banana&#39;, &#39;apple&#39;&#125;\n​\nfruits.add(&quot;apple&quot;)\nprint(fruits)  \n# &#123;&#39;orange&#39;, &#39;cherry&#39;, &#39;banana&#39;, &#39;apple&#39;&#125;</code></pre>\n<p>{‘cherry’, ‘orange’, ‘banana’, ‘apple’}<br>{‘cherry’, ‘orange’, ‘banana’, ‘apple’}<br>set.update(set)用于修改当前集合，可以添加新的元素或集合到当前集合中，如果添加的元素在集合中已存在，则该元素只会出现一次，重复的会忽略。<br>【例子】</p>\n<pre><code class=\"python\">x = &#123;&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;&#125;\ny = &#123;&quot;google&quot;, &quot;baidu&quot;, &quot;apple&quot;&#125;\nx.update(y)\nprint(x)\n# &#123;&#39;cherry&#39;, &#39;banana&#39;, &#39;apple&#39;, &#39;google&#39;, &#39;baidu&#39;&#125;\n​\ny.update([&quot;lsgo&quot;, &quot;dreamtech&quot;])\nprint(y)\n# &#123;&#39;lsgo&#39;, &#39;baidu&#39;, &#39;dreamtech&#39;, &#39;apple&#39;, &#39;google&#39;&#125;</code></pre>\n<p>{‘google’, ‘banana’, ‘cherry’, ‘apple’, ‘baidu’}<br>{‘apple’, ‘dreamtech’, ‘lsgo’, ‘google’, ‘baidu’}<br>set.remove(item) 用于移除集合中的指定元素。如果元素不存在，则会发生错误。<br>【例子】</p>\n<pre><code class=\"python\">fruits = &#123;&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;&#125;\nfruits.remove(&quot;banana&quot;)\nprint(fruits)  # &#123;&#39;apple&#39;, &#39;cherry&#39;&#125;</code></pre>\n<p>{‘cherry’, ‘apple’}<br>set.discard(value) 用于移除指定的集合元素。remove() 方法在移除一个不存在的元素时会发生错误，而 discard() 方法不会。<br>【例子】</p>\n<pre><code class=\"python\">fruits = &#123;&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;&#125;\nfruits.discard(&quot;banana&quot;)\nprint(fruits)  # &#123;&#39;apple&#39;, &#39;cherry&#39;&#125;</code></pre>\n<p>{‘cherry’, ‘apple’}<br>set.pop() 用于随机移除一个元素。<br>【例子】</p>\n<pre><code class=\"python\">fruits = &#123;&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;&#125;\nx = fruits.pop()\nprint(fruits)  # &#123;&#39;cherry&#39;, &#39;apple&#39;&#125;\nprint(x)  # banana</code></pre>\n<p>{‘banana’, ‘apple’}<br>cherry<br>由于 set 是无序和无重复元素的集合，所以两个或多个 set 可以做数学意义上的集合操作。</p>\n<p>set.intersection(set1, set2) 返回两个集合的交集。<br>set1 &amp; set2 返回两个集合的交集。<br>set.intersection_update(set1, set2) 交集，在原始的集合上移除不重叠的元素。<br>【例子】</p>\n<pre><code class=\"python\">a = set(&#39;abracadabra&#39;)\nb = set(&#39;alacazam&#39;)\nprint(a)  # &#123;&#39;r&#39;, &#39;a&#39;, &#39;c&#39;, &#39;b&#39;, &#39;d&#39;&#125;\nprint(b)  # &#123;&#39;c&#39;, &#39;a&#39;, &#39;l&#39;, &#39;m&#39;, &#39;z&#39;&#125;\n​\nc = a.intersection(b)\nprint(c)  # &#123;&#39;a&#39;, &#39;c&#39;&#125;\nprint(a &amp; b)  # &#123;&#39;c&#39;, &#39;a&#39;&#125;\nprint(a)  # &#123;&#39;a&#39;, &#39;r&#39;, &#39;c&#39;, &#39;b&#39;, &#39;d&#39;&#125;\n​\na.intersection_update(b)\nprint(a)  # &#123;&#39;a&#39;, &#39;c&#39;&#125;</code></pre>\n<p>{‘b’, ‘r’, ‘a’, ‘c’, ‘d’}<br>{‘l’, ‘a’, ‘c’, ‘z’, ‘m’}<br>{‘a’, ‘c’}<br>{‘a’, ‘c’}<br>{‘b’, ‘r’, ‘a’, ‘c’, ‘d’}<br>{‘a’, ‘c’}<br>set.union(set1, set2) 返回两个集合的并集。<br>set1 | set2 返回两个集合的并集。<br>【例子】</p>\n<pre><code class=\"python\">a = set(&#39;abracadabra&#39;)\nb = set(&#39;alacazam&#39;)\nprint(a)  # &#123;&#39;r&#39;, &#39;a&#39;, &#39;c&#39;, &#39;b&#39;, &#39;d&#39;&#125;\nprint(b)  # &#123;&#39;c&#39;, &#39;a&#39;, &#39;l&#39;, &#39;m&#39;, &#39;z&#39;&#125;\n​\nprint(a | b)  \n# &#123;&#39;l&#39;, &#39;d&#39;, &#39;m&#39;, &#39;b&#39;, &#39;a&#39;, &#39;r&#39;, &#39;z&#39;, &#39;c&#39;&#125;\n​\nc = a.union(b)\nprint(c)  \n# &#123;&#39;c&#39;, &#39;a&#39;, &#39;d&#39;, &#39;m&#39;, &#39;r&#39;, &#39;b&#39;, &#39;z&#39;, &#39;l&#39;&#125;</code></pre>\n<p>{‘b’, ‘r’, ‘a’, ‘c’, ‘d’}<br>{‘l’, ‘a’, ‘c’, ‘z’, ‘m’}<br>{‘l’, ‘b’, ‘r’, ‘a’, ‘c’, ‘z’, ‘d’, ‘m’}<br>{‘l’, ‘b’, ‘r’, ‘a’, ‘c’, ‘z’, ‘d’, ‘m’}<br>set.difference(set) 返回集合的差集。<br>set1 - set2 返回集合的差集。<br>set.difference_update(set) 集合的差集，直接在原来的集合中移除元素，没有返回值。<br>【例子】</p>\n<pre><code class=\"python\">a = set(&#39;abracadabra&#39;)\nb = set(&#39;alacazam&#39;)\nprint(a)  # &#123;&#39;r&#39;, &#39;a&#39;, &#39;c&#39;, &#39;b&#39;, &#39;d&#39;&#125;\nprint(b)  # &#123;&#39;c&#39;, &#39;a&#39;, &#39;l&#39;, &#39;m&#39;, &#39;z&#39;&#125;\n​\nc = a.difference(b)\nprint(c)  # &#123;&#39;b&#39;, &#39;d&#39;, &#39;r&#39;&#125;\nprint(a - b)  # &#123;&#39;d&#39;, &#39;b&#39;, &#39;r&#39;&#125;\n​\nprint(a)  # &#123;&#39;r&#39;, &#39;d&#39;, &#39;c&#39;, &#39;a&#39;, &#39;b&#39;&#125;\na.difference_update(b)\nprint(a)  # &#123;&#39;d&#39;, &#39;r&#39;, &#39;b&#39;&#125;</code></pre>\n<p>{‘b’, ‘r’, ‘a’, ‘c’, ‘d’}<br>{‘l’, ‘a’, ‘c’, ‘z’, ‘m’}<br>{‘d’, ‘b’, ‘r’}<br>{‘d’, ‘b’, ‘r’}<br>{‘b’, ‘r’, ‘a’, ‘c’, ‘d’}<br>{‘b’, ‘r’, ‘d’}<br>set.symmetric_difference(set)返回集合的异或。<br>set1 ^ set2 返回集合的异或。<br>set.symmetric_difference_update(set)移除当前集合中在另外一个指定集合相同的元素，并将另外一个指定集合中不同的元素插入到当前集合中。<br>【例子】</p>\n<pre><code class=\"python\">a = set(&#39;abracadabra&#39;)\nb = set(&#39;alacazam&#39;)\nprint(a)  # &#123;&#39;r&#39;, &#39;a&#39;, &#39;c&#39;, &#39;b&#39;, &#39;d&#39;&#125;\nprint(b)  # &#123;&#39;c&#39;, &#39;a&#39;, &#39;l&#39;, &#39;m&#39;, &#39;z&#39;&#125;\n​\nc = a.symmetric_difference(b)\nprint(c)  # &#123;&#39;m&#39;, &#39;r&#39;, &#39;l&#39;, &#39;b&#39;, &#39;z&#39;, &#39;d&#39;&#125;\nprint(a ^ b)  # &#123;&#39;m&#39;, &#39;r&#39;, &#39;l&#39;, &#39;b&#39;, &#39;z&#39;, &#39;d&#39;&#125;\n​\nprint(a)  # &#123;&#39;r&#39;, &#39;d&#39;, &#39;c&#39;, &#39;a&#39;, &#39;b&#39;&#125;\na.symmetric_difference_update(b)\nprint(a)  # &#123;&#39;r&#39;, &#39;b&#39;, &#39;m&#39;, &#39;l&#39;, &#39;z&#39;, &#39;d&#39;&#125;</code></pre>\n<p>{‘b’, ‘r’, ‘a’, ‘c’, ‘d’}<br>{‘l’, ‘a’, ‘c’, ‘z’, ‘m’}<br>{‘l’, ‘b’, ‘z’, ‘r’, ‘d’, ‘m’}<br>{‘l’, ‘b’, ‘z’, ‘r’, ‘d’, ‘m’}<br>{‘b’, ‘r’, ‘a’, ‘c’, ‘d’}<br>{‘l’, ‘b’, ‘r’, ‘z’, ‘d’, ‘m’}<br>set.issubset(set)判断集合是不是被其他集合包含，如果是则返回 True，否则返回 False。<br>set1 &lt;= set2 判断集合是不是被其他集合包含，如果是则返回 True，否则返回 False。<br>【例子】</p>\n<pre><code class=\"python\">x = &#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;&#125;\ny = &#123;&quot;f&quot;, &quot;e&quot;, &quot;d&quot;, &quot;c&quot;, &quot;b&quot;, &quot;a&quot;&#125;\nz = x.issubset(y)\nprint(z)  # True\nprint(x &lt;= y)  # True\n​\nx = &#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;&#125;\ny = &#123;&quot;f&quot;, &quot;e&quot;, &quot;d&quot;, &quot;c&quot;, &quot;b&quot;&#125;\nz = x.issubset(y)\nprint(z)  # False\nprint(x &lt;= y)  # False</code></pre>\n<p>True<br>True<br>False<br>False<br>set.issuperset(set)用于判断集合是不是包含其他集合，如果是则返回 True，否则返回 False。<br>set1 &gt;= set2 判断集合是不是包含其他集合，如果是则返回 True，否则返回 False。<br>【例子】</p>\n<pre><code class=\"python\">x = &#123;&quot;f&quot;, &quot;e&quot;, &quot;d&quot;, &quot;c&quot;, &quot;b&quot;, &quot;a&quot;&#125;\ny = &#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;&#125;\nz = x.issuperset(y)\nprint(z)  # True\nprint(x &gt;= y)  # True\n​\nx = &#123;&quot;f&quot;, &quot;e&quot;, &quot;d&quot;, &quot;c&quot;, &quot;b&quot;&#125;\ny = &#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;&#125;\nz = x.issuperset(y)\nprint(z)  # False\nprint(x &gt;= y)  # False</code></pre>\n<p>True<br>True<br>False<br>False<br>set.isdisjoint(set) 用于判断两个集合是不是不相交，如果是返回 True，否则返回 False。<br>【例子】</p>\n<pre><code class=\"python\">x = &#123;&quot;f&quot;, &quot;e&quot;, &quot;d&quot;, &quot;c&quot;, &quot;b&quot;&#125;\ny = &#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;&#125;\nz = x.isdisjoint(y)\nprint(z)  # False\n​\nx = &#123;&quot;f&quot;, &quot;e&quot;, &quot;d&quot;, &quot;m&quot;, &quot;g&quot;&#125;\ny = &#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;&#125;\nz = x.isdisjoint(y)\nprint(z)  # True</code></pre>\n<p>False<br>True<br>4. 集合的转换<br>【例子】</p>\n<pre><code class=\"python\">se = set(range(4))\nli = list(se)\ntu = tuple(se)\n​\nprint(se, type(se))  # &#123;0, 1, 2, 3&#125; &lt;class &#39;set&#39;&gt;\nprint(li, type(li))  # [0, 1, 2, 3] &lt;class &#39;list&#39;&gt;\nprint(tu, type(tu))  # (0, 1, 2, 3) &lt;class &#39;tuple&#39;&gt;</code></pre>\n<p>{0, 1, 2, 3} &lt;class ‘set’&gt;<br>[0, 1, 2, 3] &lt;class ‘list’&gt;<br>(0, 1, 2, 3) &lt;class ‘tuple’&gt;<br>5. 不可变集合<br>Python 提供了不能改变元素的集合的实现版本，即不能增加或删除元素，类型名叫frozenset。需要注意的是frozenset仍然可以进行集合操作，只是不能用带有update的方法。</p>\n<p>frozenset([iterable]) 返回一个冻结的集合，冻结后集合不能再添加或删除任何元素。<br>【例子】</p>\n<pre><code class=\"python\">a = frozenset(range(10))  # 生成一个新的不可变集合\nprint(a)  \n# frozenset(&#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9&#125;)\n​\nb = frozenset(&#39;lsgogroup&#39;)\nprint(b)  \n# frozenset(&#123;&#39;g&#39;, &#39;s&#39;, &#39;p&#39;, &#39;r&#39;, &#39;u&#39;, &#39;o&#39;, &#39;l&#39;&#125;)</code></pre>\n<p>frozenset({0, 1, 2, 3, 4, 5, 6, 7, 8, 9})<br>frozenset({‘l’, ‘g’, ‘r’, ‘u’, ‘o’, ‘s’, ‘p’})</p>\n<p>序列<br>在 Python 中，序列类型包括字符串、列表、元组、集合和字典，这些序列支持一些通用的操作，但比较特殊的是，集合和字典不支持索引、切片、相加和相乘操作。</p>\n<ol>\n<li>针对序列的内置函数<br>list(sub) 把一个可迭代对象转换为列表。<br>【例子】<pre><code class=\"python\">a = list()\nprint(a)  # []\n​\nb = &#39;I Love LsgoGroup&#39;\nb = list(b)\nprint(b)  \n# [&#39;I&#39;, &#39; &#39;, &#39;L&#39;, &#39;o&#39;, &#39;v&#39;, &#39;e&#39;, &#39; &#39;, &#39;L&#39;, &#39;s&#39;, &#39;g&#39;, &#39;o&#39;, &#39;G&#39;, &#39;r&#39;, &#39;o&#39;, &#39;u&#39;, &#39;p&#39;]\n​\nc = (1, 1, 2, 3, 5, 8)\nc = list(c)\nprint(c)  # [1, 1, 2, 3, 5, 8]</code></pre>\n[]<br>[‘I’, ‘ ‘, ‘L’, ‘o’, ‘v’, ‘e’, ‘ ‘, ‘L’, ‘s’, ‘g’, ‘o’, ‘G’, ‘r’, ‘o’, ‘u’, ‘p’]<br>[1, 1, 2, 3, 5, 8]<br>tuple(sub) 把一个可迭代对象转换为元组。<br>【例子】<pre><code class=\"python\">a = tuple()\nprint(a)  # ()\n​\nb = &#39;I Love LsgoGroup&#39;\nb = tuple(b)\nprint(b)  \n# (&#39;I&#39;, &#39; &#39;, &#39;L&#39;, &#39;o&#39;, &#39;v&#39;, &#39;e&#39;, &#39; &#39;, &#39;L&#39;, &#39;s&#39;, &#39;g&#39;, &#39;o&#39;, &#39;G&#39;, &#39;r&#39;, &#39;o&#39;, &#39;u&#39;, &#39;p&#39;)\n​\nc = [1, 1, 2, 3, 5, 8]\nc = tuple(c)\nprint(c)  # (1, 1, 2, 3, 5, 8)</code></pre>\n()<br>(‘I’, ‘ ‘, ‘L’, ‘o’, ‘v’, ‘e’, ‘ ‘, ‘L’, ‘s’, ‘g’, ‘o’, ‘G’, ‘r’, ‘o’, ‘u’, ‘p’)<br>(1, 1, 2, 3, 5, 8)<br>str(obj) 把obj对象转换为字符串<br>【例子】<pre><code>a = 123\na = str(a)\nprint(a)  # 123</code></pre>\n123<br>len(s) 返回对象（字符、列表、元组等）长度或元素个数。<br>s – 对象。<br>【例子】<pre><code class=\"python\">a = list()\nprint(len(a))  # 0\n​\nb = (&#39;I&#39;, &#39; &#39;, &#39;L&#39;, &#39;o&#39;, &#39;v&#39;, &#39;e&#39;, &#39; &#39;, &#39;L&#39;, &#39;s&#39;, &#39;g&#39;, &#39;o&#39;, &#39;G&#39;, &#39;r&#39;, &#39;o&#39;, &#39;u&#39;, &#39;p&#39;)\nprint(len(b))  # 16\n​\nc = &#39;I Love LsgoGroup&#39;\nprint(len(c))  # 16</code></pre>\n0<br>16<br>16<br>max(sub)返回序列或者参数集合中的最大值<br>【例子】<pre><code class=\"python\">print(max(1, 2, 3, 4, 5))  # 5\nprint(max([-8, 99, 3, 7, 83]))  # 99\nprint(max(&#39;IloveLsgoGroup&#39;))  # v</code></pre>\n5<br>99<br>v<br>min(sub)返回序列或参数集合中的最小值<br>【例子】<pre><code class=\"python\">print(min(1, 2, 3, 4, 5))  # 1\nprint(min([-8, 99, 3, 7, 83]))  # -8\nprint(min(&#39;IloveLsgoGroup&#39;))  # G</code></pre>\n1</li>\n</ol>\n<p>-8<br>G<br>sum(iterable[, start=0]) 返回序列iterable与可选参数start的总和。<br>【例子】</p>\n<pre><code class=\"python\">print(sum([1, 3, 5, 7, 9]))  # 25\nprint(sum([1, 3, 5, 7, 9], 10))  # 35\nprint(sum((1, 3, 5, 7, 9)))  # 25\nprint(sum((1, 3, 5, 7, 9), 20))  # 45</code></pre>\n<p>25<br>35<br>25<br>45<br>sorted(iterable, key=None, reverse=False) 对所有可迭代的对象进行排序操作。<br>iterable – 可迭代对象。<br>key – 主要是用来进行比较的元素，只有一个参数，具体的函数的参数就是取自于可迭代对象中，指定可迭代对象中的一个元素来进行排序。<br>reverse – 排序规则，reverse = True 降序 ， reverse = False 升序（默认）。<br>返回重新排序的列表。<br>【例子】</p>\n<pre><code class=\"python\">x = [-8, 99, 3, 7, 83]\nprint(sorted(x))  # [-8, 3, 7, 83, 99]\nprint(sorted(x, reverse=True))  # [99, 83, 7, 3, -8]\n​\nt = (&#123;&quot;age&quot;: 20, &quot;name&quot;: &quot;a&quot;&#125;, &#123;&quot;age&quot;: 25, &quot;name&quot;: &quot;b&quot;&#125;, &#123;&quot;age&quot;: 10, &quot;name&quot;: &quot;c&quot;&#125;)\nx = sorted(t, key=lambda a: a[&quot;age&quot;])\nprint(x)\n# [&#123;&#39;age&#39;: 10, &#39;name&#39;: &#39;c&#39;&#125;, &#123;&#39;age&#39;: 20, &#39;name&#39;: &#39;a&#39;&#125;, &#123;&#39;age&#39;: 25, &#39;name&#39;: &#39;b&#39;&#125;]</code></pre>\n<p>[-8, 3, 7, 83, 99]<br>[99, 83, 7, 3, -8]<br>[{‘age’: 10, ‘name’: ‘c’}, {‘age’: 20, ‘name’: ‘a’}, {‘age’: 25, ‘name’: ‘b’}]<br>reversed(seq) 函数返回一个反转的迭代器。<br>seq – 要转换的序列，可以是 tuple, string, list 或 range。<br>【例子】</p>\n<pre><code class=\"python\">s = &#39;lsgogroup&#39;\nx = reversed(s)\nprint(type(x))  # &lt;class &#39;reversed&#39;&gt;\nprint(x)  # &lt;reversed object at 0x000002507E8EC2C8&gt;\nprint(list(x))\n# [&#39;p&#39;, &#39;u&#39;, &#39;o&#39;, &#39;r&#39;, &#39;g&#39;, &#39;o&#39;, &#39;g&#39;, &#39;s&#39;, &#39;l&#39;]\n​\nt = (&#39;l&#39;, &#39;s&#39;, &#39;g&#39;, &#39;o&#39;, &#39;g&#39;, &#39;r&#39;, &#39;o&#39;, &#39;u&#39;, &#39;p&#39;)\nprint(list(reversed(t)))\n# [&#39;p&#39;, &#39;u&#39;, &#39;o&#39;, &#39;r&#39;, &#39;g&#39;, &#39;o&#39;, &#39;g&#39;, &#39;s&#39;, &#39;l&#39;]\n​\nr = range(5, 9)\nprint(list(reversed(r)))\n# [8, 7, 6, 5]\n​\nx = [-8, 99, 3, 7, 83]\nprint(list(reversed(x)))\n# [83, 7, 3, 99, -8]</code></pre>\n<p>&lt;class ‘reversed’&gt;<br>&lt;reversed object at 0x000001F0517DFD68&gt;<br>[‘p’, ‘u’, ‘o’, ‘r’, ‘g’, ‘o’, ‘g’, ‘s’, ‘l’]<br>[‘p’, ‘u’, ‘o’, ‘r’, ‘g’, ‘o’, ‘g’, ‘s’, ‘l’]<br>[8, 7, 6, 5]<br>[83, 7, 3, 99, -8]<br>enumerate(sequence, [start=0])<br>【例子】用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标，一般用在 for 循环当中。</p>\n<pre><code class=\"python\">seasons = [&#39;Spring&#39;, &#39;Summer&#39;, &#39;Fall&#39;, &#39;Winter&#39;]\na = list(enumerate(seasons))\nprint(a)  \n# [(0, &#39;Spring&#39;), (1, &#39;Summer&#39;), (2, &#39;Fall&#39;), (3, &#39;Winter&#39;)]\n​\nb = list(enumerate(seasons, 1))\nprint(b)  \n# [(1, &#39;Spring&#39;), (2, &#39;Summer&#39;), (3, &#39;Fall&#39;), (4, &#39;Winter&#39;)]\n​\nfor i, element in a:\n    print(&#39;&#123;0&#125;,&#123;1&#125;&#39;.format(i, element))\n# 0,Spring\n# 1,Summer\n# 2,Fall\n# 3,Winter</code></pre>\n<p>[(0, ‘Spring’), (1, ‘Summer’), (2, ‘Fall’), (3, ‘Winter’)]<br>[(1, ‘Spring’), (2, ‘Summer’), (3, ‘Fall’), (4, ‘Winter’)]<br>0,Spring<br>1,Summer<br>2,Fall<br>3,Winter<br>zip(iter1 [,iter2 […]])<br>用于将可迭代的对象作为参数，将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的对象，这样做的好处是节约了不少的内存。<br>我们可以使用 list() 转换来输出列表。<br>如果各个迭代器的元素个数不一致，则返回列表长度与最短的对象相同，利用 * 号操作符，可以将元组解压为列表。<br>【例子】</p>\n<pre><code class=\"python\">a = [1, 2, 3]\nb = [4, 5, 6]\nc = [4, 5, 6, 7, 8]\n​\nzipped = zip(a, b)\nprint(zipped)  # &lt;zip object at 0x000000C5D89EDD88&gt;\nprint(list(zipped))  # [(1, 4), (2, 5), (3, 6)]\nzipped = zip(a, c)\nprint(list(zipped))  # [(1, 4), (2, 5), (3, 6)]\n​\na1, a2 = zip(*zip(a, b))\nprint(list(a1))  # [1, 2, 3]\nprint(list(a2))  # [4, 5, 6]</code></pre>\n<p>&lt;zip object at 0x000001F0517E38C8&gt;<br>[(1, 4), (2, 5), (3, 6)]<br>[(1, 4), (2, 5), (3, 6)]<br>[1, 2, 3]<br>[4, 5, 6]</p>\n",
            "tags": [
                "python"
            ]
        },
        {
            "id": "http://47.97.229.110/2021/01/29/python-3-day/",
            "url": "http://47.97.229.110/2021/01/29/python-3-day/",
            "title": "python_3_day",
            "date_published": "2021-01-29T13:38:29.000Z",
            "content_html": "<p>Python入门(下)<br>简介</p>\n<p>函数</p>\n<ol>\n<li>函数的定义</li>\n<li>函数的调用</li>\n<li>函数文档</li>\n<li>函数参数</li>\n<li>函数的返回值</li>\n<li>变量作用域</li>\n</ol>\n<p>Lambda-表达式</p>\n<ol>\n<li>匿名函数的定义</li>\n<li>匿名函数的应用</li>\n</ol>\n<p>类与对象</p>\n<ol>\n<li>属性和方法组成对象</li>\n<li>self是什么？</li>\n<li>Python的魔法方法</li>\n<li>公有和私有</li>\n<li>继承</li>\n<li>组合</li>\n<li>类、类对象和实例对象</li>\n<li>什么是绑定？</li>\n<li>一些相关的内置函数（BIF）</li>\n</ol>\n<p>魔法方法</p>\n<ol>\n<li>基本的魔法方法</li>\n<li>算术运算符</li>\n<li>反算术运算符</li>\n<li>增量赋值运算</li>\n<li>一元运算符</li>\n<li>属性访问</li>\n<li>描述符</li>\n<li>定制序列</li>\n<li>迭代器</li>\n</ol>\n<p>简介<br>Python 是一种通用编程语言，其在科学计算和机器学习领域具有广泛的应用。如果我们打算利用 Python 来执行机器学习，那么对 Python 有一些基本的了解就是至关重要的。本 Python 入门系列体验就是为这样的初学者精心准备的。</p>\n<p>本实验包括以下内容：</p>\n<p>函数<br>函数的定义<br>函数的调用<br>函数文档<br>函数参数<br>函数的返回值<br>变量作用域<br>Lambda 表达式<br>匿名函数的定义<br>匿名函数的应用<br>类与对象<br>对象 = 属性 + 方法<br>self 是什么？<br>Python 的魔法方法<br>公有和私有<br>继承<br>组合<br>类、类对象和实例对象<br>什么是绑定？<br>一些相关的内置函数（BIF）<br>魔法方法<br>基本的魔法方法<br>算术运算符<br>反算术运算符<br>增量赋值运算符<br>一元运算符<br>属性访问<br>描述符<br>定制序列<br>迭代器<br>函数<br>函数的定义<br>还记得 Python 里面“万物皆对象”么？Python 把函数也当成对象，可以从另一个函数中返回出来而去构建高阶函数，比如： 参数是函数、返回值是函数。</p>\n<p>我们首先来介绍函数的定义。</p>\n<p>函数以def关键词开头，后接函数名和圆括号()。<br>函数执行的代码以冒号起始，并且缩进。<br>return [表达式] 结束函数，选择性地返回一个值给调用方。不带表达式的return相当于返回None。<br>def functionname (parameters):<br>       “函数_文档字符串”<br>        function_suite<br>        return [expression]</p>\n<p>函数的调用<br>【例子】</p>\n<pre><code class=\"python\">def printme(str):\n    print(str)\n​\n​\nprintme(&quot;我要调用用户自定义函数!&quot;)  # 我要调用用户自定义函数!\nprintme(&quot;再次调用同一函数&quot;)  # 再次调用同一函数\ntemp = printme(&#39;hello&#39;) # hello\nprint(temp)  # None</code></pre>\n<p>我要调用用户自定义函数!<br>再次调用同一函数<br>hello<br>None<br>函数文档<br>def MyFirstFunction(name):<br>    “函数定义过程中name是形参”<br>    # 因为Ta只是一个形式，表示占据一个参数位置<br>    print(‘传递进来的{0}叫做实参，因为Ta是具体的参数值！’.format(name))<br>​<br>​<br>MyFirstFunction(‘老马的程序人生’)  </p>\n<h1 id=\"传递进来的老马的程序人生叫做实参，因为Ta是具体的参数值！\"><a href=\"#传递进来的老马的程序人生叫做实参，因为Ta是具体的参数值！\" class=\"headerlink\" title=\"传递进来的老马的程序人生叫做实参，因为Ta是具体的参数值！\"></a>传递进来的老马的程序人生叫做实参，因为Ta是具体的参数值！</h1><p>​<br>print(MyFirstFunction.<strong>doc</strong>)  </p>\n<h1 id=\"函数定义过程中name是形参\"><a href=\"#函数定义过程中name是形参\" class=\"headerlink\" title=\"函数定义过程中name是形参\"></a>函数定义过程中name是形参</h1><p>​<br>help(MyFirstFunction)</p>\n<h1 id=\"Help-on-function-MyFirstFunction-in-module-main\"><a href=\"#Help-on-function-MyFirstFunction-in-module-main\" class=\"headerlink\" title=\"Help on function MyFirstFunction in module main:\"></a>Help on function MyFirstFunction in module <strong>main</strong>:</h1><h1 id=\"MyFirstFunction-name\"><a href=\"#MyFirstFunction-name\" class=\"headerlink\" title=\"MyFirstFunction(name)\"></a>MyFirstFunction(name)</h1><h1 id=\"函数定义过程中name是形参-1\"><a href=\"#函数定义过程中name是形参-1\" class=\"headerlink\" title=\"函数定义过程中name是形参\"></a>函数定义过程中name是形参</h1><p>传递进来的老马的程序人生叫做实参，因为Ta是具体的参数值！<br>函数定义过程中name是形参<br>Help on function MyFirstFunction in module <strong>main</strong>:</p>\n<p>MyFirstFunction(name)<br>    函数定义过程中name是形参</p>\n<p>函数参数<br>Python 的函数具有非常灵活多样的参数形态，既可以实现简单的调用，又可以传入非常复杂的参数。从简到繁的参数形态如下：</p>\n<p>位置参数 (positional argument)<br>默认参数 (default argument)<br>可变参数 (variable argument)<br>关键字参数 (keyword argument)<br>命名关键字参数 (name keyword argument)<br>参数组合</p>\n<ol>\n<li>位置参数<pre><code class=\"python\">def functionname(arg1):\n    &quot;函数_文档字符串&quot;\n    function_suite\n    return [expression]</code></pre>\narg1 - 位置参数 ，这些参数在调用函数 (call function) 时位置要固定。</li>\n<li>默认参数<pre><code class=\"python\">def functionname(arg1, arg2=v):\n    &quot;函数_文档字符串&quot;\n    function_suite\n    return [expression]</code></pre>\narg2 = v - 默认参数 = 默认值，调用函数时，默认参数的值如果没有传入，则被认为是默认值。<br>默认参数一定要放在位置参数 后面，不然程序会报错。<br>【例子】<pre><code class=\"python\">def printinfo(name, age=8):\n print(&#39;Name:&#123;0&#125;,Age:&#123;1&#125;&#39;.format(name, age))\n​\n​\nprintinfo(&#39;小马&#39;)  # Name:小马,Age:8\nprintinfo(&#39;小马&#39;, 10)  # Name:小马,Age:10</code></pre>\nName:小马,Age:8<br>Name:小马,Age:10<br>Python 允许函数调用时参数的顺序与声明时不一致，因为 Python 解释器能够用参数名匹配参数值。<br>【例子】<pre><code class=\"python\">def printinfo(name, age):\n print(&#39;Name:&#123;0&#125;,Age:&#123;1&#125;&#39;.format(name, age))\n​\n​\nprintinfo(age=8, name=&#39;小马&#39;)  # Name:小马,Age:8</code></pre>\nName:小马,Age:8</li>\n<li>可变参数</li>\n</ol>\n<p>顾名思义，可变参数就是传入的参数个数是可变的，可以是 0, 1, 2 到任意个，是不定长的参数。</p>\n<pre><code class=\"python\">def functionname(arg1, arg2=v, *args):\n       &quot;函数_文档字符串&quot;\n       function_suite\n       return [expression]</code></pre>\n<p><em>args - 可变参数，可以是从零个到任意个，自动组装成元组。<br>加了星号（</em>）的变量名会存放所有未命名的变量参数。<br>【例子】</p>\n<pre><code class=\"python\">def printinfo(arg1, *args):\n    print(arg1)\n    for var in args:\n        print(var)\n​\n​\nprintinfo(10)  # 10\nprintinfo(70, 60, 50)</code></pre>\n<h1 id=\"70\"><a href=\"#70\" class=\"headerlink\" title=\"70\"></a>70</h1><h1 id=\"60\"><a href=\"#60\" class=\"headerlink\" title=\"60\"></a>60</h1><h1 id=\"50\"><a href=\"#50\" class=\"headerlink\" title=\"50\"></a>50</h1><p>10<br>70<br>60<br>50<br>4. 关键字参数</p>\n<pre><code class=\"python\">def functionname(arg1, arg2=v, args, *kw):\n       &quot;函数_文档字符串&quot;\n       function_suite\n       return [expression]</code></pre>\n<p>**kw - 关键字参数，可以是从零个到任意个，自动组装成字典。<br>【例子】</p>\n<pre><code class=\"python\">def printinfo(arg1, *args, **kwargs):\n    print(arg1)\n    print(args)\n    print(kwargs)\n​\n​\nprintinfo(70, 60, 50)\n# 70\n# (60, 50)\n# &#123;&#125;\nprintinfo(70, 60, 50, a=1, b=2)\n# 70\n# (60, 50)\n# &#123;&#39;a&#39;: 1, &#39;b&#39;: 2&#125;</code></pre>\n<p>70<br>(60, 50)<br>{}<br>70<br>(60, 50)<br>{‘a’: 1, ‘b’: 2}<br>「可变参数」和「关键字参数」的同异总结如下：</p>\n<p>可变参数允许传入零个到任意个参数，它们在函数调用时自动组装为一个元组 (tuple)。<br>关键字参数允许传入零个到任意个参数，它们在函数内部自动组装为一个字典 (dict)。<br>5. 命名关键字参数</p>\n<pre><code class=\"python\">def functionname(arg1, arg2=v, args, *, nkw, *kw):\n       &quot;函数_文档字符串&quot;\n       function_suite\n       return [expression]</code></pre>\n<p>*, nkw - 命名关键字参数，用户想要输入的关键字参数，定义方式是在nkw 前面加个分隔符 *。<br>如果要限制关键字参数的名字，就可以用「命名关键字参数」<br>使用命名关键字参数时，要特别注意不能缺少参数名。<br>【例子】</p>\n<pre><code class=\"python\">def printinfo(arg1, *, nkw, **kwargs):\n    print(arg1)\n    print(nkw)\n    print(kwargs)\n​\n​\nprintinfo(70, nkw=10, a=1, b=2)\n# 70\n# 10\n# &#123;&#39;a&#39;: 1, &#39;b&#39;: 2&#125;\n​\nprintinfo(70, 10, a=1, b=2)\n# TypeError: printinfo() takes 1 positional argument but 2 were given</code></pre>\n<p>70<br>10<br>{‘a’: 1, ‘b’: 2}<br>没有写参数名nwk，因此 10 被当成「位置参数」，而原函数只有 1 个位置函数，现在调用了 2 个，因此程序会报错。<br>6. 参数组合</p>\n<p>在 Python 中定义函数，可以用位置参数、默认参数、可变参数、命名关键字参数和关键字参数，这 5 种参数中的 4 个都可以一起使用，但是注意，参数定义的顺序必须是：</p>\n<p>位置参数、默认参数、可变参数和关键字参数。<br>位置参数、默认参数、命名关键字参数和关键字参数。<br>要注意定义可变参数和关键字参数的语法：</p>\n<p>*args 是可变参数，args 接收的是一个 tuple<br>**kw 是关键字参数，kw 接收的是一个 dict<br>命名关键字参数是为了限制调用者可以传入的参数名，同时可以提供默认值。定义命名关键字参数不要忘了写分隔符 *，否则定义的是位置参数。</p>\n<p>警告：虽然可以组合多达 5 种参数，但不要同时使用太多的组合，否则函数很难懂。</p>\n<p>函数的返回值<br>【例子】</p>\n<pre><code class=\"python\">def add(a, b):\n    return a + b\n​\n​\nprint(add(1, 2))  # 3\nprint(add([1, 2, 3], [4, 5, 6]))  # [1, 2, 3, 4, 5, 6]</code></pre>\n<p>3<br>[1, 2, 3, 4, 5, 6]<br>【例子】</p>\n<pre><code class=\"python\">def back():\n    return [1, &#39;小马的程序人生&#39;, 3.14]\n​\n​\nprint(back())  # [1, &#39;小马的程序人生&#39;, 3.14]</code></pre>\n<p>[1, ‘小马的程序人生’, 3.14]<br>【例子】</p>\n<pre><code class=\"python\">def back():\n    return 1, &#39;小马的程序人生&#39;, 3.14\n​\n​\nprint(back())  # (1, &#39;小马的程序人生&#39;, 3.14)</code></pre>\n<p>(1, ‘小马的程序人生’, 3.14)<br>【例子】</p>\n<pre><code class=\"python\">def printme(str):\n    print(str)\n​\ntemp = printme(&#39;hello&#39;) # hello\nprint(temp) # None\nprint(type(temp))  # &lt;class &#39;NoneType&#39;&gt;</code></pre>\n<p>hello<br>None<br>&lt;class ‘NoneType’&gt;<br>变量作用域<br>Python 中，程序的变量并不是在哪个位置都可以访问的，访问权限决定于这个变量是在哪里赋值的。<br>定义在函数内部的变量拥有局部作用域，该变量称为局部变量。<br>定义在函数外部的变量拥有全局作用域，该变量称为全局变量。<br>局部变量只能在其被声明的函数内部访问，而全局变量可以在整个程序范围内访问。<br>【例子】</p>\n<pre><code class=\"python\">def discounts(price, rate):\n    final_price = price * rate\n    return final_price\n​\n​\nold_price = float(input(&#39;请输入原价:&#39;))  # 98\nrate = float(input(&#39;请输入折扣率:&#39;))  # 0.9\nnew_price = discounts(old_price, rate)\nprint(&#39;打折后价格是:%.2f&#39; % new_price)  # 88.20</code></pre>\n<p>请输入原价:98<br>请输入折扣率:0.9<br>打折后价格是:88.20<br>当内部作用域想修改外部作用域的变量时，就要用到global和nonlocal关键字了。<br>【例子】</p>\n<pre><code class=\"python\">num = 1\n​\n​\ndef fun1():\n    global num  # 需要使用 global 关键字声明\n    print(num)  # 1\n    num = 123\n    print(num)  # 123\n​\n​\nfun1()\nprint(num)  # 123</code></pre>\n<p>1<br>123<br>123<br>内嵌函数</p>\n<p>【例子】</p>\n<pre><code class=\"python\">def outer():\n    print(&#39;outer函数在这被调用&#39;)\n​\n    def inner():\n        print(&#39;inner函数在这被调用&#39;)\n​\n    inner()  # 该函数只能在outer函数内部被调用\n​\n​\nouter()\n# outer函数在这被调用\n# inner函数在这被调用</code></pre>\n<p>outer函数在这被调用<br>inner函数在这被调用<br>闭包</p>\n<p>是函数式编程的一个重要的语法结构，是一种特殊的内嵌函数。<br>如果在一个内部函数里对外层非全局作用域的变量进行引用，那么内部函数就被认为是闭包。<br>通过闭包可以访问外层非全局作用域的变量，这个作用域称为 闭包作用域。<br>【例子】</p>\n<pre><code class=\"python\">def funX(x):\n    def funY(y):\n        return x * y\n​\n    return funY\n​\n​\ni = funX(8)\nprint(type(i))  # &lt;class &#39;function&#39;&gt;\nprint(i(5))  # 40</code></pre>\n<p>&lt;class ‘function’&gt;<br>40<br>【例子】闭包的返回值通常是函数。</p>\n<pre><code class=\"python\">def make_counter(init):\n    counter = [init]\n​\n    def inc(): counter[0] += 1\n​\n    def dec(): counter[0] -= 1\n​\n    def get(): return counter[0]\n​\n    def reset(): counter[0] = init\n​\n    return inc, dec, get, reset\n​\n​\ninc, dec, get, reset = make_counter(0)\ninc()\ninc()\ninc()\nprint(get())  # 3\ndec()\nprint(get())  # 2\nreset()\nprint(get())  # 0</code></pre>\n<p>3<br>2<br>0<br>【例子】 如果要修改闭包作用域中的变量则需要 nonlocal 关键字</p>\n<pre><code class=\"python\">def outer():\n    num = 10\n​\n    def inner():\n        nonlocal num  # nonlocal关键字声明\n        num = 100\n        print(num)\n​\n    inner()\n    print(num)\n​\n​\nouter()\n​\n# 100\n# 100\n</code></pre>\n<p>100<br>100<br>递归</p>\n<p>如果一个函数在内部调用自身本身，这个函数就是递归函数。<br>【例子】n! = 1 x 2 x 3 x … x n</p>\n<pre><code class=\"python\"># 利用循环\nn = 5\nfor k in range(1, 5):\n    n = n * k\nprint(n)  # 120\n​\n# 利用递归\ndef factorial(n):\n    if n == 1:\n        return 1\n    return n * factorial(n - 1)\n​\n​\nprint(factorial(5)) # 120</code></pre>\n<p>120<br>120<br>【例子】斐波那契数列 f(n)=f(n-1)+f(n-2), f(0)=0 f(1)=1</p>\n<pre><code class=\"python\"># 利用循环\ni = 0\nj = 1\nlst = list([i, j])\nfor k in range(2, 11):\n    k = i + j\n    lst.append(k)\n    i = j\n    j = k\nprint(lst)  \n# [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55]\n​\n# 利用递归\ndef recur_fibo(n):\n    if n &lt;= 1:\n        return n\n    return recur_fibo(n - 1) + recur_fibo(n - 2)\n​\n​\nlst = list()\nfor k in range(11):\n    lst.append(recur_fibo(k))\nprint(lst)  \n# [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55]</code></pre>\n<p>[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55]<br>[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55]<br>【例子】设置递归的层数，Python默认递归层数为 100</p>\n<pre><code class=\"python\">import sys\n​\nsys.setrecursionlimit(1000)</code></pre>\n<p>Lambda 表达式<br>匿名函数的定义<br>在 Python 里有两类函数：</p>\n<p>第一类：用 def 关键词定义的正规函数<br>第二类：用 lambda 关键词定义的匿名函数<br>Python 使用 lambda 关键词来创建匿名函数，而非def关键词，它没有函数名，其语法结构如下：</p>\n<p>lambda argument_list: expression</p>\n<p>lambda - 定义匿名函数的关键词。<br>argument_list - 函数参数，它们可以是位置参数、默认参数、关键字参数，和正规函数里的参数类型一样。<br>:- 冒号，在函数参数和表达式中间要加个冒号。<br>expression - 只是一个表达式，输入函数参数，输出一些值。<br>注意：</p>\n<p>expression 中没有 return 语句，因为 lambda 不需要它来返回，表达式本身结果就是返回值。<br>匿名函数拥有自己的命名空间，且不能访问自己参数列表之外或全局命名空间里的参数。<br>【例子】</p>\n<pre><code class=\"python\">def sqr(x):\n    return x ** 2\n​\n​\nprint(sqr)\n# &lt;function sqr at 0x000000BABD3A4400&gt;\n​\ny = [sqr(x) for x in range(10)]\nprint(y)\n# [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]\n​\nlbd_sqr = lambda x: x ** 2\nprint(lbd_sqr)\n# &lt;function &lt;lambda&gt; at 0x000000BABB6AC1E0&gt;\n​\ny = [lbd_sqr(x) for x in range(10)]\nprint(y)\n# [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]\n​\n​\nsumary = lambda arg1, arg2: arg1 + arg2\nprint(sumary(10, 20))  # 30\n​\nfunc = lambda *args: sum(args)\nprint(func(1, 2, 3, 4, 5))  # 15</code></pre>\n<p>&lt;function sqr at 0x00000220081D9E18&gt;<br>[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]<br>&lt;function <lambda> at 0x00000220081FF400&gt;<br>[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]<br>30<br>15<br>匿名函数的应用<br>函数式编程 是指代码中每一块都是不可变的，都由纯函数的形式组成。这里的纯函数，是指函数本身相互独立、互不影响，对于相同的输入，总会有相同的输出，没有任何副作用。</p>\n<p>【例子】非函数式编程</p>\n<pre><code class=\"python\">def f(x):\n    for i in range(0, len(x)):\n        x[i] += 10\n    return x\n​\n​\nx = [1, 2, 3]\nf(x)\nprint(x)\n\n# [11, 12, 13]</code></pre>\n<p>[11, 12, 13]<br>【例子】函数式编程</p>\n<pre><code class=\"python\">def f(x):\n    y = []\n    for item in x:\n        y.append(item + 10)\n    return y\n​\n​\nx = [1, 2, 3]\nf(x)\nprint(x)\n# [1, 2, 3]</code></pre>\n<p>[1, 2, 3]<br>匿名函数 常常应用于函数式编程的高阶函数 (high-order function)中，主要有两种形式：</p>\n<p>参数是函数 (filter, map)<br>返回值是函数 (closure)<br>如，在 filter和map函数中的应用：</p>\n<p>filter(function, iterable) 过滤序列，过滤掉不符合条件的元素，返回一个迭代器对象，如果要转换为列表，可以使用 list() 来转换。<br>【例子】</p>\n<pre><code class=\"python\">odd = lambda x: x % 2 == 1\ntemplist = filter(odd, [1, 2, 3, 4, 5, 6, 7, 8, 9])\nprint(list(templist))  # [1, 3, 5, 7, 9]</code></pre>\n<p>[1, 3, 5, 7, 9]<br>map(function, *iterables) 根据提供的函数对指定序列做映射。<br>【例子】</p>\n<pre><code class=\"python\">m1 = map(lambda x: x ** 2, [1, 2, 3, 4, 5])\nprint(list(m1))  \n# [1, 4, 9, 16, 25]\n​\nm2 = map(lambda x, y: x + y, [1, 3, 5, 7, 9], [2, 4, 6, 8, 10])\nprint(list(m2))  \n# [3, 7, 11, 15, 19]</code></pre>\n<p>[1, 4, 9, 16, 25]<br>[3, 7, 11, 15, 19]<br>除了 Python 这些内置函数，我们也可以自己定义高阶函数。</p>\n<p>【例子】</p>\n<pre><code class=\"python\">def apply_to_list(fun, some_list):\n    return fun(some_list)\n​\nlst = [1, 2, 3, 4, 5]\nprint(apply_to_list(sum, lst))\n# 15\n​\nprint(apply_to_list(len, lst))\n# 5\n​\nprint(apply_to_list(lambda x: sum(x) / len(x), lst))\n# 3.0</code></pre>\n<p>15<br>5<br>3.0<br>类与对象<br>对象 = 属性 + 方法<br>对象是类的实例。换句话说，类主要定义对象的结构，然后我们以类为模板创建对象。类不但包含方法定义，而且还包含所有实例共享的数据。</p>\n<p>封装：信息隐蔽技术<br>我们可以使用关键字 class 定义 Python 类，关键字后面紧跟类的名称、分号和类的实现。</p>\n<p>【例子】</p>\n<pre><code class=\"python\">class Turtle:  # Python中的类名约定以大写字母开头\n    &quot;&quot;&quot;关于类的一个简单例子&quot;&quot;&quot;\n    # 属性\n    color = &#39;green&#39;\n    weight = 10\n    legs = 4\n    shell = True\n    mouth = &#39;大嘴&#39;\n​\n    # 方法\n    def climb(self):\n        print(&#39;我正在很努力的向前爬...&#39;)\n​\n    def run(self):\n        print(&#39;我正在飞快的向前跑...&#39;)\n​\n    def bite(self):\n        print(&#39;咬死你咬死你!!&#39;)\n​\n    def eat(self):\n        print(&#39;有得吃，真满足...&#39;)\n​\n    def sleep(self):\n        print(&#39;困了，睡了，晚安，zzz&#39;)\n​\n​\ntt = Turtle()\nprint(tt)\n# &lt;__main__.Turtle object at 0x0000007C32D67F98&gt;\n​\nprint(type(tt))\n# &lt;class &#39;__main__.Turtle&#39;&gt;\n​\nprint(tt.__class__)\n# &lt;class &#39;__main__.Turtle&#39;&gt;\n​\nprint(tt.__class__.__name__)\n# Turtle\n​\ntt.climb()\n# 我正在很努力的向前爬...\n​\ntt.run()\n# 我正在飞快的向前跑...\n​\ntt.bite()\n# 咬死你咬死你!!\n​\n# Python类也是对象。它们是type的实例\nprint(type(Turtle))\n# &lt;class &#39;type&#39;&gt;</code></pre>\n<p>&lt;__main__.Turtle object at 0x000002200820E898&gt;<br>&lt;class ‘__main__.Turtle’&gt;<br>&lt;class ‘__main__.Turtle’&gt;<br>Turtle<br>我正在很努力的向前爬…<br>我正在飞快的向前跑…<br>咬死你咬死你!!<br>&lt;class ‘type’&gt;<br>继承：子类自动共享父类之间数据和方法的机制<br>【例子】</p>\n<pre><code class=\"python\">class MyList(list):\n    pass\n​\n​\nlst = MyList([1, 5, 2, 7, 8])\nlst.append(9)\nlst.sort()\nprint(lst)\n​\n# [1, 2, 5, 7, 8, 9]</code></pre>\n<p>[1, 2, 5, 7, 8, 9]<br>多态：不同对象对同一方法响应不同的行动<br>【例子】</p>\n<pre><code class=\"python\">class Animal:\n    def run(self):\n        raise AttributeError(&#39;子类必须实现这个方法&#39;)\n​\n​\nclass People(Animal):\n    def run(self):\n        print(&#39;人正在走&#39;)\n​\n​\nclass Pig(Animal):\n    def run(self):\n        print(&#39;pig is walking&#39;)\n​\n​\nclass Dog(Animal):\n    def run(self):\n        print(&#39;dog is running&#39;)\n​\n​\ndef func(animal):\n    animal.run()\n​\n​\nfunc(Pig())\n# pig is walking</code></pre>\n<p>pig is walking<br>self 是什么？<br>Python 的 self 相当于 C++ 的 this 指针。</p>\n<p>【例子】</p>\n<pre><code class=\"python\">class Test:\n    def prt(self):\n        print(self)\n        print(self.__class__)\n​\n​\nt = Test()\nt.prt()\n# &lt;__main__.Test object at 0x000000BC5A351208&gt;\n# &lt;class &#39;__main__.Test&#39;&gt;</code></pre>\n<p>&lt;__main__.Test object at 0x000002200820EA20&gt;<br>&lt;class ‘__main__.Test’&gt;<br>类的方法与普通的函数只有一个特别的区别 —— 它们必须有一个额外的第一个参数名称（对应于该实例，即该对象本身），按照惯例它的名称是 self。在调用方法时，我们无需明确提供与参数 self 相对应的参数。</p>\n<p>【例子】</p>\n<pre><code class=\"python\">class Ball:\n    def setName(self, name):\n        self.name = name\n​\n    def kick(self):\n        print(&quot;我叫%s,该死的，谁踢我...&quot; % self.name)\n​\n​\na = Ball()\na.setName(&quot;球A&quot;)\nb = Ball()\nb.setName(&quot;球B&quot;)\nc = Ball()\nc.setName(&quot;球C&quot;)\na.kick()\n# 我叫球A,该死的，谁踢我...\nb.kick()\n# 我叫球B,该死的，谁踢我...</code></pre>\n<p>我叫球A,该死的，谁踢我…<br>我叫球B,该死的，谁踢我…<br>Python 的魔法方法<br>据说，Python 的对象天生拥有一些神奇的方法，它们是面向对象的 Python 的一切…</p>\n<p>它们是可以给你的类增加魔力的特殊方法…</p>\n<p>如果你的对象实现了这些方法中的某一个，那么这个方法就会在特殊的情况下被 Python 所调用，而这一切都是自动发生的…</p>\n<p>类有一个名为<strong>init</strong>(self[, param1, param2…])的魔法方法，该方法在类实例化时会自动调用。</p>\n<p>【例子】</p>\n<pre><code class=\"python\">​\nclass Ball:\n    def __init__(self, name):\n        self.name = name\n​\n    def kick(self):\n        print(&quot;我叫%s,该死的，谁踢我...&quot; % self.name)\n​\n​\na = Ball(&quot;球A&quot;)\nb = Ball(&quot;球B&quot;)\nc = Ball(&quot;球C&quot;)\na.kick()\n# 我叫球A,该死的，谁踢我...\nb.kick()\n# 我叫球B,该死的，谁踢我...</code></pre>\n<p>我叫球A,该死的，谁踢我…<br>我叫球B,该死的，谁踢我…<br>公有和私有<br>在 Python 中定义私有变量只需要在变量名或函数名前加上“__”两个下划线，那么这个函数或变量就会为私有的了。</p>\n<p>【例子】类的私有属性实例</p>\n<pre><code class=\"python\">class JustCounter:\n    __secretCount = 0  # 私有变量\n    publicCount = 0  # 公开变量\n​\n    def count(self):\n        self.__secretCount += 1\n        self.publicCount += 1\n        print(self.__secretCount)\n​\n​\ncounter = JustCounter()\ncounter.count()  # 1\ncounter.count()  # 2\nprint(counter.publicCount)  # 2\n​\n# Python的私有为伪私有\nprint(counter._JustCounter__secretCount)  # 2 \nprint(counter.__secretCount)  \n# AttributeError: &#39;JustCounter&#39; object has no attribute &#39;__secretCount&#39;</code></pre>\n<p>1<br>2<br>2<br>2<br>【例子】类的私有方法实例</p>\n<pre><code class=\"python\">class Site:\n    def __init__(self, name, url):\n        self.name = name  # public\n        self.__url = url  # private\n​\n    def who(self):\n        print(&#39;name  : &#39;, self.name)\n        print(&#39;url : &#39;, self.__url)\n​\n    def __foo(self):  # 私有方法\n        print(&#39;这是私有方法&#39;)\n​\n    def foo(self):  # 公共方法\n        print(&#39;这是公共方法&#39;)\n        self.__foo()\n​\n​\nx = Site(&#39;老马的程序人生&#39;, &#39;https://blog.csdn.net/LSGO_MYP&#39;)\nx.who()\n# name  :  老马的程序人生\n# url :  https://blog.csdn.net/LSGO_MYP\n​\nx.foo()\n# 这是公共方法\n# 这是私有方法\n​\nx.__foo()\n# AttributeError: &#39;Site&#39; object has no attribute &#39;__foo&#39;</code></pre>\n<p>name  :  老马的程序人生<br>url :  <span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xTR09fTVlQ\">https://blog.csdn.net/LSGO_MYP</span><br>这是公共方法<br>这是私有方法<br>继承<br>Python 同样支持类的继承，派生类的定义如下所示：</p>\n<p>class DerivedClassName(BaseClassName):<br>       statement-1<br>              .<br>              .<br>              .<br>       statement-N</p>\n<p>BaseClassName（基类名）必须与派生类定义在一个作用域内。除了类，还可以用表达式，基类定义在另一个模块中时这一点非常有用：</p>\n<p>class DerivedClassName(modname.BaseClassName):<br>       statement-1<br>              .<br>              .<br>              .<br>       statement-N</p>\n<p>【例子】如果子类中定义与父类同名的方法或属性，则会自动覆盖父类对应的方法或属性。</p>\n<pre><code class=\"python\"># 类定义\nclass people:\n    # 定义基本属性\n    name = &#39;&#39;\n    age = 0\n    # 定义私有属性,私有属性在类外部无法直接进行访问\n    __weight = 0\n​\n    # 定义构造方法\n    def __init__(self, n, a, w):\n        self.name = n\n        self.age = a\n        self.__weight = w\n​\n    def speak(self):\n        print(&quot;%s 说: 我 %d 岁。&quot; % (self.name, self.age))\n​\n​\n# 单继承示例\nclass student(people):\n    grade = &#39;&#39;\n​\n    def __init__(self, n, a, w, g):\n        # 调用父类的构函\n        people.__init__(self, n, a, w)\n        self.grade = g\n​\n    # 覆写父类的方法\n    def speak(self):\n        print(&quot;%s 说: 我 %d 岁了，我在读 %d 年级&quot; % (self.name, self.age, self.grade))\n​\n​\ns = student(&#39;小马的程序人生&#39;, 10, 60, 3)\ns.speak()\n# 小马的程序人生 说: 我 10 岁了，我在读 3 年级</code></pre>\n<p>小马的程序人生 说: 我 10 岁了，我在读 3 年级<br>注意：如果上面的程序去掉：people.<strong>init</strong>(self, n, a, w)，则输出：说: 我 0 岁了，我在读 3 年级，因为子类的构造方法把父类的构造方法覆盖了。</p>\n<p>【例子】</p>\n<pre><code class=\"python\">import random\n​\nclass Fish:\n    def __init__(self):\n        self.x = random.randint(0, 10)\n        self.y = random.randint(0, 10)\n​\n    def move(self):\n        self.x -= 1\n        print(&quot;我的位置&quot;, self.x, self.y)\n​\n​\nclass GoldFish(Fish):  # 金鱼\n    pass\n​\n​\nclass Carp(Fish):  # 鲤鱼\n    pass\n​\n​\nclass Salmon(Fish):  # 三文鱼\n    pass\n​\n​\nclass Shark(Fish):  # 鲨鱼\n    def __init__(self):\n        self.hungry = True\n​\n    def eat(self):\n        if self.hungry:\n            print(&quot;吃货的梦想就是天天有得吃！&quot;)\n            self.hungry = False\n        else:\n            print(&quot;太撑了，吃不下了！&quot;)\n            self.hungry = True\n​\n​\ng = GoldFish()\ng.move()  # 我的位置 9 4\ns = Shark()\ns.eat() # 吃货的梦想就是天天有得吃！\ns.move()  \n# AttributeError: &#39;Shark&#39; object has no attribute &#39;x&#39;</code></pre>\n<p>我的位置 3 8<br>吃货的梦想就是天天有得吃！<br>解决该问题可用以下两种方式：</p>\n<p>调用未绑定的父类方法Fish.<strong>init</strong>(self)<br>class Shark(Fish):  # 鲨鱼<br>    def <strong>init</strong>(self):<br>        Fish.<strong>init</strong>(self)<br>        self.hungry = True<br>​<br>    def eat(self):<br>        if self.hungry:<br>            print(“吃货的梦想就是天天有得吃！”)<br>            self.hungry = False<br>        else:<br>            print(“太撑了，吃不下了！”)<br>            self.hungry = True<br>使用super函数super().<strong>init</strong>()<br>class Shark(Fish):  # 鲨鱼<br>    def <strong>init</strong>(self):<br>        super().<strong>init</strong>()<br>        self.hungry = True<br>​<br>    def eat(self):<br>        if self.hungry:<br>            print(“吃货的梦想就是天天有得吃！”)<br>            self.hungry = False<br>        else:<br>            print(“太撑了，吃不下了！”)<br>            self.hungry = True<br>Python 虽然支持多继承的形式，但我们一般不使用多继承，因为容易引起混乱。</p>\n<p>class DerivedClassName(Base1, Base2, Base3):<br>       statement-1<br>              .<br>              .<br>              .<br>       statement-N</p>\n<p>需要注意圆括号中父类的顺序，若是父类中有相同的方法名，而在子类使用时未指定，Python 从左至右搜索，即方法在子类中未找到时，从左到右查找父类中是否包含方法。</p>\n<p>【例子】</p>\n<pre><code class=\"python\"># 类定义\nclass People:\n    # 定义基本属性\n    name = &#39;&#39;\n    age = 0\n    # 定义私有属性,私有属性在类外部无法直接进行访问\n    __weight = 0\n​\n    # 定义构造方法\n    def __init__(self, n, a, w):\n        self.name = n\n        self.age = a\n        self.__weight = w\n​\n    def speak(self):\n        print(&quot;%s 说: 我 %d 岁。&quot; % (self.name, self.age))\n​\n​\n# 单继承示例\nclass Student(People):\n    grade = &#39;&#39;\n​\n    def __init__(self, n, a, w, g):\n        # 调用父类的构函\n        People.__init__(self, n, a, w)\n        self.grade = g\n​\n    # 覆写父类的方法\n    def speak(self):\n        print(&quot;%s 说: 我 %d 岁了，我在读 %d 年级&quot; % (self.name, self.age, self.grade))\n​\n​\n# 另一个类，多重继承之前的准备\nclass Speaker:\n    topic = &#39;&#39;\n    name = &#39;&#39;\n​\n    def __init__(self, n, t):\n        self.name = n\n        self.topic = t\n​\n    def speak(self):\n        print(&quot;我叫 %s，我是一个演说家，我演讲的主题是 %s&quot; % (self.name, self.topic))\n​\n​\n# 多重继承\nclass Sample01(Speaker, Student):\n    a = &#39;&#39;\n​\n    def __init__(self, n, a, w, g, t):\n        Student.__init__(self, n, a, w, g)\n        Speaker.__init__(self, n, t)\n​\n# 方法名同，默认调用的是在括号中排前地父类的方法\ntest = Sample01(&quot;Tim&quot;, 25, 80, 4, &quot;Python&quot;)\ntest.speak()  \n# 我叫 Tim，我是一个演说家，我演讲的主题是 Python\n​\nclass Sample02(Student, Speaker):\n    a = &#39;&#39;\n​\n    def __init__(self, n, a, w, g, t):\n        Student.__init__(self, n, a, w, g)\n        Speaker.__init__(self, n, t)\n​\n# 方法名同，默认调用的是在括号中排前地父类的方法\ntest = Sample02(&quot;Tim&quot;, 25, 80, 4, &quot;Python&quot;)\ntest.speak()  \n# Tim 说: 我 25 岁了，我在读 4 年级</code></pre>\n<p>我叫 Tim，我是一个演说家，我演讲的主题是 Python<br>Tim 说: 我 25 岁了，我在读 4 年级<br>组合<br>【例子】</p>\n<pre><code class=\"python\">class Turtle:\n    def __init__(self, x):\n        self.num = x\n​\n​\nclass Fish:\n    def __init__(self, x):\n        self.num = x\n​\n​\nclass Pool:\n    def __init__(self, x, y):\n        self.turtle = Turtle(x)\n        self.fish = Fish(y)\n​\n    def print_num(self):\n        print(&quot;水池里面有乌龟%s只，小鱼%s条&quot; % (self.turtle.num, self.fish.num))\n​\n​\np = Pool(2, 3)\np.print_num()\n# 水池里面有乌龟2只，小鱼3条</code></pre>\n<p>水池里面有乌龟2只，小鱼3条<br>类、类对象和实例对象<br>类对象和实例对象</p>\n<p>类对象：创建一个类，其实也是一个对象也在内存开辟了一块空间，称为类对象，类对象只有一个。</p>\n<p>class A(object):<br>       pass</p>\n<p>实例对象：就是通过实例化类创建的对象，称为实例对象，实例对象可以有多个。</p>\n<p>【例子】</p>\n<pre><code class=\"python\">class A(object):\n    pass\n​\n# 实例化对象 a、b、c都属于实例对象\n。\na = A()\nb = A()\nc = A()</code></pre>\n<p>类属性：类里面方法外面定义的变量称为类属性。类属性所属于类对象并且多个实例对象之间共享同一个类属性，说白了就是类属性所有的通过该类实例化的对象都能共享。</p>\n<p>【例子】</p>\n<pre><code class=\"python\">class A():\n    a = 0  #类属性\n    def __init__(self, xx):\n        A.a = xx  #使用类属性可以通过 （类名.类属性）调用。</code></pre>\n<p>实例属性：实例属性和具体的某个实例对象有关系，并且一个实例对象和另外一个实例对象是不共享属性的，说白了实例属性只能在自己的对象里面使用，其他的对象不能直接使用，因为self是谁调用，它的值就属于该对象。</p>\n<p>【例子】</p>\n<pre><code class=\"python\"># 创建类对象\nclass Test(object):\n    class_attr = 100  # 类属性\n​\n    def __init__(self):\n        self.sl_attr = 100  # 实例属性\n​\n    def func(self):\n        print(&#39;类对象.类属性的值:&#39;, Test.class_attr)  # 调用类属性\n        print(&#39;self.类属性的值&#39;, self.class_attr)  # 相当于把类属性 变成实例属性\n        print(&#39;self.实例属性的值&#39;, self.sl_attr)  # 调用实例属性\n​\n​\na = Test()\na.func()\n​\n# 类对象.类属性的值: 100\n# self.类属性的值 100\n# self.实例属性的值 100\n​\nb = Test()\nb.func()\n​\n# 类对象.类属性的值: 100\n# self.类属性的值 100\n# self.实例属性的值 100\n​\na.class_attr = 200\na.sl_attr = 200\na.func()\n​\n# 类对象.类属性的值: 100\n# self.类属性的值 200\n# self.实例属性的值 200\n​\nb.func()\n​\n# 类对象.类属性的值: 100\n# self.类属性的值 100\n# self.实例属性的值 100\n​\nTest.class_attr = 300\na.func()\n​\n# 类对象.类属性的值: 300\n# self.类属性的值 200\n# self.实例属性的值 200\n​\nb.func()\n# 类对象.类属性的值: 300\n# self.类属性的值 300\n# self.实例属性的值 100</code></pre>\n<p>类对象.类属性的值: 100<br>self.类属性的值 100<br>self.实例属性的值 100<br>类对象.类属性的值: 100<br>self.类属性的值 100<br>self.实例属性的值 100<br>类对象.类属性的值: 100<br>self.类属性的值 200<br>self.实例属性的值 200<br>类对象.类属性的值: 100<br>self.类属性的值 100<br>self.实例属性的值 100<br>类对象.类属性的值: 300<br>self.类属性的值 200<br>self.实例属性的值 200<br>类对象.类属性的值: 300<br>self.类属性的值 300<br>self.实例属性的值 100<br>注意：属性与方法名相同，属性会覆盖方法。</p>\n<p>【例子】</p>\n<pre><code class=\"python\">class A:\n    def x(self):\n        print(&#39;x_man&#39;)\n​\n​\naa = A()\naa.x()  # x_man\naa.x = 1\nprint(aa.x)  # 1\naa.x()\n# TypeError: &#39;int&#39; object is not callable</code></pre>\n<p>x_man<br>1<br>什么是绑定？<br>Python 严格要求方法需要有实例才能被调用，这种限制其实就是 Python 所谓的绑定概念。</p>\n<p>Python 对象的数据属性通常存储在名为.__ dict__的字典中，我们可以直接访问<strong>dict__，或利用 Python 的内置函数vars()获取.</strong> dict__。</p>\n<p>【例子】</p>\n<pre><code class=\"python\">class CC:\n    def setXY(self, x, y):\n        self.x = x\n        self.y = y\n​\n    def printXY(self):\n        print(self.x, self.y)\n​\n​\ndd = CC()\nprint(dd.__dict__)\n# &#123;&#125;\n​\nprint(vars(dd))\n# &#123;&#125;\n​\nprint(CC.__dict__)\n# &#123;&#39;__module__&#39;: &#39;__main__&#39;, &#39;setXY&#39;: &lt;function CC.setXY at 0x000000C3473DA048&gt;, &#39;printXY&#39;: &lt;function CC.printXY at 0x000000C3473C4F28&gt;, &#39;__dict__&#39;: &lt;attribute &#39;__dict__&#39; of &#39;CC&#39; objects&gt;, &#39;__weakref__&#39;: &lt;attribute &#39;__weakref__&#39; of &#39;CC&#39; objects&gt;, &#39;__doc__&#39;: None&#125;\n​\ndd.setXY(4, 5)\nprint(dd.__dict__)\n# &#123;&#39;x&#39;: 4, &#39;y&#39;: 5&#125;\n​\nprint(vars(CC))\n# &#123;&#39;__module__&#39;: &#39;__main__&#39;, &#39;setXY&#39;: &lt;function CC.setXY at 0x000000632CA9B048&gt;, &#39;printXY&#39;: &lt;function CC.printXY at 0x000000632CA83048&gt;, &#39;__dict__&#39;: &lt;attribute &#39;__dict__&#39; of &#39;CC&#39; objects&gt;, &#39;__weakref__&#39;: &lt;attribute &#39;__weakref__&#39; of &#39;CC&#39; objects&gt;, &#39;__doc__&#39;: None&#125;\n​\nprint(CC.__dict__)\n# &#123;&#39;__module__&#39;: &#39;__main__&#39;, &#39;setXY&#39;: &lt;function CC.setXY at 0x000000632CA9B048&gt;, &#39;printXY&#39;: &lt;function CC.printXY at 0x000000632CA83048&gt;, &#39;__dict__&#39;: &lt;attribute &#39;__dict__&#39; of &#39;CC&#39; objects&gt;, &#39;__weakref__&#39;: &lt;attribute &#39;__weakref__&#39; of &#39;CC&#39; objects&gt;, &#39;__doc__&#39;: None&#125;</code></pre>\n<p>{}<br>{}<br>{‘<strong>module</strong>‘: ‘<strong>main</strong>‘, ‘setXY’: &lt;function CC.setXY at 0x000002200822BD08&gt;, ‘printXY’: &lt;function CC.printXY at 0x000002200822BF28&gt;, ‘<strong>dict</strong>‘: &lt;attribute ‘__dict__’ of ‘CC’ objects&gt;, ‘<strong>weakref</strong>‘: &lt;attribute ‘__weakref__’ of ‘CC’ objects&gt;, ‘<strong>doc</strong>‘: None}<br>{‘x’: 4, ‘y’: 5}<br>{‘<strong>module</strong>‘: ‘<strong>main</strong>‘, ‘setXY’: &lt;function CC.setXY at 0x000002200822BD08&gt;, ‘printXY’: &lt;function CC.printXY at 0x000002200822BF28&gt;, ‘<strong>dict</strong>‘: &lt;attribute ‘__dict__’ of ‘CC’ objects&gt;, ‘<strong>weakref</strong>‘: &lt;attribute ‘__weakref__’ of ‘CC’ objects&gt;, ‘<strong>doc</strong>‘: None}<br>{‘<strong>module</strong>‘: ‘<strong>main</strong>‘, ‘setXY’: &lt;function CC.setXY at 0x000002200822BD08&gt;, ‘printXY’: &lt;function CC.printXY at 0x000002200822BF28&gt;, ‘<strong>dict</strong>‘: &lt;attribute ‘__dict__’ of ‘CC’ objects&gt;, ‘<strong>weakref</strong>‘: &lt;attribute ‘__weakref__’ of ‘CC’ objects&gt;, ‘<strong>doc</strong>‘: None}<br>一些相关的内置函数（BIF）<br>issubclass(class, classinfo) 方法用于判断参数 class 是否是类型参数 classinfo 的子类。<br>一个类被认为是其自身的子类。<br>classinfo可以是类对象的元组，只要class是其中任何一个候选类的子类，则返回True。<br>【例子】</p>\n<pre><code class=\"python\">class A:\n    pass\n​\n​\nclass B(A):\n    pass\n​\n​\nprint(issubclass(B, A))  # True\nprint(issubclass(B, B))  # True\nprint(issubclass(A, B))  # False\nprint(issubclass(B, object))  # True</code></pre>\n<p>True<br>True<br>False<br>True<br>isinstance(object, classinfo) 方法用于判断一个对象是否是一个已知的类型，类似type()。<br>type()不会认为子类是一种父类类型，不考虑继承关系。<br>isinstance()会认为子类是一种父类类型，考虑继承关系。<br>如果第一个参数不是对象，则永远返回False。<br>如果第二个参数不是类或者由类对象组成的元组，会抛出一个TypeError异常。<br>【例子】</p>\n<p>a = 2<br>print(isinstance(a, int))  # True<br>print(isinstance(a, str))  # False<br>print(isinstance(a, (str, int, list)))  # True<br>​<br>​<br>class A:<br>    pass<br>​<br>​<br>class B(A):<br>    pass<br>​<br>​<br>print(isinstance(A(), A))  # True<br>print(type(A()) == A)  # True<br>print(isinstance(B(), A))  # True<br>print(type(B()) == A)  # False<br>True<br>False<br>True<br>True<br>True<br>True<br>False<br>hasattr(object, name)用于判断对象是否包含对应的属性。<br>【例子】</p>\n<pre><code class=\"python\">class Coordinate:\n    x = 10\n    y = -5\n    z = 0\n​\n​\npoint1 = Coordinate()\nprint(hasattr(point1, &#39;x&#39;))  # True\nprint(hasattr(point1, &#39;y&#39;))  # True\nprint(hasattr(point1, &#39;z&#39;))  # True\nprint(hasattr(point1, &#39;no&#39;))  # False</code></pre>\n<p>True<br>True<br>True<br>False<br>getattr(object, name[, default])用于返回一个对象属性值。<br>【例子】</p>\n<pre><code class=\"python\">class A(object):\n    bar = 1\n​\n​\na = A()\nprint(getattr(a, &#39;bar&#39;))  # 1\nprint(getattr(a, &#39;bar2&#39;, 3))  # 3\nprint(getattr(a, &#39;bar2&#39;))\n# AttributeError: &#39;A&#39; object has no attribute &#39;bar2&#39;</code></pre>\n<p>1<br>3<br>【例子】这个例子很酷！</p>\n<pre><code class=\"python\">class A(object):\n    def set(self, a, b):\n        x = a\n        a = b\n        b = x\n        print(a, b)\n​\n​\na = A()\nc = getattr(a, &#39;set&#39;)\nc(a=&#39;1&#39;, b=&#39;2&#39;)  # 2 1</code></pre>\n<p>​<br>2 1<br>setattr(object, name, value)对应函数 getattr()，用于设置属性值，该属性不一定是存在的。<br>【例子】</p>\n<pre><code class=\"python\">class A(object):\n    bar = 1\n​\n​\na = A()\nprint(getattr(a, &#39;bar&#39;))  # 1\nsetattr(a, &#39;bar&#39;, 5)\nprint(a.bar)  # 5\nsetattr(a, &quot;age&quot;, 28)\nprint(a.age)  # 28</code></pre>\n<p>1<br>5<br>28<br>delattr(object, name)用于删除属性。<br>【例子】</p>\n<pre><code class=\"python\">class Coordinate:\n    x = 10\n    y = -5\n    z = 0\n​\n​\npoint1 = Coordinate()\n​\nprint(&#39;x = &#39;, point1.x)  # x =  10\nprint(&#39;y = &#39;, point1.y)  # y =  -5\nprint(&#39;z = &#39;, point1.z)  # z =  0\n​\ndelattr(Coordinate, &#39;z&#39;)\n​\nprint(&#39;--删除 z 属性后--&#39;)  # --删除 z 属性后--\nprint(&#39;x = &#39;, point1.x)  # x =  10\nprint(&#39;y = &#39;, point1.y)  # y =  -5\n​\n# 触发错误\nprint(&#39;z = &#39;, point1.z)\n# AttributeError: &#39;Coordinate&#39; object has no attribute &#39;z&#39;</code></pre>\n<p>x =  10<br>y =  -5<br>z =  0<br>–删除 z 属性后–<br>x =  10<br>y =  -5<br>class property([fget[, fset[, fdel[, doc]]]])用于在新式类中返回属性值。<br>fget – 获取属性值的函数<br>fset – 设置属性值的函数<br>fdel – 删除属性值函数<br>doc – 属性描述信息<br>【例子】</p>\n<pre><code class=\"python\">class C(object):\n    def __init__(self):\n        self.__x = None\n​\n    def getx(self):\n        return self.__x\n​\n    def setx(self, value):\n        self.__x = value\n​\n    def delx(self):\n        del self.__x\n​\n    x = property(getx, setx, delx, &quot;I&#39;m the &#39;x&#39; property.&quot;)\n​\n​\ncc = C()\ncc.x = 2\nprint(cc.x)  # 2\n​\ndel cc.x\nprint(cc.x)\n# AttributeError: &#39;C&#39; object has no attribute &#39;_C__x&#39;</code></pre>\n<p>2<br>魔法方法<br>魔法方法总是被双下划线包围，例如__init__。</p>\n<p>魔法方法是面向对象的 Python 的一切，如果你不知道魔法方法，说明你还没能意识到面向对象的 Python 的强大。</p>\n<p>魔法方法的“魔力”体现在它们总能够在适当的时候被自动调用。</p>\n<p>魔法方法的第一个参数应为cls（类方法） 或者self（实例方法）。</p>\n<p>cls：代表一个类的名称<br>self：代表一个实例对象的名称<br>基本的魔法方法<br><strong>init</strong>(self[, …]) 构造器，当一个实例被创建的时候调用的初始化方法<br>【例子】</p>\n<pre><code class=\"python\">class Rectangle:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n​\n    def getPeri(self):\n        return (self.x + self.y) * 2\n​\n    def getArea(self):\n        return self.x * self.y\n​\n​\nrect = Rectangle(4, 5)\nprint(rect.getPeri())  # 18\nprint(rect.getArea())  # 20</code></pre>\n<p>18<br>20<br><strong>new</strong>(cls[, …]) 在一个对象实例化的时候所调用的第一个方法，在调用__init__初始化前，先调用__new__。<br>__new__至少要有一个参数cls，代表要实例化的类，此参数在实例化时由 Python 解释器自动提供，后面的参数直接传递给__init__。<br>__new__对当前类进行了实例化，并将实例返回，传给__init__的self。但是，执行了__new__，并不一定会进入__init__，只有__new__返回了，当前类cls的实例，当前类的__init__才会进入。<br>【例子】</p>\n<pre><code class=\"python\">class A(object):\n    def __init__(self, value):\n        print(&quot;into A __init__&quot;)\n        self.value = value\n​\n    def __new__(cls, *args, **kwargs):\n        print(&quot;into A __new__&quot;)\n        print(cls)\n        return object.__new__(cls)\n​\n​\nclass B(A):\n    def __init__(self, value):\n        print(&quot;into B __init__&quot;)\n        self.value = value\n​\n    def __new__(cls, *args, **kwargs):\n        print(&quot;into B __new__&quot;)\n        print(cls)\n        return super().__new__(cls, *args, **kwargs)\n​\n​\nb = B(10)\n​\n# 结果：\n# into B __new__\n# &lt;class &#39;__main__.B&#39;&gt;\n# into A __new__\n# &lt;class &#39;__main__.B&#39;&gt;\n# into B __init__\n​\nclass A(object):\n    def __init__(self, value):\n        print(&quot;into A __init__&quot;)\n        self.value = value\n​\n    def __new__(cls, *args, **kwargs):\n        print(&quot;into A __new__&quot;)\n        print(cls)\n        return object.__new__(cls)\n​\n​\nclass B(A):\n    def __init__(self, value):\n        print(&quot;into B __init__&quot;)\n        self.value = value\n​\n    def __new__(cls, *args, **kwargs):\n        print(&quot;into B __new__&quot;)\n        print(cls)\n        return super().__new__(A, *args, **kwargs)  # 改动了cls变为A\n​\n​\nb = B(10)\n​\n# 结果：\n# into B __new__\n# &lt;class &#39;__main__.B&#39;&gt;\n# into A __new__\n# &lt;class &#39;__main__.A&#39;&gt;</code></pre>\n<p>into B <strong>new</strong><br>&lt;class ‘__main__.B’&gt;<br>into A <strong>new</strong><br>&lt;class ‘__main__.B’&gt;<br>into B <strong>init</strong><br>into B <strong>new</strong><br>&lt;class ‘__main__.B’&gt;<br>into A <strong>new</strong><br>&lt;class ‘__main__.A’&gt;<br>若__new__没有正确返回当前类cls的实例，那__init__是不会被调用的，即使是父类的实例也不行，将没有__init__被调用。<br>【例子】利用__new__实现单例模式。</p>\n<pre><code class=\"python\">class Earth:\n    pass\n​\n​\na = Earth()\nprint(id(a))  # 260728291456\nb = Earth()\nprint(id(b))  # 260728291624\n​\nclass Earth:\n    __instance = None  # 定义一个类属性做判断\n​\n    def __new__(cls):\n        if cls.__instance is None:\n            cls.__instance = object.__new__(cls)\n            return cls.__instance\n        else:\n            return cls.__instance\n​\n​\na = Earth()\nprint(id(a))  # 512320401648\nb = Earth()\nprint(id(b))  # 512320401648</code></pre>\n<p>2336598724336<br>2336598528464<br>2336598467752<br>2336598467752<br>__new__方法主要是当你继承一些不可变的 class 时（比如int, str, tuple）， 提供给你一个自定义这些类的实例化过程的途径。<br>【例子】</p>\n<pre><code class=\"python\">class CapStr(str):\n    def __new__(cls, string):\n        string = string.upper()\n        return str.__new__(cls, string)\n​\n​\na = CapStr(&quot;i love lsgogroup&quot;)\nprint(a)  # I LOVE LSGOGROUP</code></pre>\n<p>I LOVE LSGOGROUP<br><strong>del</strong>(self) 析构器，当一个对象将要被系统回收之时调用的方法。<br>Python 采用自动引用计数（ARC）方式来回收对象所占用的空间，当程序中有一个变量引用该 Python 对象时，Python 会自动保证该对象引用计数为 1；当程序中有两个变量引用该 Python 对象时，Python 会自动保证该对象引用计数为 2，依此类推，如果一个对象的引用计数变成了 0，则说明程序中不再有变量引用该对象，表明程序不再需要该对象，因此 Python 就会回收该对象。</p>\n<p>大部分时候，Python 的 ARC 都能准确、高效地回收系统中的每个对象。但如果系统中出现循环引用的情况，比如对象 a 持有一个实例变量引用对象 b，而对象 b 又持有一个实例变量引用对象 a，此时两个对象的引用计数都是 1，而实际上程序已经不再有变量引用它们，系统应该回收它们，此时 Python 的垃圾回收器就可能没那么快，要等专门的循环垃圾回收器（Cyclic Garbage Collector）来检测并回收这种引用循环。</p>\n<p>【例子】</p>\n<pre><code class=\"python\">class C(object):\n    def __init__(self):\n        print(&#39;into C __init__&#39;)\n​\n    def __del__(self):\n        print(&#39;into C __del__&#39;)\n​\n​\nc1 = C()\n# into C __init__\nc2 = c1\nc3 = c2\ndel c3\ndel c2\ndel c1\n# into C __del__</code></pre>\n<p>into C <strong>init</strong><br>into C <strong>del</strong><br><strong>str</strong>(self):</p>\n<p>当你打印一个对象的时候，触发<strong>str</strong><br>当你使用%s格式化的时候，触发<strong>str</strong><br>str强转数据类型的时候，触发<strong>str</strong><br><strong>repr</strong>(self)：</p>\n<p>repr是str的备胎<br>有<strong>str__的时候执行__str</strong>,没有实现<strong>str__的时候，执行__repr</strong><br>repr(obj)内置函数对应的结果是<strong>repr__的返回值<br>当你使用%r格式化的时候 触发__repr</strong><br>【例子】</p>\n<p>class Cat:<br>    “””定义一个猫类”””<br>​<br>    def <strong>init</strong>(self, new_name, new_age):<br>        “””在创建完对象之后 会自动调用, 它完成对象的初始化的功能”””<br>        self.name = new_name<br>        self.age = new_age<br>​<br>    def <strong>str</strong>(self):<br>        “””返回一个对象的描述信息”””<br>        return “名字是:%s , 年龄是:%d” % (self.name, self.age)</p>\n<pre><code>def __repr__(self):\n    &quot;&quot;&quot;返回一个对象的描述信息&quot;&quot;&quot;\n    return &quot;Cat:(%s,%d)&quot; % (self.name, self.age)</code></pre>\n<p>​<br>    def eat(self):<br>        print(“%s在吃鱼….” % self.name)<br>​<br>    def drink(self):<br>        print(“%s在喝可乐…” % self.name)<br>​<br>    def introduce(self):<br>        print(“名字是:%s, 年龄是:%d” % (self.name, self.age))<br>​<br>​</p>\n<h1 id=\"创建了一个对象\"><a href=\"#创建了一个对象\" class=\"headerlink\" title=\"创建了一个对象\"></a>创建了一个对象</h1><p>tom = Cat(“汤姆”, 30)<br>print(tom)  # 名字是:汤姆 , 年龄是:30<br>print(str(tom)) # 名字是:汤姆 , 年龄是:30<br>print(repr(tom))  # Cat:(汤姆,30)<br>tom.eat()  # 汤姆在吃鱼….<br>tom.introduce()  # 名字是:汤姆, 年龄是:30<br>名字是:汤姆 , 年龄是:30<br>名字是:汤姆 , 年龄是:30<br>Cat:(汤姆,30)<br>汤姆在吃鱼….<br>名字是:汤姆, 年龄是:30<br><strong>str</strong>(self) 的返回结果可读性强。也就是说，<strong>str</strong> 的意义是得到便于人们阅读的信息，就像下面的 ‘2019-10-11’ 一样。</p>\n<p><strong>repr</strong>(self) 的返回结果应更准确。怎么说，<strong>repr</strong> 存在的目的在于调试，便于开发者使用。</p>\n<p>【例子】</p>\n<pre><code class=\"python\">import datetime\n​\ntoday = datetime.date.today()\nprint(str(today))  # 2019-10-11\nprint(repr(today))  # datetime.date(2019, 10, 11)\nprint(&#39;%s&#39; %today)  # 2019-10-11\nprint(&#39;%r&#39; %today)  # datetime.date(2019, 10, 11)</code></pre>\n<p>2020-08-01<br>datetime.date(2020, 8, 1)<br>2020-08-01<br>datetime.date(2020, 8, 1)<br>算术运算符<br>类型工厂函数，指的是“不通过类而是通过函数来创建对象”。</p>\n<p>【例子】</p>\n<pre><code class=\"python\">class C:\n    pass\n​\n​\nprint(type(len))  # &lt;class &#39;builtin_function_or_method&#39;&gt;\nprint(type(dir))  # &lt;class &#39;builtin_function_or_method&#39;&gt;\nprint(type(int))  # &lt;class &#39;type&#39;&gt;\nprint(type(list))  # &lt;class &#39;type&#39;&gt;\nprint(type(tuple))  # &lt;class &#39;type&#39;&gt;\nprint(type(C))  # &lt;class &#39;type&#39;&gt;\nprint(int(&#39;123&#39;))  # 123\n​\n# 这个例子中list工厂函数把一个元祖对象加工成了一个列表对象。\nprint(list((1, 2, 3)))  # [1, 2, 3]</code></pre>\n<p>&lt;class ‘builtin_function_or_method’&gt;<br>&lt;class ‘builtin_function_or_method’&gt;<br>&lt;class ‘type’&gt;<br>&lt;class ‘type’&gt;<br>&lt;class ‘type’&gt;<br>&lt;class ‘type’&gt;<br>123<br>[1, 2, 3]<br><strong>add</strong>(self, other)定义加法的行为：+<br><strong>sub</strong>(self, other)定义减法的行为：-<br>【例子】</p>\n<pre><code class=\"python\">class MyClass:\n​\n    def __init__(self, height, weight):\n        self.height = height\n        self.weight = weight\n​\n    # 两个对象的长相加，宽不变.返回一个新的类\n    def __add__(self, others):\n        return MyClass(self.height + others.height, self.weight + others.weight)\n​\n    # 两个对象的宽相减，长不变.返回一个新的类\n    def __sub__(self, others):\n        return MyClass(self.height - others.height, self.weight - others.weight)\n​\n    # 说一下自己的参数\n    def intro(self):\n        print(&quot;高为&quot;, self.height, &quot; 重为&quot;, self.weight)\n​\n​\ndef main():\n    a = MyClass(height=10, weight=5)\n    a.intro()\n​\n    b = MyClass(height=20, weight=10)\n    b.intro()\n​\n    c = b - a\n    c.intro()\n​\n    d = a + b\n    d.intro()\n​\n​\nif __name__ == &#39;__main__&#39;:\n    main()\n​\n# 高为 10  重为 5\n# 高为 20  重为 10\n# 高为 10  重为 5\n# 高为 30  重为 15</code></pre>\n<p>高为 10  重为 5<br>高为 20  重为 10<br>高为 10  重为 5<br>高为 30  重为 15<br><strong>mul</strong>(self, other)定义乘法的行为：*<br><strong>truediv</strong>(self, other)定义真除法的行为：/<br><strong>floordiv</strong>(self, other)定义整数除法的行为：//<br><strong>mod</strong>(self, other) 定义取模算法的行为：%<br><strong>divmod</strong>(self, other)定义当被 divmod() 调用时的行为<br>divmod(a, b)把除数和余数运算结果结合起来，返回一个包含商和余数的元组(a // b, a % b)。<br>【例子】</p>\n<pre><code class=\"python\">print(divmod(7, 2))  # (3, 1)\nprint(divmod(8, 2))  # (4, 0)</code></pre>\n<p>(3, 1)<br>(4, 0)<br><strong>pow</strong>(self, other[, module])定义当被 power() 调用或 ** 运算时的行为<br><strong>lshift</strong>(self, other)定义按位左移位的行为：&lt;&lt;<br>__rshift__(self, other)定义按位右移位的行为：&gt;&gt;<br><strong>and</strong>(self, other)定义按位与操作的行为：&amp;<br><strong>xor</strong>(self, other)定义按位异或操作的行为：^<br><strong>or</strong>(self, other)定义按位或操作的行为：|<br>反算术运算符<br>反运算魔方方法，与算术运算符保持一一对应，不同之处就是反运算的魔法方法多了一个“r”。当文件左操作不支持相应的操作时被调用。</p>\n<p><strong>radd</strong>(self, other)定义加法的行为：+<br><strong>rsub</strong>(self, other)定义减法的行为：-<br><strong>rmul</strong>(self, other)定义乘法的行为：*<br><strong>rtruediv</strong>(self, other)定义真除法的行为：/<br><strong>rfloordiv</strong>(self, other)定义整数除法的行为：//<br><strong>rmod</strong>(self, other) 定义取模算法的行为：%<br><strong>rdivmod</strong>(self, other)定义当被 divmod() 调用时的行为<br><strong>rpow</strong>(self, other[, module])定义当被 power() 调用或 ** 运算时的行为<br><strong>rlshift</strong>(self, other)定义按位左移位的行为：&lt;&lt;<br>__rrshift__(self, other)定义按位右移位的行为：&gt;&gt;<br><strong>rand</strong>(self, other)定义按位与操作的行为：&amp;<br><strong>rxor</strong>(self, other)定义按位异或操作的行为：^<br><strong>ror</strong>(self, other)定义按位或操作的行为：|<br>a + b</p>\n<p>这里加数是a，被加数是b，因此是a主动，反运算就是如果a对象的<strong>add</strong>()方法没有实现或者不支持相应的操作，那么 Python 就会调用b的<strong>radd</strong>()方法。</p>\n<p>【例子】</p>\n<pre><code class=\"python\">class Nint(int):\n    def __radd__(self, other):\n        return int.__sub__(other, self) # 注意 self 在后面\n​\n​\na = Nint(5)\nb = Nint(3)\nprint(a + b)  # 8\nprint(1 + b)  # -2</code></pre>\n<p>8<br>-2<br>增量赋值运算符<br><strong>iadd</strong>(self, other)定义赋值加法的行为：+=<br><strong>isub</strong>(self, other)定义赋值减法的行为：-=<br><strong>imul</strong>(self, other)定义赋值乘法的行为：*=<br><strong>itruediv</strong>(self, other)定义赋值真除法的行为：/=<br><strong>ifloordiv</strong>(self, other)定义赋值整数除法的行为：//=<br><strong>imod</strong>(self, other)定义赋值取模算法的行为：%=<br><strong>ipow</strong>(self, other[, modulo])定义赋值幂运算的行为：**=<br><strong>ilshift</strong>(self, other)定义赋值按位左移位的行为：&lt;&lt;=<br>__irshift__(self, other)定义赋值按位右移位的行为：&gt;&gt;=<br><strong>iand</strong>(self, other)定义赋值按位与操作的行为：&amp;=<br><strong>ixor</strong>(self, other)定义赋值按位异或操作的行为：^=<br><strong>ior</strong>(self, other)定义赋值按位或操作的行为：|=<br>一元运算符<br><strong>neg</strong>(self)定义正号的行为：+x<br><strong>pos</strong>(self)定义负号的行为：-x<br><strong>abs</strong>(self)定义当被abs()调用时的行为<br><strong>invert</strong>(self)定义按位求反的行为：~x<br>属性访问<br><strong>getattr</strong>(self, name): 定义当用户试图获取一个不存在的属性时的行为。<br><strong>getattribute</strong>(self, name)：定义当该类的属性被访问时的行为（先调用该方法，查看是否存在该属性，若不存在，接着去调用<strong>getattr__）。<br>__setattr</strong>(self, name, value)：定义当一个属性被设置时的行为。<br><strong>delattr</strong>(self, name)：定义当一个属性被删除时的行为。<br>【例子】</p>\n<pre><code class=\"python\">class C:\n    def __getattribute__(self, item):\n        print(&#39;__getattribute__&#39;)\n        return super().__getattribute__(item)\n​\n    def __getattr__(self, item):\n        print(&#39;__getattr__&#39;)\n​\n    def __setattr__(self, key, value):\n        print(&#39;__setattr__&#39;)\n        super().__setattr__(key, value)\n​\n    def __delattr__(self, item):\n        print(&#39;__delattr__&#39;)\n        super().__delattr__(item)\n​\n​\nc = C()\nc.x\n# __getattribute__\n# __getattr__\n​\nc.x = 1\n# __setattr__\n​\ndel c.x\n# __delattr__</code></pre>\n<p><strong>getattribute</strong><br><strong>getattr</strong><br><strong>setattr</strong><br><strong>delattr</strong><br>描述符<br>描述符就是将某种特殊类型的类的实例指派给另一个类的属性。</p>\n<p><strong>get</strong>(self, instance, owner)用于访问属性，它返回属性的值。<br><strong>set</strong>(self, instance, value)将在属性分配操作中调用，不返回任何内容。<br><strong>del</strong>(self, instance)控制删除操作，不返回任何内容。<br>【例子】</p>\n<pre><code class=\"python\">class MyDecriptor:\n    def __get__(self, instance, owner):\n        print(&#39;__get__&#39;, self, instance, owner)\n​\n    def __set__(self, instance, value):\n        print(&#39;__set__&#39;, self, instance, value)\n​\n    def __delete__(self, instance):\n        print(&#39;__delete__&#39;, self, instance)\n​\n​\nclass Test:\n    x = MyDecriptor()\n​\n​\nt = Test()\nt.x\n# __get__ &lt;__main__.MyDecriptor object at 0x000000CEAAEB6B00&gt; &lt;__main__.Test object at 0x000000CEABDC0898&gt; &lt;class &#39;__main__.Test&#39;&gt;\n​\nt.x = &#39;x-man&#39;\n# __set__ &lt;__main__.MyDecriptor object at 0x00000023687C6B00&gt; &lt;__main__.Test object at 0x00000023696B0940&gt; x-man\n​\ndel t.x\n# __delete__ &lt;__main__.MyDecriptor object at 0x000000EC9B160A90&gt; &lt;__main__.Test object at 0x000000EC9B160B38&gt;</code></pre>\n<p><strong>get</strong> &lt;__main__.MyDecriptor object at 0x0000022008242668&gt; &lt;__main__.Test object at 0x00000220082427B8&gt; &lt;class ‘__main__.Test’&gt;<br><strong>set</strong> &lt;__main__.MyDecriptor object at 0x0000022008242668&gt; &lt;__main__.Test object at 0x00000220082427B8&gt; x-man<br><strong>delete</strong> &lt;__main__.MyDecriptor object at 0x0000022008242668&gt; &lt;__main__.Test object at 0x00000220082427B8&gt;<br>定制序列<br>协议（Protocols）与其它编程语言中的接口很相似，它规定你哪些方法必须要定义。然而，在 Python 中的协议就显得不那么正式。事实上，在 Python 中，协议更像是一种指南。</p>\n<p>容器类型的协议</p>\n<p>如果说你希望定制的容器是不可变的话，你只需要定义<strong>len</strong>()和<strong>getitem</strong>()方法。<br>如果你希望定制的容器是可变的话，除了<strong>len</strong>()和<strong>getitem</strong>()方法，你还需要定义<strong>setitem</strong>()和<strong>delitem</strong>()两个方法。<br>【例子】编写一个不可改变的自定义列表，要求记录列表中每个元素被访问的次数。</p>\n<pre><code class=\"python\">class CountList:\n    def __init__(self, *args):\n        self.values = [x for x in args]\n        self.count = &#123;&#125;.fromkeys(range(len(self.values)), 0)\n​\n    def __len__(self):\n        return len(self.values)\n​\n    def __getitem__(self, item):\n        self.count[item] += 1\n        return self.values[item]\n​\n​\nc1 = CountList(1, 3, 5, 7, 9)\nc2 = CountList(2, 4, 6, 8, 10)\nprint(c1[1])  # 3\nprint(c2[2])  # 6\nprint(c1[1] + c2[1])  # 7\n​\nprint(c1.count)\n# &#123;0: 0, 1: 2, 2: 0, 3: 0, 4: 0&#125;\n​\nprint(c2.count)\n# &#123;0: 0, 1: 1, 2: 1, 3: 0, 4: 0&#125;</code></pre>\n<p>3<br>6<br>7<br>{0: 0, 1: 2, 2: 0, 3: 0, 4: 0}<br>{0: 0, 1: 1, 2: 1, 3: 0, 4: 0}<br><strong>len</strong>(self)定义当被len()调用时的行为（返回容器中元素的个数）。<br><strong>getitem</strong>(self, key)定义获取容器中元素的行为，相当于self[key]。<br><strong>setitem</strong>(self, key, value)定义设置容器中指定元素的行为，相当于self[key] = value。<br><strong>delitem</strong>(self, key)定义删除容器中指定元素的行为，相当于del self[key]。<br>【例子】编写一个可改变的自定义列表，要求记录列表中每个元素被访问的次数。</p>\n<pre><code class=\"python\">class CountList:\n    def __init__(self, *args):\n        self.values = [x for x in args]\n        self.count = &#123;&#125;.fromkeys(range(len(self.values)), 0)\n​\n    def __len__(self):\n        return len(self.values)\n​\n    def __getitem__(self, item):\n        self.count[item] += 1\n        return self.values[item]\n​\n    def __setitem__(self, key, value):\n        self.values[key] = value\n​\n    def __delitem__(self, key):\n        del self.values[key]\n        for i in range(0, len(self.values)):\n            if i &gt;= key:\n                self.count[i] = self.count[i + 1]\n        self.count.pop(len(self.values))\n​\n​\nc1 = CountList(1, 3, 5, 7, 9)\nc2 = CountList(2, 4, 6, 8, 10)\nprint(c1[1])  # 3\nprint(c2[2])  # 6\nc2[2] = 12\nprint(c1[1] + c2[2])  # 15\nprint(c1.count)\n# &#123;0: 0, 1: 2, 2: 0, 3: 0, 4: 0&#125;\nprint(c2.count)\n# &#123;0: 0, 1: 0, 2: 2, 3: 0, 4: 0&#125;\ndel c1[1]\nprint(c1.count)\n# &#123;0: 0, 1: 0, 2: 0, 3: 0&#125;</code></pre>\n<p>3<br>6<br>15<br>{0: 0, 1: 2, 2: 0, 3: 0, 4: 0}<br>{0: 0, 1: 0, 2: 2, 3: 0, 4: 0}<br>{0: 0, 1: 0, 2: 0, 3: 0}<br>迭代器<br>迭代是 Python 最强大的功能之一，是访问集合元素的一种方式。<br>迭代器是一个可以记住遍历的位置的对象。<br>迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。<br>迭代器只能往前不会后退。<br>字符串，列表或元组对象都可用于创建迭代器：<br>【例子】</p>\n<pre><code class=\"python\">string = &#39;lsgogroup&#39;\nfor c in string:\n    print(c)\n​\n&#39;&#39;&#39;\nl\ns\ng\no\ng\nr\no\nu\np\n&#39;&#39;&#39;\n​\nfor c in iter(string):\n    print(c)</code></pre>\n<p>l<br>s<br>g<br>o<br>g<br>r<br>o<br>u<br>p<br>l<br>s<br>g<br>o<br>g<br>r<br>o<br>u<br>p<br>【例子】</p>\n<pre><code class=\"python\">links = &#123;&#39;B&#39;: &#39;百度&#39;, &#39;A&#39;: &#39;阿里&#39;, &#39;T&#39;: &#39;腾讯&#39;&#125;\nfor each in links:\n    print(&#39;%s -&gt; %s&#39; % (each, links[each]))\n\n&#39;&#39;&#39;\nB -&gt; 百度\nA -&gt; 阿里\nT -&gt; 腾讯\n&#39;&#39;&#39;\n​\nfor each in iter(links):\n    print(&#39;%s -&gt; %s&#39; % (each, links[each]))</code></pre>\n<p>B -&gt; 百度<br>A -&gt; 阿里<br>T -&gt; 腾讯<br>B -&gt; 百度<br>A -&gt; 阿里<br>T -&gt; 腾讯<br>迭代器有两个基本的方法：iter() 和 next()。<br>iter(object) 函数用来生成迭代器。<br>next(iterator[, default]) 返回迭代器的下一个项目。<br>iterator – 可迭代对象<br>default – 可选，用于设置在没有下一个元素时返回该默认值，如果不设置，又没有下一个元素则会触发 StopIteration 异常。<br>【例子】</p>\n<pre><code class=\"python\">links = &#123;&#39;B&#39;: &#39;百度&#39;, &#39;A&#39;: &#39;阿里&#39;, &#39;T&#39;: &#39;腾讯&#39;&#125;\n​\nit = iter(links)\nwhile True:\n    try:\n        each = next(it)\n    except StopIteration:\n        break\n    print(each)\n​\n# B\n# A\n# T\n​\nit = iter(links)\nprint(next(it))  # B\nprint(next(it))  # A\nprint(next(it))  # T\nprint(next(it))  # StopIteration</code></pre>\n<p>B<br>A<br>T<br>B<br>A<br>T</p>\n<hr>\n<p>StopIteration                             Traceback (most recent call last)<br><ipython-input-2-682f811edce7> in <module>()<br>     17 print(next(it))  # A<br>     18 print(next(it))  # T<br>—&gt; 19 print(next(it))  # StopIteration</p>\n<p>StopIteration:<br>把一个类作为一个迭代器使用需要在类中实现两个魔法方法 <strong>iter</strong>() 与 <strong>next</strong>() 。</p>\n<p><strong>iter</strong>(self)定义当迭代容器中的元素的行为，返回一个特殊的迭代器对象， 这个迭代器对象实现了 <strong>next</strong>() 方法并通过 StopIteration 异常标识迭代的完成。<br><strong>next</strong>() 返回下一个迭代器对象。<br>StopIteration 异常用于标识迭代的完成，防止出现无限循环的情况，在 <strong>next</strong>() 方法中我们可以设置在完成指定循环次数后触发 StopIteration 异常来结束迭代。<br>【例子】</p>\n<pre><code class=\"python\">class Fibs:\n    def __init__(self, n=10):\n        self.a = 0\n        self.b = 1\n        self.n = n\n​\n    def __iter__(self):\n        return self\n​\n    def __next__(self):\n        self.a, self.b = self.b, self.a + self.b\n        if self.a &gt; self.n:\n            raise StopIteration\n        return self.a\n​\n​\nfibs = Fibs(100)\nfor each in fibs:\n    print(each, end=&#39; &#39;)\n​\n# 1 1 2 3 5 8 13 21 34 55 89</code></pre>\n<p>1 1 2 3 5 8 13 21 34 55 89<br>4.10 生成器</p>\n<p>在 Python 中，使用了 yield 的函数被称为生成器（generator）。<br>跟普通函数不同的是，生成器是一个返回迭代器的函数，只能用于迭代操作，更简单点理解生成器就是一个迭代器。<br>在调用生成器运行的过程中，每次遇到 yield 时函数会暂停并保存当前所有的运行信息，返回 yield 的值, 并在下一次执行 next() 方法时从当前位置继续运行。<br>调用一个生成器函数，返回的是一个迭代器对象。<br>【例子】</p>\n<pre><code class=\"python\">def myGen():\n    print(&#39;生成器执行！&#39;)\n    yield 1\n    yield 2\n\nmyG = myGen()\nfor each in myG:\n    print(each)\n​\n&#39;&#39;&#39;\n生成器执行！\n1\n2\n&#39;&#39;&#39;\n​\nmyG = myGen()\nprint(next(myG))  \n# 生成器执行！\n# 1\n​\nprint(next(myG))  # 2\nprint(next(myG))  # StopIteration</code></pre>\n<p>生成器执行！<br>1<br>2<br>生成器执行！<br>1<br>2</p>\n<hr>\n<p>StopIteration                             Traceback (most recent call last)<br><ipython-input-6-56bfa60ce8de> in <module>()<br>     14<br>     15 print(next(myG))  # 2<br>—&gt; 16 print(next(myG))  # StopIteration</p>\n<p>StopIteration:<br>【例子】用生成器实现斐波那契数列。</p>\n<pre><code class=\"python\">def libs(n):\n    a = 0\n    b = 1\n    while True:\n        a, b = b, a + b\n        if a &gt; n:\n            return\n        yield a\n​\n​\nfor each in libs(100):\n    print(each, end=&#39; &#39;)\n​\n# 1 1 2 3 5 8 13 21 34 55 89</code></pre>\n<p>1 1 2 3 5 8 13 21 34 55 89</p>\n",
            "tags": [
                "python"
            ]
        },
        {
            "id": "http://47.97.229.110/2021/01/26/hello-world/",
            "url": "http://47.97.229.110/2021/01/26/hello-world/",
            "title": "Hello Hexo",
            "date_published": "2021-01-26T08:42:53.177Z",
            "content_html": "<p>Welcome to <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvLw==\">Hexo</span>! This is your very first post. Check <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3Mv\">documentation</span> for more info. If you get any problems when using Hexo, you can find the answer in <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3MvdHJvdWJsZXNob290aW5nLmh0bWw=\">troubleshooting</span> or you can ask me on <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2hleG9qcy9oZXhvL2lzc3Vlcw==\">GitHub</span>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><pre><code class=\"bash\">$ hexo new &quot;My New Post&quot;</code></pre>\n<p>More info: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvd3JpdGluZy5odG1s\">Writing</span></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><pre><code class=\"bash\">$ hexo server</code></pre>\n<p>More info: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvc2VydmVyLmh0bWw=\">Server</span></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><pre><code class=\"bash\">$ hexo generate</code></pre>\n<p>More info: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3MvZ2VuZXJhdGluZy5odG1s\">Generating</span></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><pre><code class=\"bash\">$ hexo deploy</code></pre>\n<p>More info: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvb25lLWNvbW1hbmQtZGVwbG95bWVudC5odG1s\">Deployment</span></p>\n",
            "tags": [
                "hexo"
            ]
        },
        {
            "id": "http://47.97.229.110/2021/01/26/2020-1-26/",
            "url": "http://47.97.229.110/2021/01/26/2020-1-26/",
            "title": "2020-1-26",
            "date_published": "2021-01-26T02:55:39.000Z",
            "content_html": "<p>2020-1-26<br>开发出了Hexo站点</p>\n",
            "tags": [
                "日志"
            ]
        },
        {
            "id": "http://47.97.229.110/2021/01/26/%E7%89%B9%E6%AE%8A%E5%8A%9F%E8%83%BD/",
            "url": "http://47.97.229.110/2021/01/26/%E7%89%B9%E6%AE%8A%E5%8A%9F%E8%83%BD/",
            "title": "特殊功能",
            "date_published": "2021-01-26T01:27:48.000Z",
            "content_html": "<p>links 链接块<br>本功能参考 NexT，基于 Hexo Tag 功能，用来建立友链或其他网址链接功能。</p>\n<p>文章中的使用格式：</p>\n<p>使用 links 标签块，包围 yml 语法书写的内容，字段包括<br>site    站点名称    必填<br>owner    管理员名字    可选，默认为 site 的值<br>url        站点链接    必填<br>desc    站点描述    可选，默认为 url 的值<br>image    站点图片    可选，默认为 images/404.png<br>color    方块颜色    可选，默认为 #666</p>\n<pre><code class=\"bash\">&#123;% links %&#125;\n- site: #站点名称\n  owner: #管理员名字\n  url: #站点网址\n  desc: #简短描述\n  image: #一张图片\n  color: #颜色代码\n&#123;% endlinks %&#125;</code></pre>\n<p>举个栗子：</p>\n<pre><code class=\"bash\">&#123;% links %&#125;\n- site: 優萌初華\n  owner: 霜月琉璃\n  url: https://shoka.lostyu.me\n  desc: 琉璃的医学 & 编程笔记\n  image: https://cdn.jsdelivr.net/gh/amehime/shoka@latest/images/avatar.jpg\n  color: \"#e9546b\"\n\n- site: 優萌初華\n  owner: 霜月琉璃\n  url: https://shoka.lostyu.me\n  image: images/avatar.jpg\n\n- site: 優萌初華\n  url: https://shoka.lostyu.me\n  desc: 琉璃的医学 & 编程笔记\n  color: \"#9d5b8b\"\n&#123;% endlinks %&#125;</code></pre>\n<div class=\"links\"><div class=\"item\" title=\"霜月琉璃\" style=\"--block-color:#e9546b;\"><span class=\"exturl image\" data-url=\"aHR0cHM6Ly9zaG9rYS5sb3N0eXUubWU=\" data-background-image=\"https://cdn.jsdelivr.net/gh/amehime/shoka@latest/images/avatar.jpg\"></span>\n          <div class=\"info\">\n          <span class=\"exturl title\" data-url=\"aHR0cHM6Ly9zaG9rYS5sb3N0eXUubWU=\">優萌初華</span>\n          <p class=\"desc\">琉璃的医学 & 编程笔记</p>\n          </div></div><div class=\"item\" title=\"霜月琉璃\"><span class=\"exturl image\" data-url=\"aHR0cHM6Ly9zaG9rYS5sb3N0eXUubWU=\" data-background-image=\"/images/avatar.jpg\"></span>\n          <div class=\"info\">\n          <span class=\"exturl title\" data-url=\"aHR0cHM6Ly9zaG9rYS5sb3N0eXUubWU=\">優萌初華</span>\n          <p class=\"desc\">https://shoka.lostyu.me</p>\n          </div></div><div class=\"item\" title=\"優萌初華\" style=\"--block-color:#9d5b8b;\"><span class=\"exturl image\" data-url=\"aHR0cHM6Ly9zaG9rYS5sb3N0eXUubWU=\" data-background-image=\"/images/404.png\"></span>\n          <div class=\"info\">\n          <span class=\"exturl title\" data-url=\"aHR0cHM6Ly9zaG9rYS5sb3N0eXUubWU=\">優萌初華</span>\n          <p class=\"desc\">琉璃的医学 & 编程笔记</p>\n          </div></div></div>\n\n<p>以上标签块里的内容，还可以保存到一个 yml 文件中，然后使用 linksfile 标签。<br>其中， path 位于 <root>/source 目录下。</p>\n<pre><code class=\"bash\">&#123;% linksfile [path] %&#125;</code></pre>\n<p>举个栗子：</p>\n<pre><code class=\"bash\">&#123;% linksfile friends/_data.yml %&#125;</code></pre>\n<p>code 代码块</p>\n<p>使用 markdown-it-prism 进行代码高亮，支持显示行号、行高亮 mark 、命令行提示符 command 、代码块标题。</p>\n<p>基本格式： [language] [title] [url] [link text] [mark] [command]</p>\n<p>选项    描述    默认值<br>language</p>\n<p>支持的语言戳此<br>如果不需要代码高亮，但希望显示代码块样式，则设为 raw<br>留空或设为 info ，将不显示代码高亮和代码块样式<br>null</p>\n<p>title    代码块的标题文字    null<br>url    代码块标题右侧显示的链接    null<br>link text    上述链接显示的标题    link<br>mark</p>\n<p>行高亮显示，格式为 mark:行号,行号开始-行号结束,其他行号 。<br>例如 mark:1,4-7,10 ，将高亮显示第 1、4、5、6、7、10 行</p>\n<p>null</p>\n<p>command</p>\n<p>命令行提示符，格式为 command:(“提示内容”:行号,行号||”提示内容”:行号开始-行号结束)<br>例如 command:(“[root@localhost] $”:1,9-10||”[admin@remotehost] #”:4-6)</p>\n<p>null</p>\n<pre><code class=\"bash\">```java 行高亮 https://shoka.lostyu.me 参考链接 mark:1,6-7\nimport java.util.Scanner;\n...\nScanner in = new Scanner (System.in);\n// 输入 Scan 之后，按下键盘 Alt + “/” 键，Eclipse 下自动补全。\n\nSystem.out.println (in.nextLine ());\nSystem.out.println (&quot;Hello&quot; + &quot;world.&quot;);</code></pre>\n<pre><code class=\"bash\">pwd\n/usr/home/chris/bin\nls -la\ntotal 2\ndrwxr-xr-x   2 chris  chris     11 Jan 10 16:48 .\ndrwxr--r-x  45 chris  chris     92 Feb 14 11:10 ..\n-rwxr-xr-x   1 chris  chris    444 Aug 25  2013 backup\n-rwxr-xr-x   1 chris  chris    642 Jan 17 14:42 deploy\ngit add -A\ngit commit -m &quot;update&quot;\ngit push</code></pre>\n<pre><code class=\"bash\">import java.util.Scanner;\n...\nScanner in = new Scanner(System.in);\n// 输入 Scan 之后，按下键盘 Alt + “/” 键，Eclipse 下自动补全。\n\nSystem.out.println(in.nextLine());\nSystem.out.println(&quot;Hello&quot; + &quot; world.&quot;);</code></pre>\n<pre><code class=\"bash\">pwd\n/usr/home/chris/bin\nls -la\ntotal 2\ndrwxr-xr-x   2 chris  chris     11 Jan 10 16:48 .\ndrwxr--r-x  45 chris  chris     92 Feb 14 11:10 ..\n-rwxr-xr-x   1 chris  chris    444 Aug 25  2013 backup\n-rwxr-xr-x   1 chris  chris    642 Jan 17 14:42 deploy\ngit add -A\ngit commit -m &quot;update&quot;\ngit push</code></pre>\n<p>quiz 练习题与答案<br>这个功能是用来显示练习题的。<br>需要在 Front Matter 中添加 quiz: true ，以正确显示题型标签。</p>\n<pre><code class=\"bash\">---\ntitle: 练习题与答案\nquiz: true\n---\n\n1. 编译时多态主要指运算符重载与函数重载，而运行时多态主要指虚函数。 &#123;.quiz .true&#125;\n\n2. 有基类 `SHAPE`，派生类 `CIRCLE`，声明如下变量：  &#123;.quiz .multi&#125;\n    ```cpp\n    SHAPE shape1,*p1;\n    CIRCLE circle1,*q1;\n    ```\n    下列哪些项是 “派生类对象替换基类对象”。\n    - `p1=&amp;circle1;` &#123;.correct&#125;\n    - `q1=&amp;shape1;`\n    - `shape1=circle1;` &#123;.correct&#125;\n    - `circle1=shape1;`\n&#123;.options&#125;\n    &gt; - :heavy_check_mark: 令基类对象的指针指向派生类对象\n    &gt; - :x: 派生类指针指向基类的引用\n    &gt; - :heavy_check_mark: 派生类对象给基类对象赋值\n    &gt; - :x: 基类对象给派生类对象赋值\n    &gt; &#123;.options&#125;\n\n3. 下列叙述正确的是 []&#123;.gap&#125; 。 &#123;.quiz&#125;\n    - 虚函数只能定义成无参函数\n    - 虚函数不能有返回值\n    - 能定义虚构造函数\n    - A、B、C 都不对 &#123;.correct&#125;\n&#123;.options&#125;\n\n10. 如果定义 `int e=8; double f=6.4, g=8.9;`，则表达式 `f+int (e/3*int (f+g)/2)%4` 的值为 [9.4]&#123;.gap&#125;。 &#123;.quiz .fill&#125;\n    &gt; 注意运算顺序和数据类型\n    &gt; [8.4]&#123;.mistake&#125;</code></pre>\n<hr>\n<p>title: 练习题与答案<br>quiz: true</p>\n<hr>\n<ol>\n<li><p>编译时多态主要指运算符重载与函数重载，而运行时多态主要指虚函数。 {.quiz .true}</p>\n</li>\n<li><p>有基类 <code>SHAPE</code>，派生类 <code>CIRCLE</code>，声明如下变量：  {.quiz .multi}</p>\n<pre><code class=\"cpp\">SHAPE shape1,*p1;\nCIRCLE circle1,*q1;</code></pre>\n<p> 下列哪些项是 “派生类对象替换基类对象”。</p>\n<ul>\n<li><code>p1=&amp;circle1;</code> {.correct}</li>\n<li><code>q1=&amp;shape1;</code></li>\n<li><code>shape1=circle1;</code> {.correct}</li>\n<li><code>circle1=shape1;</code><br>{.options}<blockquote>\n<ul>\n<li>:heavy_check_mark: 令基类对象的指针指向派生类对象</li>\n<li>:x: 派生类指针指向基类的引用</li>\n<li>:heavy_check_mark: 派生类对象给基类对象赋值</li>\n<li>:x: 基类对象给派生类对象赋值<br>{.options}</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n</li>\n<li><p>下列叙述正确的是 []{.gap} 。 {.quiz}</p>\n<ul>\n<li>虚函数只能定义成无参函数</li>\n<li>虚函数不能有返回值</li>\n<li>能定义虚构造函数</li>\n<li>A、B、C 都不对 {.correct}<br>{.options}</li>\n</ul>\n</li>\n<li><p>如果定义 <code>int e=8; double f=6.4, g=8.9;</code>，则表达式 <code>f+int (e/3*int (f+g)/2)%4</code> 的值为 [9.4]{.gap}。 {.quiz .fill}</p>\n<blockquote>\n<p>注意运算顺序和数据类型<br>[8.4]{.mistake}<br>有基类 SHAPE ，派生类 CIRCLE ，声明如下变量：</p>\n</blockquote>\n<pre><code class=\"bash\">SHAPE shape1,*p1;\nCIRCLE circle1,*q1;</code></pre>\n</li>\n</ol>\n<p>使用说明<br>本功能基于 markdown-it-bracketed-spans 和 markdown-it-attrs</p>\n<pre><code class=\"bash\">\n标签    含义\n&#123;.quiz&#125;    选择题\n&#123;.quiz .multi&#125;    多选题\n&#123;.quiz .true&#125;    正确的判断题\n&#123;.quiz .false&#125;    错误的判断题\n&#123;.quiz .fill&#125;    填空题\n[]&#123;.gap&#125;    空白下划线\n[答案内容]&#123;.gap&#125;    答案内容带下划线\n&#123;.options&#125;    ABCDE 选项\n&#123;.correct&#125;    选择题的正确选项\n&gt;    答案解析\n[8.4]&#123;.mistake&#125;    错题备注</code></pre>\n<p>#emoji 绘文字</p>\n<p>本功能基于 markdown-it-emoji ，所有标签参考戳此</p>\n<pre><code class=\"bash\">:kissing_heart:\n:ring:\n:notes:</code></pre>\n<p>effects 文字特效<br>本功能基于 markdown-it-ins 、 markdown-it-bracketed-spans 和 markdown-it-attrs</p>\n<p>本主题风格颜色通用样式：default、primary、success、info、warning、danger</p>\n<pre><code class=\"bash\">++ 下划线 ++\n++ 波浪线 ++&#123;.wavy&#125;\n++ 着重点 ++&#123;.dot&#125;\n++ 紫色下划线 ++&#123;.primary&#125;\n++ 绿色波浪线 ++&#123;.wavy .success&#125;\n++ 黄色着重点 ++&#123;.dot .warning&#125;\n~~ 删除线～～\n~~ 红色删除线～～&#123;.danger&#125;\n== 荧光高亮 ==\n[赤橙黄绿青蓝紫]&#123;.rainbow&#125;\n[红色]&#123;.red&#125;\n[粉色]&#123;.pink&#125;\n[橙色]&#123;.orange&#125;\n[红色]&#123;.yellow&#125;\n[绿色]&#123;.green&#125;\n[靛青]&#123;.aqua&#125;\n[蓝色]&#123;.blue&#125;\n[紫色]&#123;.purple&#125;\n[灰色]&#123;.grey&#125;\n快捷键 [Ctrl]&#123;.kbd&#125; + [C]&#123;.kbd .red&#125;\nH~2~0\n29^th^</code></pre>\n<p>++ 下划线 ++<br>++ 波浪线 ++{.wavy}<br>++ 着重点 ++{.dot}<br>++ 紫色下划线 ++{.primary}<br>++ 绿色波浪线 ++{.wavy .success}<br>++ 黄色着重点 ++{.dot .warning}<br>~~ 删除线～～<br>~~ 红色删除线～～{.danger}<br>== 荧光高亮 ==<br>[赤橙黄绿青蓝紫]{.rainbow}<br>[红色]{.red}<br>[粉色]{.pink}<br>[橙色]{.orange}<br>[红色]{.yellow}<br>[绿色]{.green}<br>[靛青]{.aqua}<br>[蓝色]{.blue}<br>[紫色]{.purple}<br>[灰色]{.grey}<br>快捷键 [Ctrl]{.kbd} + [C]{.kbd .red}<br>H<del>2</del>0<br>29^th^</p>\n<p>spoiler 隐藏文字<br>本功能基于 markdown-it-spoiler 和 markdown-it-attrs</p>\n<pre><code class=\"bash\">!! 黑幕黑幕黑幕黑幕黑幕黑幕！！： 鼠标滑过显示内容\n!! 模糊模糊模糊模糊模糊模糊！！&#123;.bulr&#125; ： 选中文字显示内容</code></pre>\n<p>!! 黑幕黑幕黑幕黑幕黑幕黑幕！！： 鼠标滑过显示内容<br>!! 模糊模糊模糊模糊模糊模糊！！{.bulr} ： 选中文字显示内容</p>\n<p>#label 标签块<br>本功能基于 markdown-it-bracketed-spans 和 markdown-it-attrs<br>有以下颜色可选</p>\n<pre><code class=\"bash\">[default]&#123;.label&#125;\n[primary]&#123;.label .primary&#125;\n[info]&#123;.label .info&#125;\n[:heavy_check_mark:success]&#123;.label .success&#125;\n[warning]&#123;.label .warning&#125;\n[:broken_heart:danger]&#123;.label .danger&#125;</code></pre>\n<p>[default]{.label}<br>[primary]{.label .primary}<br>[info]{.label .info}<br>[:heavy_check_mark:success]{.label .success}<br>[warning]{.label .warning}<br>[:broken_heart:danger]{.label .danger}</p>\n<p>note 提醒块<br>本功能基于 markdown-it-container<br>标签为：</p>\n<p>开始行    :::[风格颜色]<br>结束行</p>\n<pre><code class=\"bash\">:::default\n默认默认\n:::\n\n:::primary\n基本基本\n:::\n\n:::info\n提示提示\n:::\n\n:::success\n成功成功\n:::\n\n:::warning\n警告警告\n:::\n\n:::danger\n危险危险\n:::\n\n:::danger no-icon\n危险危险\n:::</code></pre>\n<p>:::default<br>默认默认<br>:::</p>\n<p>:::primary<br>基本基本<br>:::</p>\n<p>:::info<br>提示提示<br>:::</p>\n<p>:::success<br>成功成功<br>:::</p>\n<p>:::warning<br>警告警告<br>:::</p>\n<p>:::danger<br>危险危险<br>:::</p>\n<p>:::danger no-icon<br>危险危险<br>:::</p>\n<p>tab 标签卡<br>本功能基于 markdown-it-container<br>标签为：</p>\n<p>开始行    ;;;[同一ID] [标签名称]<br>结束行    ;;;</p>\n<pre><code class=\"bash\">;;;id1 卡片 1\n这里是卡片 1 的内容\n** 加粗 **\n[success]&#123;.label .success&#125;\n\n&#123;% links %&#125;\n- site: 優萌初華\n  owner: 霜月琉璃\n  url: https://shoka.lostyu.me\n  desc: 琉璃的医学 & 编程笔记\n  image: https://cdn.jsdelivr.net/gh/amehime/shoka@latest/images/avatar.jpg\n  color: \"#e9546b\"\n&#123;% endlinks %&#125;\n;;;\n\n;;;id1 卡片 2\n这里是卡片 2 的内容\n:::danger\n危险危险\n:::\n- 第一行\n- 第二行\n;;;\n\n;;;id2 ②号标签卡片 1\n这里是卡片 1 的内容\n;;;\n\n;;;id2 ②号标签卡片 2\n这里是卡片 2 的内容\n;;;</code></pre>\n<p>;;;id1 卡片 1<br>这里是卡片 1 的内容<br>** 加粗 **<br>[success]{.label .success}</p>\n<div class=\"links\"><div class=\"item\" title=\"霜月琉璃\" style=\"--block-color:#e9546b;\"><span class=\"exturl image\" data-url=\"aHR0cHM6Ly9zaG9rYS5sb3N0eXUubWU=\" data-background-image=\"https://cdn.jsdelivr.net/gh/amehime/shoka@latest/images/avatar.jpg\"></span>\n          <div class=\"info\">\n          <span class=\"exturl title\" data-url=\"aHR0cHM6Ly9zaG9rYS5sb3N0eXUubWU=\">優萌初華</span>\n          <p class=\"desc\">琉璃的医学 & 编程笔记</p>\n          </div></div></div>\n<p>;;;</p>\n<p>;;;id1 卡片 2<br>这里是卡片 2 的内容<br>:::danger<br>危险危险<br>:::</p>\n<ul>\n<li>第一行</li>\n<li>第二行<br>;;;</li>\n</ul>\n<p>;;;id2 ②号标签卡片 1<br>这里是卡片 1 的内容<br>;;;</p>\n<p>;;;id2 ②号标签卡片 2<br>这里是卡片 2 的内容<br>;;;</p>\n<p>#collapse 折叠块<br>本功能基于 markdown-it-container<br>标签为：</p>\n<p>开始行    +++[风格颜色] [标题文字]<br>结束行    +++</p>\n<pre><code class=\"bash\">+++ 默认默认 这里是一段文字\n++ 下划线 ++\n+++\n\n\n+++primary 紫色\n:::info\n参考信息\n:::\n\n- 第一行\n- 第二行\n+++\n\n\n+++info  蓝色\n;;;id3 卡片 1\n这里是卡片 1 的内容\n;;;\n\n;;;id3 卡片 2\n这里是卡片 2 的内容\n;;;\n+++\n\n+++success 绿色\n&#123;% links %&#125;\n- site: 優萌初華\n  url: https://shoka.lostyu.me\n  color: \"#e9546b\"\n&#123;% endlinks %&#125;\n+++\n\n+++warning 黄色\n!! 警告警告警告警告警告！！&#123;.bulr&#125;\n[label]&#123;.label .success&#125;\n+++\n\n+++danger 红色\n[danger]&#123;.label .danger&#125;\n+++</code></pre>\n<p>+++ 默认默认 这里是一段文字<br>++ 下划线 ++<br>+++</p>\n<p>+++primary 紫色<br>:::info<br>参考信息<br>:::</p>\n<ul>\n<li>第一行</li>\n<li>第二行</li>\n</ul>\n<p>+++</p>\n<p>+++info  蓝色<br>;;;id3 卡片 1<br>这里是卡片 1 的内容<br>;;;</p>\n<p>;;;id3 卡片 2<br>这里是卡片 2 的内容<br>;;;<br>+++</p>\n<p>+++success 绿色</p>\n<div class=\"links\"><div class=\"item\" title=\"優萌初華\" style=\"--block-color:#e9546b;\"><span class=\"exturl image\" data-url=\"aHR0cHM6Ly9zaG9rYS5sb3N0eXUubWU=\" data-background-image=\"/images/404.png\"></span>\n          <div class=\"info\">\n          <span class=\"exturl title\" data-url=\"aHR0cHM6Ly9zaG9rYS5sb3N0eXUubWU=\">優萌初華</span>\n          <p class=\"desc\">https://shoka.lostyu.me</p>\n          </div></div></div>\n<p>+++</p>\n<p>+++warning 黄色<br>!! 警告警告警告警告警告！！{.bulr}<br>[label]{.label .success}<br>+++</p>\n<p>+++danger 红色<br>[danger]{.label .danger}<br>+++</p>\n<p>taskList 待办事项<br>本功能基于 markdown-it-task-checkbox 。<br>可以利用 markdown-it-attrs 添加风格颜色，只可以给 ul 标签添加，需要新建两行。</p>\n<pre><code class=\"bash\">- [ ] 这是一个小叉叉\n- [x] 这是一个红色勾勾\n\n&#123;.danger&#125;\n\n- [ ] 未完成\n- [x] 完成\n\n&#123;.primary&#125;\n\n- [ ] 未完成\n- [x] 默认颜色</code></pre>\n<ul>\n<li><input disabled=\"\" type=\"checkbox\"> 这是一个小叉叉</li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 这是一个红色勾勾</li>\n</ul>\n<p>{.danger}</p>\n<ul>\n<li><input disabled=\"\" type=\"checkbox\"> 未完成</li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 完成</li>\n</ul>\n<p>{.primary}</p>\n<ul>\n<li><input disabled=\"\" type=\"checkbox\"> 未完成</li>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 默认颜色</li>\n</ul>\n<p>furigana 文字注音<br>原本用于日语汉字假名注音，但别的注音也可以。<br>为了兼容性，采用 markdown-it-ruby 的基本格式： {文字^注音} ，并且为了兼容表格，将分隔符由 | 换成了 ^ 。<br>注音分隔基于 furigana-markdown-it 显示说明看这里</p>\n<p>{取り返す^とりかえす}    取とり返かえす<br>{可愛い犬^か+わい・い・いぬ}    可愛かわいい犬いぬ<br>{可愛い犬^か・わい・いいぬ}    可か愛わいい犬いぬ<br>{アクセラレータ^accelerator}    アクセラレータaccelerator<br>{accelerator^アクセラレータ}    acceleratorアクセラレータ<br>{食べる^たべる}    食たべる<br>{食べる^=たべる}    食べるたべる<br>{あいうえお^*}    あ●い●う●え●お●<br>{あいうえお^*❤}    あ❤い❤う❤え❤お❤<br>{常用账号^contact}    常用账号</p>\n<p>media 多媒体<br>本功能基于 Hexo Tag 功能，使用 media 标签，目前可选择两种类型，即 audio 和 video 。</p>\n<pre><code class=\"bash\">&#123;% media audio %&#125;\n... 音频列表\n&#123;% endmedia %&#125;\n\n&#123;% media video %&#125;\n... 视频列表\n&#123;% endmedia %&#125;</code></pre>\n<p>标签包绕一段 yml 格式的内容，格式与背景音乐的配置类似。</p>\n<p>亦可以直接使用网易云、虾米、QQ 音乐的播放列表、单曲。</p>\n<pre><code class=\"bash\">&#123;% media audio %&#125;\n- title: 列表 1\n  list:\n    - https://music.163.com/#/playlist?id=2943811283\n    - https://music.163.com/#/playlist?id=2297706586\n- title: 列表 2\n  list:\n    - https://music.163.com/#/playlist?id=2031842656\n&#123;% endmedia %&#125;\n\n\n&#123;% media video %&#125;\n- name: \"测试 1\"\n  url: https://cdn.kastatic.org/ka-youtube-converted/O_nY1TM2RZM.mp4/O_nY1TM2RZM.mp4#t=0\n- name: \"测试 2\"\n  url: https://cdn.kastatic.org/ka-youtube-converted/O_nY1TM2RZM.mp4/O_nY1TM2RZM.mp4#t=0\n&#123;% endmedia %&#125;</code></pre>\n<p>math 数学公式<br>本功能基于 markdown-it-katex<br>在 Front Matter 中添加 math: true 以支持 KaTex</p>\n<pre><code class=\"bash\">---\ntitle: 数学公式显示\nmath: true\n---\n\n行内公式：$\\sqrt &#123;3x-1&#125;+(1+x)^2$\n\n独立块显示：\n$$\\begin &#123;array&#125;&#123;c&#125;\n\n\\nabla \\times \\vec &#123;\\mathbf &#123;B&#125;&#125; -\\, \\frac1c\\, \\frac &#123;\\partial\\vec &#123;\\mathbf &#123;E&#125;&#125;&#125;&#123;\\partial t&#125; &amp;\n= \\frac &#123;4\\pi&#125;&#123;c&#125;\\vec &#123;\\mathbf &#123;j&#125;&#125;    \\nabla \\cdot \\vec &#123;\\mathbf &#123;E&#125;&#125; &amp; = 4 \\pi \\rho \\\\\n\n\\nabla \\times \\vec &#123;\\mathbf &#123;E&#125;&#125;\\, +\\, \\frac1c\\, \\frac &#123;\\partial\\vec &#123;\\mathbf &#123;B&#125;&#125;&#125;&#123;\\partial t&#125; &amp; = \\vec &#123;\\mathbf &#123;0&#125;&#125; \\\\\n\n\\nabla \\cdot \\vec &#123;\\mathbf &#123;B&#125;&#125; &amp; = 0\n\n\\end &#123;array&#125;$$</code></pre>\n<p>mermaid 流程图<br>本功能基于 markdown-it-mermaid<br>在 Front Matter 中添加 mermaid: true 以支持 Mermaid</p>\n<pre><code class=\"bash\">---\ntitle: 流程图显示\nmermaid: true\n---\n\n```mermaid\ngraph LR\n    A [Square Rect] -- Link text --&gt; B ((Circle))\n    A --&gt; C (Round Rect)\n    B --&gt; D &#123;Rhombus&#125;\n    C --&gt; D</code></pre>\n<pre><code class=\"mermaid\">sequenceDiagram\n    loop Daily query\n        Alice-&gt;&gt;Bob: Hello Bob, how are you?\n        alt is sick\n            Bob-&gt;&gt;Alice: Not so good :(\n        else is well\n            Bob-&gt;&gt;Alice: Feeling fresh like a daisy\n        end\n\n        opt Extra response\n            Bob-&gt;&gt;Alice: Thanks for asking\n        end\n    end</code></pre>\n<pre><code>---\ntitle: 流程图显示\nmermaid: true\n---\n\n```mermaid\ngraph LR\n    A [Square Rect] -- Link text --&gt; B ((Circle))\n    A --&gt; C (Round Rect)\n    B --&gt; D &#123;Rhombus&#125;\n    C --&gt; D</code></pre>\n<pre><code class=\"mermaid\">sequenceDiagram\n    loop Daily query\n        Alice-&gt;&gt;Bob: Hello Bob, how are you?\n        alt is sick\n            Bob-&gt;&gt;Alice: Not so good :(\n        else is well\n            Bob-&gt;&gt;Alice: Feeling fresh like a daisy\n        end\n\n        opt Extra response\n            Bob-&gt;&gt;Alice: Thanks for asking\n        end\n    end</code></pre>\n",
            "tags": [
                "hexo"
            ]
        },
        {
            "id": "http://47.97.229.110/2021/01/25/Linux%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/",
            "url": "http://47.97.229.110/2021/01/25/Linux%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/",
            "title": "Linux搭建博客",
            "date_published": "2021-01-25T05:58:22.000Z",
            "content_html": "<p>Hexo简介<br>Hexo是一款基于Node.js的静态博客框架，依赖少易于安装使用，可以方便的生成静态网页托管在GitHub和Gitee上，是搭建博客的首选框架。大家可以进入hexo官网进行详细查看，因为Hexo的创建者是台湾人，对中文的支持很友好，可以选择中文进行查看</p>\n<p>安装Git<br>Git是目前世界上最先进的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理</p>\n<pre><code class=\"bash\">$ apt-get install git -y</code></pre>\n<p>安装nodejs<br>Hexo是基于nodeJS编写的，所以需要安装一下nodeJs和里面的npm工具</p>\n<p>wp-block-code</p>\n<pre><code class=\"bash\">$ apt-get install nodejs npm -y</code></pre>\n<p>安装完后，输入命令</p>\n<p>wp-block-code</p>\n<pre><code class=\"bash\">$ node -v</code></pre>\n<p>wp-block-code</p>\n<pre><code class=\"bash\">$ npm -v</code></pre>\n<p>检查是否安装成功</p>\n<p>更换npm源为淘宝源</p>\n<p>wp-block-code</p>\n<pre><code class=\"bash\">$ npm config set registry https://registry.npm.taobao.org</code></pre>\n<p>安装hexo<br>前面git和nodejs安装好后，就可以安装hexo了，先创建一个文件夹filename，然后cd到这个文件夹下</p>\n<p>输入命令</p>\n<p>wp-block-code</p>\n<pre><code class=\"bash\">$ npm install -g hexo-cli</code></pre>\n<p>输入命令</p>\n<p>wp-block-code</p>\n<pre><code class=\"bash\">$ hexo -v</code></pre>\n<p>查看版本信息</p>\n<p>初始化hexo</p>\n<pre><code class=\"bash\">wp-block-code\n$ hexo init filename(文件名随意定义)\nwp-block-code\n$ cd filename //进入这个文件夹\nwp-block-code\n$ npm install</code></pre>\n<pre><code class=\"bash\">$ cd &lt;folder&gt; #说明：将操作位置转移到将要存放项目的文件夹目录（便于区分，我的项目文件夹名为hexo,~/root/hexo以下将使用这个文件夹）\n$ hexo init #说明：自动在文件夹（hexo1）中创建项目所需的文件\n$ npm install #说明：安装依赖包\n$ hexo generate #说明：构建，会在hexo1中创建public文件夹</code></pre>\n<p>执行完以上命令后，会多出以下文件和文件夹<br>例如<br>新建完成后，指定文件夹目录下有：</p>\n<pre><code class=\"bash\">_config.yml：站点的配置文件，需要备份\nthemes：主题文件夹，需要备份\nsource：博客文章的 .md 文件，需要备份\nscaffolds：文章的模板，需要备份\npackage.json：安装包的名称，需要备份\n.gitignore：限定在 push 时哪些文件可以忽略，需要备份\n.git：主题和站点都有，标志这是一个 git 项目，不需要备份\nnode_modules：是安装包的目录，在执行 npm install 的时候会重新生成，不需要备份\npublic：是 hexo g 生成的静态网页，不需要备份\n.deploy_git：同上，hexo g 也会生成，不需要备份</code></pre>\n<p>db.json：文件，不需要备份<br>输入命令<br>wp-block-code</p>\n<pre><code class=\"bash\">$ hexo g</code></pre>\n<p>输入命令<br>wp-block-code</p>\n<pre><code class=\"bash\">$ hexo s</code></pre>\n<p>打开hexo的服务<br>在浏览器输入</p>\n<pre><code class=\"bash\">$ http://localhost:4000</code></pre>\n<p>就可以看到你生成的博客<br>使用ctrl+c停止服务<br>Hexo+Github<br>GitHub创建个人仓库<br>注册登录github官网，点击右上角加号，点击New repository，新建仓库<br>创建一个和用户名相同的仓库,即<span class=\"exturl\" data-url=\"aHR0cDovL3h4eHguZ2l0aHViLmlvLOWFtuS4rXh4eOaYr2dpdGh1YueahOeUqOaIt+WQjS8=\">http://xxxx.github.io，其中xxx是github的用户名</span><br>点击create repository<br>Git初始化设置<br>输入命令<br>wp-block-code</p>\n<pre><code class=\"bash\">$ git config --global user.name &quot;yourname&quot; </code></pre>\n<p>wp-block-code</p>\n<pre><code class=\"bash\">$ git config --global user.email &quot;youremail&quot;</code></pre>\n<p>yourname是github用户名，youremail是注册github的邮箱<br>wp-block-code</p>\n<pre><code class=\"bash\">$ git config user.name </code></pre>\n<p>wp-block-code</p>\n<pre><code class=\"bash\">$ git config user.email</code></pre>\n<p>检查是否正确，输入命令<br>生成SSH添加到GitHub<br>输入命令，创建SSH,一路回车<br>wp-block-code</p>\n<pre><code class=\"bash\">$ ssh-keygen -t rsa -C &quot;youremail&quot;</code></pre>\n<p>查看SSH KEY，输入命令<br>wp-block-code</p>\n<pre><code class=\"bash\">$ cat ~/.ssh/id_rsa.pub</code></pre>\n<p>复制id_rsa.pub里面的全部内容<br>在github的setting中，找到SSH keys的设置选项，点击New SSH key，粘贴id_rsa.pub里面的全部内容<br>输入命令<br>wp-block-code</p>\n<pre><code class=\"bash\">$ ssh -T git@github.com</code></pre>\n<p>查看是否连接成功<br>打开站点配置文件 _config.yml，修改添加以下内容<br>wp-block-code</p>\n<pre><code class=\"bash\">deploy:\n  type: git\n  repo: git@github.com:yourgithubname/yourgithubname.github.io.git\n  branch: master</code></pre>\n<p>安装deploy-git ，也就是部署的命令,这样才能用命令部署到github<br>wp-block-code</p>\n<pre><code class=\"bash\">$ npm install hexo-deployer-git --save</code></pre>\n<p>输入命令<br>wp-block-code</p>\n<pre><code class=\"bash\">$ hexo clean 第一次安装不用清缓存\n$ hexo clean &amp;&amp;　hexo g -d 　缩写\n$ hexo g = hexo generate 生成静态文件\n$ hexo generate -deploy 生成静态文件后立即部署网站</code></pre>\n<p>打开下面的网址</p>\n<pre><code class=\"bash\">$ http://yourname.github.io</code></pre>\n<p>就可看到和<br><span class=\"exturl\" data-url=\"aHR0cDovL2xvY2FsaG9zdDo0MDAwLw==\">http://localhost:4000</span><br>一样的了！<br>关联Git仓库<br>wp-block-code</p>\n<pre><code class=\"bash\">$ git clone https://github.com/你的用户名/你的用户名.github.io.git</code></pre>\n<p>执行之后会在当前目录生成’你的用户名.github.io’的文件夹，这是关联github仓库的文件夹，需要上传的文件都会移动到这里<br>更多精彩内容请点击hexo官网<br>(附上我的博客链接)<br>Hexo+Gitee<br>Gitee创建个人仓库<br>打开码云官网，注册登陆，创建项目，点击右上角加号，新建仓库<br>开启 Gitee Pages<br>点击启动<br>启动后，点击蓝色链接打开网址<br>初始化Git设置<br>输入命令<br>wp-block-code</p>\n<pre><code class=\"bash\">$ git config --global user.name &quot;这里输入你的Gitee注册名&quot;// 按回车\n$ git config --global user.email &quot;这里输你的Gitee邮箱&quot;</code></pre>\n<p>生成SSH密钥文件<br>wp-block-code</p>\n<pre><code class=\"bash\">$ ssh-keygen -t rsa -C &quot;你的Gitee注册邮箱&quot;\n$ // 可不输入，三个回车</code></pre>\n<p>复制粘贴到码云<br>配置 _config.yml<br>点击复制克隆/下载里面的https的内容<br>修改添加_config.yml以下内容<br>wp-block-code</p>\n<pre><code class=\"bash\">url: Gitee Pages 服务，网站地址： https://空间名.gitee.io/仓库名(粘贴)\nroot: /仓库名/\nwp-block-code\ndeploy:\n  type: git\n  repo: https://gitee.com/空间名/仓库名(粘贴)\n  branch: master</code></pre>\n<p>基础配置可以参考官方文档的配置说明</p>\n<pre><code class=\"bash\">$ wp-block-code\n$ hexo clean &amp;&amp;　hexo g -d 　缩写 清缓存\n$ hexo g = hexo generate 生成静态文件\n$ hexo generate -deploy 生成静态文件后立即部署网站自动上传到gitee</code></pre>\n<p>打开Gitee Pages 服务 ，每次上传或改动，都要点击“更新”打开网址访问</p>\n",
            "tags": [
                "hexo"
            ]
        }
    ]
}